<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>嵌入式实验与课设 | zx's Blog</title><meta name="author" content="zx"><meta name="copyright" content="zx"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="从0到1的嵌入式之旅如何在几乎旷了一个学期的课的情况下，在4天5夜内完成一整个学期的嵌入式实验与课设，敬请期待。 实验1搭建stm32开发环境并使用GPIO 实验内容1. 创建STM32CubeIDE&#x2F;STM32CubeMX工程并生成代码 安装STM32CubeIDE&#x2F;STM32CubeMX软件；使用STM32CubeMX图形化界面配置STM32 MCU；生成初始化代码。 2.">
<meta property="og:type" content="article">
<meta property="og:title" content="嵌入式实验与课设">
<meta property="og:url" content="https://zx2023qj.github.io/2024/12/27/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%9E%E9%AA%8C%E4%B8%8E%E8%AF%BE%E8%AE%BE/index.html">
<meta property="og:site_name" content="zx&#39;s Blog">
<meta property="og:description" content="从0到1的嵌入式之旅如何在几乎旷了一个学期的课的情况下，在4天5夜内完成一整个学期的嵌入式实验与课设，敬请期待。 实验1搭建stm32开发环境并使用GPIO 实验内容1. 创建STM32CubeIDE&#x2F;STM32CubeMX工程并生成代码 安装STM32CubeIDE&#x2F;STM32CubeMX软件；使用STM32CubeMX图形化界面配置STM32 MCU；生成初始化代码。 2.">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zx2023qj.github.io/img/3.jpg">
<meta property="article:published_time" content="2024-12-27T12:48:44.000Z">
<meta property="article:modified_time" content="2025-01-01T13:47:15.236Z">
<meta property="article:author" content="zx">
<meta property="article:tag" content="日常">
<meta property="article:tag" content="作业">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zx2023qj.github.io/img/3.jpg"><link rel="shortcut icon" href="/img/3.jpg"><link rel="canonical" href="https://zx2023qj.github.io/2024/12/27/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%9E%E9%AA%8C%E4%B8%8E%E8%AF%BE%E8%AE%BE/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '嵌入式实验与课设',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-01-01 21:47:15'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/3.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">32</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">30</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">20</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/2.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="zx's Blog"><span class="site-name">zx's Blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">嵌入式实验与课设</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-12-27T12:48:44.000Z" title="发表于 2024-12-27 20:48:44">2024-12-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-01-01T13:47:15.236Z" title="更新于 2025-01-01 21:47:15">2025-01-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/">课程学习</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="嵌入式实验与课设"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="从0到1的嵌入式之旅"><a href="#从0到1的嵌入式之旅" class="headerlink" title="从0到1的嵌入式之旅"></a>从0到1的嵌入式之旅</h2><p>如何在几乎旷了一个学期的课的情况下，在4天5夜内完成一整个学期的嵌入式实验与课设，敬请期待。</p>
<h3 id="实验1"><a href="#实验1" class="headerlink" title="实验1"></a>实验1</h3><p>搭建stm32开发环境并使用GPIO</p>
<h4 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h4><p><strong>1.</strong> <strong>创建STM32CubeIDE&#x2F;STM32CubeMX工程并生成代码</strong></p>
<p>安装STM32CubeIDE&#x2F;STM32CubeMX软件；<br>使用STM32CubeMX图形化界面配置STM32 MCU；<br>生成初始化代码。</p>
<p><strong>2.</strong> <strong>通过GPIO驱动LED和开关按键</strong></p>
<p>根据图 1所示的开发板LED和开关按键电路图，设计并实现具有如下功能的程序：<br>按KeyLeft，使LED1输出翻转<br>按KeyRight，使LED2输出翻转<br>按下KeyUp键时使LED1和LED2的输出都翻转</p>
<p>开发板相关的原理图如下：</p>
<p><img src="/2024/12/27/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%9E%E9%AA%8C%E4%B8%8E%E8%AF%BE%E8%AE%BE/image-20241227205217151.png" alt="image-20241227205217151"></p>
<h4 id="实验思路"><a href="#实验思路" class="headerlink" title="实验思路"></a>实验思路</h4><p><strong>分析电路</strong></p>
<p>对于LED模块<br>单片机通过控制 GPIO 引脚的电平来点亮或熄灭 LED：<br>GPIO 输出 低电平 时，LED 正极与 VCC3.3 形成回路，LED 点亮。<br>GPIO 输出 高电平 时，无电流流过 LED，LED 熄灭。</p>
<p>对于KAY模块<br>按键的状态通过读取对应 GPIO 引脚的电平判断：<br>WK_UP：<br>默认未按下时，GPIO 引脚通过下拉电阻保持 低电平。<br>按下时，直接与 VCC3.3 相连，GPIO 读取 高电平。<br>KEY0&#x2F;KEY1&#x2F;KEY2：<br>默认未按下时，通过上拉电阻保持 高电平。<br>按下时，直接接地，GPIO 读取 低电平。</p>
<p><strong>分析需求</strong></p>
<p>按KeyLeft，使LED1输出翻转<br>按KeyRight，使LED2输出翻转<br>按下KeyUp键时使LED1和LED2的输出都翻转</p>
<p>在实验要求中<br>KeyLeft对应PE4，KeyRight对应PE2，KeyUp对应PA0<br>LED1对应PF9，LED2对应PF10</p>
<p>读取KeyLeft，KeyRight，KeyUp的值对LED1和LED2进行控制</p>
<h4 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h4><p>1、先在stm32cubemx中对引脚进行设置</p>
<p><img src="/2024/12/27/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%9E%E9%AA%8C%E4%B8%8E%E8%AF%BE%E8%AE%BE/image-20241228171436449.png" alt="image-20241228171436449"></p>
<p>然后生成代码</p>
<p>2、读取三个GPIO引脚的输入</p>
<p>对于KeyUp引脚，默认为低电平，按下时为高电平，因此检验KeyUp是否为高电平<br>对于KeyLeft和KeyRight，默认为高电平，按下时为低电平，因此检验KeyLeft和KeyRight是否为低电平</p>
<p>3、根据电平作出判断</p>
<p>由于按下按键时可能会有按键抖动，因此需要delay进行防抖，delay之后再次检测电平，通过togglePin翻转电平，再进行阻塞</p>
<p>4、编写代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">while (1)</span><br><span class="line"> &#123;</span><br><span class="line">  if(HAL_GPIO_ReadPin(KeyUp_GPIO_Port, KeyUp_Pin) == GPIO_PIN_SET)&#123;</span><br><span class="line">	  HAL_Delay(50);</span><br><span class="line">	  if(HAL_GPIO_ReadPin(KeyUp_GPIO_Port, KeyUp_Pin) == GPIO_PIN_SET)&#123;</span><br><span class="line">		  HAL_GPIO_TogglePin(LED1_GPIO_Port, LED1_Pin);</span><br><span class="line">		  HAL_GPIO_TogglePin(LED2_GPIO_Port, LED2_Pin);</span><br><span class="line">	  &#125;</span><br><span class="line">	  while(HAL_GPIO_ReadPin(KeyUp_GPIO_Port, KeyUp_Pin) == GPIO_PIN_SET);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if(HAL_GPIO_ReadPin(KeyLeft_GPIO_Port, KeyLeft_Pin) == GPIO_PIN_RESET)&#123;</span><br><span class="line">  	  HAL_Delay(50);</span><br><span class="line">  	  if(HAL_GPIO_ReadPin(KeyLeft_GPIO_Port, KeyLeft_Pin) == GPIO_PIN_RESET)&#123;</span><br><span class="line">  		  HAL_GPIO_TogglePin(LED1_GPIO_Port, LED1_Pin);</span><br><span class="line">  	  &#125;</span><br><span class="line">  	  while(HAL_GPIO_ReadPin(KeyLeft_GPIO_Port, KeyLeft_Pin) == GPIO_PIN_RESET);</span><br><span class="line">  &#125;</span><br><span class="line">  if(HAL_GPIO_ReadPin(KeyRight_GPIO_Port, KeyRight_Pin) == GPIO_PIN_RESET)&#123;</span><br><span class="line">	  HAL_Delay(50);</span><br><span class="line">  	  if(HAL_GPIO_ReadPin(KeyRight_GPIO_Port, KeyRight_Pin) == GPIO_PIN_RESET)&#123;</span><br><span class="line">  	  	  HAL_GPIO_TogglePin(LED2_GPIO_Port, LED2_Pin);</span><br><span class="line">  	  &#125;</span><br><span class="line">  	  while(HAL_GPIO_ReadPin(KeyRight_GPIO_Port, KeyRight_Pin) == GPIO_PIN_RESET);</span><br><span class="line">  &#125;                                       </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>5、演示视频</p>
<p><video width="800" height="450" src="https://zx2023qj.github.io/2024/12/27/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%9E%E9%AA%8C%E4%B8%8E%E8%AF%BE%E8%AE%BE/eead47d28a4988c683dd04e60227c869.mp4" controls></video></p>
<h4 id="知识补充"><a href="#知识补充" class="headerlink" title="知识补充"></a>知识补充</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在本实验中使用的是GPIO的普通推挽输出模式</span><br><span class="line">上拉电阻将GPIO置为高电平，下拉电阻将GPIO置为低电平</span><br><span class="line">STLINK接线时连接的是SWCLK，SWDIO，GND和3.3V，需要和ARM仿真器连接在一起</span><br></pre></td></tr></table></figure>

<h3 id="GPIO八大输入输出模式解析"><a href="#GPIO八大输入输出模式解析" class="headerlink" title="GPIO八大输入输出模式解析"></a>GPIO八大输入输出模式解析</h3><p>普通推挽输出，选择输出0V或者3.3V。</p>
<p>普通开漏输出，一直输出0V，工作电压由外部电源决定，更加灵活，但是注意电压的上限和IO口的上限。</p>
<p>由于输出不可能既由芯片内部决定，又由片上的外设，如串口等决定，因此如果由片上外设输出，则分类出了复用推挽输出和复用开漏输出。</p>
<p><img src="/2024/12/27/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%9E%E9%AA%8C%E4%B8%8E%E8%AF%BE%E8%AE%BE/image-20241228220537662.png" alt="image-20241228220537662"></p>
<p><img src="/2024/12/27/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%9E%E9%AA%8C%E4%B8%8E%E8%AF%BE%E8%AE%BE/image-20241228220649298.png" alt="image-20241228220649298"></p>
<p>输入模式则分为上拉输入，下拉输入，浮空输入，模拟输入</p>
<p>上拉输入使用上拉电阻，将输入的初始电平维持在高电平；下拉输入使用下拉电阻，将输入的初始电平维持在低电平；覅空输入则是不使用上拉也不使用下拉，初始电平处于随机状态。</p>
<p>模拟输入则是不经过TTL肖特基触发器，直接读取模拟信号，而经过TTL肖特基触发器之后的就是数字信号，分为高低电平。</p>
<p>由于片上外设和芯片内部在读取输入时并不冲突，因此也就不区分普通输入和复用输入。</p>
<p><img src="/2024/12/27/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%9E%E9%AA%8C%E4%B8%8E%E8%AF%BE%E8%AE%BE/image-20241228220916947.png" alt="image-20241228220916947"></p>
<h3 id="中断条件"><a href="#中断条件" class="headerlink" title="中断条件"></a>中断条件</h3><p>串口USART，定时器TIM，I^2C，GPIO都可以造成中断。</p>
<p>此处只介绍GPIO造成的中断，将GPIO设置为EXTI之后可以使用GPIO中断，在NVIC（嵌套向量中断控制器）中可以设置GPIO中断的类型，包括External Interrupt  Mode with Rising Edge Trigger、External Interrupt  Mode with Falling Edge Trigger、External Interrupt  Mode with Rising and Falling Edge Trigger、External Event Mode with Rising Edge Trigger、External Event  Mode with Falling Edge Trigger、External Event  Mode with Rising and Falling Edge Trigger。前三种为芯片内部中断、后三种Event是用于片上外设的，分为上升沿中断、下降沿中断和上升下降沿中断三种不同的触发类型。</p>
<p>在检测到中断事件之后，NVIC会执行对应的EXTI对应的handler函数，从而实现中断需要的操作。</p>
<p>对于中断事件，存在抢占优先级和响应优先级两种优先级。优先级的数值越小，对应的优先级就越高。</p>
<p>其作用如下图：</p>
<p><img src="/2024/12/27/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%9E%E9%AA%8C%E4%B8%8E%E8%AF%BE%E8%AE%BE/image-20241228225743695.png" alt="image-20241228225743695"></p>
<h3 id="实验2"><a href="#实验2" class="headerlink" title="实验2"></a>实验2</h3><h4 id="实验内容-1"><a href="#实验内容-1" class="headerlink" title="实验内容"></a>实验内容</h4><p><strong>1.</strong> <strong>抢占优先级相同的中断试验</strong></p>
<p>根据图 1所示的开发板LED和开关按键电路图，使用STM32中断功能设计并实现具有如下功能的程序：<br>按KeyLeft，使LED1输出翻转，按KeyRight，使LED2输出翻转；<br>按下KeyLeft键后再快速按下KeyRight键，KeyRight键控制的LED2并不会立刻变化，需等待1秒后才变化。</p>
<p><strong>2.</strong> <strong>抢占优先级不同的中断试验</strong></p>
<p>根据图 1所示的开发板LED和开关按键电路图，使用STM32中断功能设计并实现具有如下功能的程序：<br>按KeyLeft，使LED1输出翻转，按KeyRight，使LED2输出翻转；<br>按下KeyRight键（优先级为2）后快速再按下KeyLeft键，KeyLeft键（优先级为1）控制的LED1会立刻变化。</p>
<p>开发板对应的原理图跟实验1是相同的这里就不作赘述。</p>
<p>记住KeyLeft对应PE4，KeyRight对应PE2，KeyUp对应PA0，LED1对应PF9，LED2对应PF10即可。</p>
<h4 id="实验思路-1"><a href="#实验思路-1" class="headerlink" title="实验思路"></a>实验思路</h4><p><strong>1.</strong> <strong>抢占优先级相同的中断试验</strong></p>
<p>根据实验要求，在按下KeyLeft之后，需要执行翻转LED1的操作；在按下KeyRight之后，需要执行翻转LED2的操作；而在按下KeyLeft再快速按下KeyRight之后，由于相同的抢占优先级，会先执行翻转LED1再执行翻转LED2，但是在这期间会有延时，也就是说在按下KeyLeft之后，先翻转LED1，然后延时1s，再返回到主进程。</p>
<p><strong>2.</strong> <strong>抢占优先级不同的中断试验</strong></p>
<p>跟1不同的点是，按下KeyRight之后再按下KeyLeft，KeyLeft对应的LED1会立即发生变化。</p>
<p>所以基本的代码是相同的，只需要对抢占优先级进行修改即可。</p>
<h4 id="实验步骤-1"><a href="#实验步骤-1" class="headerlink" title="实验步骤"></a>实验步骤</h4><p>1、先对引脚进行设置，再对NVIC进行设置。由于KeyLeft和KeyRight，默认为高电平，按下时为低电平，因此设置下降沿触发器为中断条件。然后在NVIC中对抢占优先级进行设置，由于在其中还涉及到delay操作，因此对System tick Timer也进行设置，启用EXTI2和EXTI4（这是因为KeyLeft和KeyRight对应的引脚为PE2和PE4）。</p>
<p><img src="/2024/12/27/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%9E%E9%AA%8C%E4%B8%8E%E8%AF%BE%E8%AE%BE/image-20241228235337487.png" alt="image-20241228235337487"></p>
<p><img src="/2024/12/27/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%9E%E9%AA%8C%E4%B8%8E%E8%AF%BE%E8%AE%BE/image-20241229012751614.png" alt="image-20241229012751614"></p>
<p><img src="/2024/12/27/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%9E%E9%AA%8C%E4%B8%8E%E8%AF%BE%E8%AE%BE/image-20241229012609422.png" alt="image-20241229012609422"></p>
<p>2、生成硬件代码，由于<strong>HAL_GPIO_EXTI_Callback</strong>是一个弱链接回调函数，可以通过override（重写）重新实现这个回调函数。</p>
<p>3、编写代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)&#123;</span><br><span class="line">	if(GPIO_Pin == KeyLeft_Pin)&#123;</span><br><span class="line">		HAL_GPIO_TogglePin(LED1_GPIO_Port, LED1_Pin);</span><br><span class="line">		HAL_Delay(1000);</span><br><span class="line">	&#125;</span><br><span class="line">	if(GPIO_Pin == KeyRight_Pin)&#123;</span><br><span class="line">		HAL_GPIO_TogglePin(LED2_GPIO_Port, LED2_Pin);</span><br><span class="line">		HAL_Delay(1000);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、演示视频</p>
<p>优先级相同</p>
<p><video width="800" height="450" src="https://zx2023qj.github.io/2024/12/27/嵌入式实验与课设/321a391fa9be55deaff36c91d41a3f89.mp4" controls></video></p>
<p>优先级不同</p>
<p><video width="800" height="450" src="https://zx2023qj.github.io/2024/12/27/嵌入式实验与课设/4ef8365a91f2e0c492b921c6712519f0.mp4" controls></video></p>
<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>HCLK（主时钟源） -&gt;  分频器 -&gt; 倍频器 -&gt; 定时器时钟源</p>
<p>n-1分频器可以将脉冲分为n分频，</p>
<p>72MHz的意思是1s会发送72M次时钟脉冲。通过分频器之后脉冲的频率就会下降，以便于计数。</p>
<p>定时器可以串联。</p>
<p>自动重装载寄存器用于给定时器计数，发送定时器更新中断，触发定时器事件，设置时需要-1。</p>
<p>prescaler（预分频器）</p>
<p>counter period(autoreload register)自动重装载寄存器</p>
<p>auto-relaod preload 自动重装载预装载，开启该选项之后可以在当前时间周期运行完之后修改自动重装载寄存器，而不是立即修改。</p>
<p>假设APB（也就是定时器时钟源的频率为72Mhz），设prescaler为7200-1，则可以将时钟源分频为10000hz，那么如果将counter period设为10000-1，就实现了定时1s的效果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">定时器相关函数</span><br><span class="line">//启动定时器</span><br><span class="line">HAL_TIM_Base_Start(&amp;htim);</span><br><span class="line">//启动开启了中断的定时器</span><br><span class="line">HAL_TIM_Base_Start_IT(&amp;htim);</span><br><span class="line">//定时器中断更新函数</span><br><span class="line">HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef* htim)&#123;&#125;;</span><br><span class="line">//读取定时器的值</span><br><span class="line">__HAL_TIM_GET_COUNTER(&amp;htim);</span><br><span class="line">//读取触发器中断标志位，用于判断中断是自动重载寄存器触发的还是从模式控制器产生的</span><br><span class="line">__HAL_TIM_GET_FLAG(htim,TIM_FLAG_TRIGGER)</span><br><span class="line">//清零触发器中断标志位</span><br><span class="line">__HAL_TIM_CLEAR_FLAG(htim,TIM_FLAG_TRIGGER)</span><br></pre></td></tr></table></figure>

<p>通用定时器可以通过ETR2来使用定时器的外部时钟模式2，对从外部输入的脉冲进行计数。也可以通过设置从模式控制器为外部时钟模式1，选择引脚，可以选择ETR1、TI1_ED、TI2FP2、TI1FP1，跟ETR2的效果差不多。</p>
<p>从模式控制器还有reset、gated、trigger三个模式。reset可以对定时器进行reset。可以理解为除了自动重装载寄存器之外的另一个reset定时器的方式。gated模式可以对输入的脉冲进行过滤，并触发触发器中断，例如设置为高电平通过，低电平过滤，则当输入的为低电平时，定时器停止计数并触发中断。trigger模式会在输入的脉冲变化时开启计数，且开启计数后不会停止。one pluse mode启动单脉冲模式，则定时器达到自动重装载寄存器的值之后，清零但是不会自动开启计数，可以配合trigger使用，通过trigger启动。</p>
<p>定时器的输入捕获模式可以测量脉冲宽度，输出比较模式可以输出脉冲宽度，实现PWM（详见PWM）。</p>
<h3 id="实验3"><a href="#实验3" class="headerlink" title="实验3"></a>实验3</h3><h4 id="实验内容-2"><a href="#实验内容-2" class="headerlink" title="实验内容"></a>实验内容</h4><p><strong>1.</strong> <strong>使用STM32CubeMX配置时钟树</strong></p>
<p>根据图 1所示配置，使用STM32CubeMX配置STM32F407ZGT6的时钟树，并生成工程代码。<img src="/2024/12/27/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%9E%E9%AA%8C%E4%B8%8E%E8%AF%BE%E8%AE%BE/image-20241231145704555.png" alt="image-20241231145704555"></p>
<p><strong>2.</strong> <strong>使用STM32F407ZG6的基本定时器</strong></p>
<p>TIM6设置为连续定时模式，定时周期500ms，以中断方式启动TIM6，在UEV事件中断回调函数里使里使LED1输出翻转。</p>
<p>TIM7设置为单次定时模式，定时周期2000ms，按下KeyRight键之后使LED2点亮，并以中断方式启动TIM7，在UEV事件中断回调函数里使里使LED2输出翻转。</p>
<h4 id="实验思路-2"><a href="#实验思路-2" class="headerlink" title="实验思路"></a>实验思路</h4><p><strong>1.</strong> <strong>使用STM32CubeMX配置时钟树</strong></p>
<p>开启RCC中的HSE。根据图片配置时钟树。LED1对应PF9，LED2对应PF10。KeyRight对应PE2，需要设置上拉电阻。</p>
<p><strong>2.</strong> <strong>使用STM32F407ZG6的基本定时器</strong></p>
<p>由于之前的配置中，APB1的频率为50Mhz，因此需要对TIM6和TIM7进行设置。</p>
<p>已知APB1为50*10^6Hz，根据定时周期进行计算，TIM6的频率为2Hz，TIM7的频率为0.5Hz。为了计算方便，将预分频器设置为10000-1，那么剩下的就是5000Hz，对于TIM6自动重载寄存器为2500-1，TIM7自动重载寄存器为10000-1。</p>
<p>以中断方式启动TIM6，在UEV事件中断回调函数里使里使LED1输出翻转。</p>
<p>在while中轮询KeyRight，检测到KeyRight为0时启动TIM7，结束之后在回调函数中关闭TIM7，使led翻转。</p>
<p>TIM7设置为单次定时模式，定时周期2000ms，按下KeyRight键之后使LED2点亮，并以中断方式启动TIM7，在UEV事件中断回调函数里使里使LED2输出翻转。</p>
<h4 id="实验步骤-2"><a href="#实验步骤-2" class="headerlink" title="实验步骤"></a>实验步骤</h4><p>1、配置时钟树和引脚。</p>
<p><img src="/2024/12/27/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%9E%E9%AA%8C%E4%B8%8E%E8%AF%BE%E8%AE%BE/image-20250101014320995.png" alt="image-20250101014320995"></p>
<p><img src="/2024/12/27/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%9E%E9%AA%8C%E4%B8%8E%E8%AF%BE%E8%AE%BE/image-20250101014349758.png" alt="image-20250101014349758"></p>
<p><img src="/2024/12/27/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%9E%E9%AA%8C%E4%B8%8E%E8%AF%BE%E8%AE%BE/image-20250101014424265.png" alt="image-20250101014424265"></p>
<p><img src="/2024/12/27/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%9E%E9%AA%8C%E4%B8%8E%E8%AF%BE%E8%AE%BE/image-20250101014455326.png" alt="image-20250101014455326"></p>
<p>2、编写代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//全局函数</span><br><span class="line">void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)&#123;</span><br><span class="line">	if(htim == &amp;htim6)&#123;</span><br><span class="line">		HAL_GPIO_TogglePin(LED1_GPIO_Port, LED1_Pin);</span><br><span class="line">	&#125;</span><br><span class="line">	if(htim == &amp;htim7)&#123;</span><br><span class="line">		HAL_GPIO_TogglePin(LED2_GPIO_Port, LED2_Pin);</span><br><span class="line">		HAL_TIM_Base_Stop_IT(&amp;htim7);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//main内部</span><br><span class="line">HAL_TIM_Base_Start_IT(&amp;htim6);</span><br><span class="line">while (1)</span><br><span class="line">&#123;</span><br><span class="line">	if(HAL_GPIO_ReadPin(KeyRight_GPIO_Port, KeyRight_Pin) == GPIO_PIN_RESET)</span><br><span class="line">	&#123;	</span><br><span class="line">		HAL_Delay(10);</span><br><span class="line">		HAL_TIM_Base_Start_IT(&amp;htim7);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、视频演示</p>
<p><video width="800" height="450" src="https://zx2023qj.github.io/2024/12/27/嵌入式实验与课设/02eeff72c743d1cba19ce02e446c9243.mp4" controls></video></p>
<h3 id="串口通信"><a href="#串口通信" class="headerlink" title="串口通信"></a>串口通信</h3><p>此处指的是usart串口通信，需要先将引脚设置为usart_rx和usart_tx模式，然后启用asyn（异步模式）</p>
<p>假设此处的usart串口为usart1_tx和usart1_rx;</p>
<h4 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h4><p>在while循环中不断重复询问是否有数据发送</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span> receive_data[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">	<span class="comment">//串口接收数据，串口为usart1，发送的数据为message，长度为strlen(message)，超时时间为100ms，如果timeout设置为hal_max_delay则表示无限等待，指的是从机接收到主机的数据</span></span><br><span class="line">	HAL_UART_Receive(&amp;huart1,receive_data,<span class="built_in">strlen</span>(receive_data),<span class="number">100</span>);</span><br><span class="line">    <span class="comment">//串口发送数据，串口为usart1，发送的数据为message，长度为strlen(message)，超时时间为100ms，如果timeout设置为hal_max_delay则表示无限等待，指的是从机发送到主机的数据</span></span><br><span class="line">	HAL_UART_Transmit(&amp;huart1,receive_data,<span class="built_in">strlen</span>(receive_data),<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="type">uint8_t</span> receive_data[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//串口接收完成数据之后的回调函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_UART_RxCpltCallback</span><span class="params">(UART_HandleTypeDef *huart)</span>&#123;</span><br><span class="line">	<span class="comment">//由于是中断，所以不需要timeout	</span></span><br><span class="line">    <span class="keyword">if</span>(huart == &amp;huart1)&#123;</span><br><span class="line">        HAL_UART_Transmit_IT(&amp;huart1,receive_data,<span class="built_in">strlen</span>(receive_data));</span><br><span class="line">        HAL_UART_Receive_IT(&amp;huart1,receive_data,<span class="built_in">strlen</span>(receive_data));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HAL_UART_Receive_IT(&amp;huart1,receive_data,<span class="built_in">strlen</span>(receive_data));</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定长DMA数据</span></span><br><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="type">uint8_t</span> receive_data[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//DMA的传输完成中断</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_UART_RxCpltCallback</span><span class="params">(UART_HandleTypeDef *huart)</span>&#123;</span><br><span class="line">	<span class="comment">//由于是中断，所以不需要timeout	</span></span><br><span class="line">    <span class="keyword">if</span>(huart == &amp;huart1)&#123;</span><br><span class="line">	HAL_UART_Transmit_DMA(&amp;huart1,receive_data,<span class="built_in">strlen</span>(receive_data));</span><br><span class="line">    HAL_UART_Receive_DMA(&amp;huart1,receive_data,<span class="built_in">strlen</span>(receive_data));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HAL_UART_Receive_DMA(&amp;huart1,receive_data,<span class="built_in">strlen</span>(receive_data));</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span> receive_data[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//DMA的传输完成中断</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_UARTEx_RxEventCallback</span><span class="params">(UART_HandleTypeDef *huart, <span class="type">uint16_t</span> Size)</span>&#123;</span><br><span class="line">	<span class="comment">//由于是中断，所以不需要timeout</span></span><br><span class="line">    <span class="keyword">if</span>(huart == &amp;huart1)&#123;</span><br><span class="line">        HAL_UART_Transmit_DMA(&amp;huart1,receive_data,Size);</span><br><span class="line">        HAL_UARTEx_ReceiveToIdle_DMA(&amp;huart1, receive_data, <span class="keyword">sizeof</span>(receive_data));</span><br><span class="line">        __HAL_DMA_DISABLE_IT(&amp;hdma_usart1_rx,DMA_IT_HT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HAL_UARTEx_ReceiveToIdle_DMA(&amp;huart1, receive_data, <span class="keyword">sizeof</span>(receive_data));</span><br><span class="line">__HAL_DMA_DISABLE_IT(&amp;hdma_usart1_rx,DMA_IT_HT);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="实验4"><a href="#实验4" class="headerlink" title="实验4"></a>实验4</h3><h4 id="实验内容-3"><a href="#实验内容-3" class="headerlink" title="实验内容"></a>实验内容</h4><p><strong>1.</strong> <strong>建立USART上位机开发环境</strong></p>
<p>在上位机（一般为PC电脑）上下载安装CH340驱动程序和XCOM串口调试软件，使用USB连接开发板和上位机后，能在XCOM软件中检测到串口SUB-SERIAL CH340。</p>
<p><strong>2.</strong> <strong>使用USART实现上位机与STM32F407ZG6通信</strong></p>
<p>MCU通过USART向上位机发送“Hello, MCU”， 串口调试软件可显示。上位机通过USART向MCU发送“ON”、“OFF”指令，分别控制LED1的亮和灭。</p>
<p>附上相关电路图，可以看到版本为CH340，usart1 RX为PA10，usart TX为PA9，LED1为PF9。</p>
<p><img src="/2024/12/27/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%9E%E9%AA%8C%E4%B8%8E%E8%AF%BE%E8%AE%BE/image-20241229171942017.png" alt="image-20241229171942017"></p>
<h4 id="实验思路-3"><a href="#实验思路-3" class="headerlink" title="实验思路"></a>实验思路</h4><p><strong>1.</strong> <strong>建立USART上位机开发环境</strong></p>
<p>安装CH340驱动程序和XCOM串口调试软件。查看CH340默认的端口配置。</p>
<p><strong>2.</strong> <strong>使用USART实现上位机与STM32F407ZG6通信</strong></p>
<p>由于需要使用不同长度的指令，因此使用DMA加不定长数据的方式。再接收数据判断然后执行不同流程。</p>
<h4 id="实验步骤-3"><a href="#实验步骤-3" class="headerlink" title="实验步骤"></a>实验步骤</h4><p>1、首先要搭建环境，在stmcubemx中对PA9和PA10进行初始化，使用异步通信加DMA的模式。将PF9设置为LED1。</p>
<p><img src="/2024/12/27/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%9E%E9%AA%8C%E4%B8%8E%E8%AF%BE%E8%AE%BE/image-20241229172405821.png" alt="image-20241229172405821"></p>
<p>2、编写代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//全局变量</span><br><span class="line">uint8_t receive_data[50];</span><br><span class="line">//全局函数</span><br><span class="line">void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size)&#123;</span><br><span class="line">	if(huart == &amp;huart1)&#123;</span><br><span class="line">		HAL_UART_Transmit_DMA(&amp;huart1, receive_data, Size);</span><br><span class="line">		receive_data[Size] = &#x27;\0&#x27;;</span><br><span class="line">		const char *on = &quot;ON&quot;;</span><br><span class="line">		const char *off = &quot;OFF&quot;;</span><br><span class="line"></span><br><span class="line">		if(!strcmp((char *)receive_data,on))&#123;</span><br><span class="line">			HAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin, GPIO_PIN_RESET);</span><br><span class="line">		&#125;</span><br><span class="line">		else if(!strcmp((char *)receive_data,off))&#123;</span><br><span class="line">			HAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin, GPIO_PIN_SET);</span><br><span class="line">		&#125;</span><br><span class="line">		HAL_UARTEx_ReceiveToIdle_DMA(&amp;huart1, receive_data, sizeof(receive_data));</span><br><span class="line">		__HAL_DMA_DISABLE_IT(&amp;hdma_usart1_rx,DMA_IT_HT);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//main函数</span><br><span class="line">HAL_UARTEx_ReceiveToIdle_DMA(&amp;huart1, receive_data, sizeof(receive_data));</span><br><span class="line">__HAL_DMA_DISABLE_IT(&amp;hdma_usart1_rx,DMA_IT_HT);</span><br></pre></td></tr></table></figure>

<p>3、测试串口是否连接成功。</p>
<p><img src="/2024/12/27/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%9E%E9%AA%8C%E4%B8%8E%E8%AF%BE%E8%AE%BE/image-20241231144542469.png" alt="image-20241231144542469"></p>
<p>4、演示视频</p>
<p><video width="800" height="450" src="https://zx2023qj.github.io/2024/12/27/嵌入式实验与课设/2024-12-31 14-36-08.mkv" controls></video></p>
<h3 id="实验5"><a href="#实验5" class="headerlink" title="实验5"></a>实验5</h3><h4 id="实验内容-4"><a href="#实验内容-4" class="headerlink" title="实验内容"></a>实验内容</h4><p><strong>1.</strong> <strong>集成和调式SPI驱动程序</strong></p>
<p>使用教材或开发板厂商提供的驱动程序文件，将w25flash.h、w25flash.c集成到工程。通过修改调试，使得驱动程序可以正常运行。</p>
<p><strong>2.</strong> <strong>通过SPI读写Flash存储芯片BY25Q128AS</strong></p>
<p>MCU在Flash中写入“Hello, MCU”等内容。MCU重启后，从Flash中读取内同，通过USART发送到上位机串口调试软件显示。</p>
<h4 id="实验思路-4"><a href="#实验思路-4" class="headerlink" title="实验思路"></a>实验思路</h4><p><strong>1.</strong> <strong>集成和调式SPI驱动程序</strong></p>
<p>将驱动文件合并到工程中。</p>
<p><strong>2.</strong> <strong>通过SPI读写Flash存储芯片BY25Q128AS</strong></p>
<p>通过驱动文件中的函数对flash进行读写。</p>
<h4 id="实验步骤-4"><a href="#实验步骤-4" class="headerlink" title="实验步骤"></a>实验步骤</h4><p>1、配置引脚</p>
<p><img src="/2024/12/27/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%9E%E9%AA%8C%E4%B8%8E%E8%AF%BE%E8%AE%BE/image-20250101045445534.png" alt="image-20250101045445534"></p>
<p>注意cubemx自动配置的引脚可能是错误的。</p>
<p><img src="/2024/12/27/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%9E%E9%AA%8C%E4%B8%8E%E8%AF%BE%E8%AE%BE/image-20250101045508421.png" alt="image-20250101045508421"></p>
<p>2、编写代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;w25flash.h&quot;</span><br><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#include &quot;string.h&quot;</span><br><span class="line"></span><br><span class="line">#ifdef __GNUC__</span><br><span class="line">#define PUTCHAR_PROTOTYPE int __io_putchar(int ch)</span><br><span class="line">#else</span><br><span class="line">#define PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f)</span><br><span class="line">#endif</span><br><span class="line">PUTCHAR_PROTOTYPE</span><br><span class="line">&#123;</span><br><span class="line">      HAL_UART_Transmit(&amp;huart1, (uint8_t *)&amp;ch, 1, HAL_MAX_DELAY);</span><br><span class="line">      return ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//定义函数</span><br><span class="line">void Flash_Write(void)</span><br><span class="line">&#123;</span><br><span class="line">	uint8_t blobkNo = 0;</span><br><span class="line">	uint16_t sectorNo = 0;</span><br><span class="line">	uint16_t pageNo = 0;</span><br><span class="line">	uint32_t memAddress = 0;</span><br><span class="line"></span><br><span class="line">	printf(&quot;---------------------\r\n&quot;);</span><br><span class="line">	//写入Page0两个字符串</span><br><span class="line">	memAddress = Flash_Addr_byBlockSectorPage(blobkNo, sectorNo, pageNo);		//Page0的地址</span><br><span class="line">	uint8_t	bufStr1[] = &quot;Hello MCU&quot;;</span><br><span class="line">	uint16_t len = 1 + strlen(&quot;Hello MCU&quot;); 											//包括结束符&#x27;\0&#x27;</span><br><span class="line">	Flash_WriteInPage(memAddress, bufStr1, len);   													//在Page0的起始位置写入数据</span><br><span class="line">	printf(&quot;Write in Page0:0\r\n%s\r\n&quot;, bufStr1);</span><br><span class="line">	printf(&quot;---------------------\r\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//读取Page0的内容</span><br><span class="line">void Flash_Read(void)</span><br><span class="line">&#123;</span><br><span class="line">	uint8_t blobkNo=0;</span><br><span class="line">	uint16_t sectorNo=0;</span><br><span class="line">	uint16_t pageNo=0;</span><br><span class="line"></span><br><span class="line">	printf(&quot;---------------------\r\n&quot;);</span><br><span class="line">	//读取Page0</span><br><span class="line">	uint8_t bufStr[50];																											//Page0读出的数据</span><br><span class="line">	uint32_t memAddress = Flash_Addr_byBlockSectorPage(blobkNo, sectorNo,pageNo);</span><br><span class="line">	Flash_ReadBytes(memAddress, bufStr, 50);																//读取50个字符</span><br><span class="line">	printf(&quot;Read from Page0:0\r\n%s\r\n&quot;,bufStr);</span><br><span class="line">	printf(&quot;---------------------\r\n&quot;</span><br><span class="line"></span><br><span class="line">//main函数中循环外部</span><br><span class="line">uint16_t ID = Flash_ReadID();</span><br><span class="line">printf(&quot;W25Q128 ID:0x%x\r\n&quot;,ID);</span><br><span class="line">printf(&quot;---------------------\r\n&quot;);</span><br><span class="line">//清空flash</span><br><span class="line">uint32_t globalAddr=0;</span><br><span class="line">Flash_EraseBlock64K(globalAddr);</span><br><span class="line"></span><br><span class="line">Flash_Write();</span><br><span class="line">HAL_Delay(1000);</span><br><span class="line">Flash_Read();</span><br></pre></td></tr></table></figure>

<p>3、视频演示</p>
<p><video width="800" height="450" src="https://zx2023qj.github.io/2024/12/27/嵌入式实验与课设/2025-01-01 04-50-08.mkv" controls></video></p>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.cnblogs.com/lc-guo/p/17965537</span><br></pre></td></tr></table></figure>

<h3 id="实验6"><a href="#实验6" class="headerlink" title="实验6"></a>实验6</h3><h4 id="实验内容-5"><a href="#实验内容-5" class="headerlink" title="实验内容"></a>实验内容</h4><p><strong>1.</strong> <strong>移植鸿蒙LiteOS-M到STM32</strong></p>
<p>掌握如何将 LiteOS-M 系统移植到 STM32平台上，理解嵌入式操作系统移植的基本原理和流程，学习如何适配硬件平台。 </p>
<p><strong>2.</strong> <strong>开发基于鸿蒙LiteOS-M的多任务程序</strong></p>
<p>掌握鸿蒙 LiteOS-M 操作系统的多任务管理功能，学习如何在实时操作系统中创建、调度和管理多个任务。</p>
<h4 id="实验思路-5"><a href="#实验思路-5" class="headerlink" title="实验思路"></a>实验思路</h4><p>1、对代码进行编译。</p>
<p>2、创建任务，查看任务是否完成。</p>
<h4 id="实验步骤-5"><a href="#实验步骤-5" class="headerlink" title="实验步骤"></a>实验步骤</h4><p>跟着<a target="_blank" rel="noopener" href="https://jeckxu666.blog.csdn.net/article/details/123971394">【OpenHarmony】移植 3.1 版本系统到 STM32_openharmony移植到stm32-CSDN博客</a>一步一步操作。</p>
<p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;los_task.h&quot;</span><br><span class="line">#include &quot;los_typedef.h&quot;</span><br><span class="line">#include &quot;los_sys.h&quot;</span><br><span class="line">#include &quot;los_api_task.h&quot;</span><br><span class="line">#include &quot;usart.h&quot;  // 假设已实现 USART 的初始化与发送功能</span><br><span class="line"></span><br><span class="line">#define TASK1_PRIORITY 5</span><br><span class="line">#define TASK2_PRIORITY 6</span><br><span class="line">#define TASK1_STACK_SIZE 0x1000</span><br><span class="line">#define TASK2_STACK_SIZE 0x1000</span><br><span class="line"></span><br><span class="line">// 任务ID</span><br><span class="line">UINT32 g_task1Id;</span><br><span class="line">UINT32 g_task2Id;</span><br><span class="line"></span><br><span class="line">// 任务1函数：每隔1秒打印内容</span><br><span class="line">VOID Task1(VOID) &#123;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        USART_SendString(&quot;Task1: Running...\r\n&quot;);  // USART 输出</span><br><span class="line">        LOS_TaskDelay(1000);  // 延时1秒，单位是毫秒</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 任务2函数：每隔5秒挂起和恢复任务1</span><br><span class="line">VOID Task2(VOID) &#123;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        // 挂起任务1</span><br><span class="line">        LOS_TaskSuspend(g_task1Id);</span><br><span class="line">        USART_SendString(&quot;Task2: Task1 Suspended\r\n&quot;);</span><br><span class="line"></span><br><span class="line">        // 延时5秒</span><br><span class="line">        LOS_TaskDelay(5000);</span><br><span class="line"></span><br><span class="line">        // 恢复任务1</span><br><span class="line">        LOS_TaskResume(g_task1Id);</span><br><span class="line">        USART_SendString(&quot;Task2: Task1 Resumed\r\n&quot;);</span><br><span class="line"></span><br><span class="line">        // 延时5秒</span><br><span class="line">        LOS_TaskDelay(5000);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 主函数：创建任务</span><br><span class="line">VOID AppMain(VOID) &#123;</span><br><span class="line">    // 初始化 UART</span><br><span class="line">    USART_Init();  // 假设已实现初始化函数</span><br><span class="line"></span><br><span class="line">    // 任务属性结构体</span><br><span class="line">    TSK_INIT_PARAM_S task1Params;</span><br><span class="line">    TSK_INIT_PARAM_S task2Params;</span><br><span class="line"></span><br><span class="line">    // 初始化任务1参数</span><br><span class="line">    task1Params.pfnTaskEntry = (TSK_ENTRY_FUNC)Task1;</span><br><span class="line">    task1Params.uwStackSize = TASK1_STACK_SIZE;</span><br><span class="line">    task1Params.pcName = &quot;Task1&quot;;</span><br><span class="line">    task1Params.usTaskPrio = TASK1_PRIORITY;</span><br><span class="line">    task1Params.uwResved = LOS_TASK_STATUS_DETACHED;</span><br><span class="line"></span><br><span class="line">    // 初始化任务2参数</span><br><span class="line">    task2Params.pfnTaskEntry = (TSK_ENTRY_FUNC)Task2;</span><br><span class="line">    task2Params.uwStackSize = TASK2_STACK_SIZE;</span><br><span class="line">    task2Params.pcName = &quot;Task2&quot;;</span><br><span class="line">    task2Params.usTaskPrio = TASK2_PRIORITY;</span><br><span class="line">    task2Params.uwResved = LOS_TASK_STATUS_DETACHED;</span><br><span class="line"></span><br><span class="line">    // 创建任务1</span><br><span class="line">    if (LOS_TaskCreate(&amp;g_task1Id, &amp;task1Params) != LOS_OK) &#123;</span><br><span class="line">        USART_SendString(&quot;Error: Failed to create Task1\r\n&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 创建任务2</span><br><span class="line">    if (LOS_TaskCreate(&amp;g_task2Id, &amp;task2Params) != LOS_OK) &#123;</span><br><span class="line">        USART_SendString(&quot;Error: Failed to create Task2\r\n&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>视频演示</p>
<p><video width="800" height="450" src="https://zx2023qj.github.io/2024/12/27/嵌入式实验与课设/2025-01-01 10-05-56.mkv" controls></video></p>
<h3 id="PWM"><a href="#PWM" class="headerlink" title="PWM"></a>PWM</h3><p>使用数字信号模拟模拟信号。</p>
<p>PWM是使用定时器的输出比较模式实现的，该模式存在冻结模式（直接输出），强制有效（一直为有效电平），强制无效（一直为无效电平），匹配时有效，匹配时无效，匹配时翻转等，其中PWM是由PWM模式实现的。</p>
<p>向上计数模式（计数器从0到自动重装载寄存器）<br>PWM模式1，计数器比比较寄存器小时有效，大于等于时无效。<br>PWM模式2，计数器比比较寄存器小时无效，大于等于时有效。<br>向下计数模式（计数器从自动重装载寄存器到0）<br>PWM模式1，计数器比比较寄存器小于等于时有效，大于时无效。<br>PWM模式2，计数器比比较寄存器小时等于无效，大于时有效。<br>向上向下计数模式（计数器从0到自动重装载寄存器到0）<br>PWM模式1，计数器比比较寄存器小于等于时有效，大于时无效。<br>PWM模式2，计数器比比较寄存器小时等于无效，大于时有效。</p>
<p><img src="/2024/12/27/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%9E%E9%AA%8C%E4%B8%8E%E8%AF%BE%E8%AE%BE/image-20241231222508567.png" alt="image-20241231222508567"></p>
<p>有效电平和无效电平不一定对应高和低电平，可以调节。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//PWM相关函数</span><br><span class="line">//启动PWM</span><br><span class="line">HAL_TIM_PWM_Start(htim,TIM_CHANNEL);</span><br><span class="line">//设置比较寄存器的值</span><br><span class="line">__HAL_TIM_SET_COMPARE(htim,TIM_CHANNEL,value);</span><br></pre></td></tr></table></figure>

<h3 id="实验7"><a href="#实验7" class="headerlink" title="实验7"></a>实验7</h3><h4 id="实验内容-6"><a href="#实验内容-6" class="headerlink" title="实验内容"></a>实验内容</h4><p><strong>1.</strong> <strong>集成和调试TFT LCD显示驱动程序（FSMC模块和LCD模块）</strong></p>
<p>使用教材或开发板厂商提供的驱动程序文件，将font.h、tftlcd.h和tftlcd.c集成到工程。通过修改调试，使得驱动程序可以正常运行，并在开发板的TTF LCD上显示“Hello, MCU”。</p>
<p><strong>2.</strong> <strong>启用和配置实时时钟（RTC模块）</strong></p>
<p>在LCD上显示日期和时间，秒数每秒变化一次。</p>
<p><strong>3.</strong> <strong>启用配置闹钟（GPIO模块）</strong></p>
<p>设置一组或多组闹钟，闹钟触发时控制开发板上蜂鸣器响5秒、LED1每0.5秒翻转一次。</p>
<p><strong>4.</strong> <strong>上位机设置时钟（USART模块）</strong></p>
<p>将时间转换为字符串之后通过串口发送给上位机串口调试软件显示，每秒刷新一次。上位机向MCU发送时间修改指令，MCU能够解析和执行指令，并按照指令修改时间。</p>
<h4 id="实验思路-6"><a href="#实验思路-6" class="headerlink" title="实验思路"></a>实验思路</h4><p>对功能进行逐个实现。</p>
<p>先完成RTC模块，闹钟模块，再完成LCD模块和USART模块。</p>
<h4 id="实验步骤-6"><a href="#实验步骤-6" class="headerlink" title="实验步骤"></a>实验步骤</h4><p>1、启动TFTLCD，首先要对FSMC进行初始化。</p>
<p><img src="/2024/12/27/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%9E%E9%AA%8C%E4%B8%8E%E8%AF%BE%E8%AE%BE/image-20250101172210369.png" alt="image-20250101172210369"></p>
<p>2、根据驱动，对TFTLCD进行初始化。测试TFTLCD的效果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">TFTLCD_Init();</span><br><span class="line">FRONT_COLOR=BLACK;</span><br><span class="line">LCD_ShowString(10,10,tftlcd_data.width,tftlcd_data.height,12,&quot;Hello World!&quot;);</span><br><span class="line">LCD_ShowString(10,30,tftlcd_data.width,tftlcd_data.height,16,&quot;Hello World!&quot;);</span><br><span class="line">LCD_ShowString(10,50,tftlcd_data.width,tftlcd_data.height,24,&quot;Hello World!&quot;);</span><br><span class="line">LCD_ShowFontHZ(10, 80,&quot;普中科技&quot;);</span><br><span class="line">LCD_ShowString(10,120,tftlcd_data.width,tftlcd_data.height,24,&quot;www.prechin.cn&quot;);</span><br><span class="line">LCD_Fill(10,150,60,180,GRAY);</span><br><span class="line">uint16_t color=0;</span><br><span class="line">color=LCD_ReadPoint(20,160);</span><br><span class="line">LCD_Fill(100,150,150,180,color);</span><br><span class="line">printf(&quot;color=%x\r\n&quot;,color);</span><br></pre></td></tr></table></figure>

<p>3、启动RTC，RTC需要使用内部时钟，需要进行配置。</p>
<p><img src="/2024/12/27/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%9E%E9%AA%8C%E4%B8%8E%E8%AF%BE%E8%AE%BE/image-20250101172807179.png" alt="image-20250101172807179"></p>
<p><img src="/2024/12/27/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%9E%E9%AA%8C%E4%B8%8E%E8%AF%BE%E8%AE%BE/image-20250101172756141.png" alt="image-20250101172756141"></p>
<p>4、对uart进行配置</p>
<p><img src="/2024/12/27/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%9E%E9%AA%8C%E4%B8%8E%E8%AF%BE%E8%AE%BE/image-20250101203449436.png" alt="image-20250101203449436"></p>
<p>5、完成实验要求</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//在LCD上输出Hello, MCU</span><br><span class="line">LCD_ShowString(10,130,tftlcd_data.width,tftlcd_data.height,24,&quot;Hello,MCU&quot;);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//启用闹钟，配置RTC的回调函数</span><br><span class="line">void HAL_RTCEx_WakeUpTimerEventCallback(RTC_HandleTypeDef *hrtc)&#123;</span><br><span class="line">	RTC_TimeTypeDef sTime;</span><br><span class="line">	RTC_DateTypeDef sDate;</span><br><span class="line">    if(HAL_RTC_GetTime(hrtc, &amp;sTime, RTC_FORMAT_BIN) == HAL_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        HAL_RTC_GetDate(hrtc, &amp;sDate,  RTC_FORMAT_BIN);</span><br><span class="line">        year = sDate.Year;</span><br><span class="line">        month = sDate.Month;</span><br><span class="line">        weekday = sDate.WeekDay;</span><br><span class="line">        date = sDate.Date;</span><br><span class="line">        hour = sTime.Hours;</span><br><span class="line">        minute = sTime.Minutes;</span><br><span class="line">        second = sTime.Seconds;</span><br><span class="line">        char str[30];</span><br><span class="line">       sprintf(str,&quot;%02d:%02d:%02d&quot;,hour,minute,second);</span><br><span class="line">        LCD_ShowString(10,130,tftlcd_data.width,tftlcd_data.height,24,str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void HAL_RTC_AlarmAEventCallback(RTC_HandleTypeDef *hrtc)&#123;</span><br><span class="line">    char infoA[]=&quot;Alarm A(xx:xx:30) trigger: \r\n&quot;;</span><br><span class="line">    printf(&quot;%s&quot;, infoA);</span><br><span class="line">    HAL_GPIO_TogglePin(LED1_GPIO_Port,LED1_Pin);</span><br><span class="line">    HAL_GPIO_TogglePin(BEEP_GPIO_Port, BEEP_Pin);</span><br><span class="line">    HAL_Delay(500);</span><br><span class="line">    HAL_GPIO_TogglePin(BEEP_GPIO_Port, BEEP_Pin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">//使用串口控制时间</span><br><span class="line">int ParseAndSetRTC(const char *input_string, RTC_HandleTypeDef *hrtc) &#123;</span><br><span class="line">    // 检查输入字符串是否为 NULL</span><br><span class="line">    if (input_string == NULL || strlen(input_string) != 12 || strncmp(input_string, &quot;change&quot;, 6) != 0) &#123;</span><br><span class="line">        return -1; // 输入字符串格式不正确</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 提取小时、分钟和秒</span><br><span class="line">    char hour_str[3] = &#123;0&#125;;</span><br><span class="line">    char minute_str[3] = &#123;0&#125;;</span><br><span class="line">    char second_str[3] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">    strncpy(hour_str, input_string + 6, 2);</span><br><span class="line">    strncpy(minute_str, input_string + 8, 2);</span><br><span class="line">    strncpy(second_str, input_string + 10, 2);</span><br><span class="line"></span><br><span class="line">    int hour = atoi(hour_str);</span><br><span class="line">    int minute = atoi(minute_str);</span><br><span class="line">    int second = atoi(second_str);</span><br><span class="line"></span><br><span class="line">    // 验证时间是否合法</span><br><span class="line">    if (hour &lt; 0 || hour &gt; 23 || minute &lt; 0 || minute &gt; 59 || second &lt; 0 || second &gt; 59) &#123;</span><br><span class="line">        return -1; // 时间无效</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 设置 RTC 时间</span><br><span class="line">    RTC_TimeTypeDef sTime = &#123;0&#125;;</span><br><span class="line">    sTime.Hours = hour;</span><br><span class="line">    sTime.Minutes = minute;</span><br><span class="line">    sTime.Seconds = second;</span><br><span class="line">    sTime.DayLightSaving = RTC_DAYLIGHTSAVING_NONE;</span><br><span class="line">    sTime.StoreOperation = RTC_STOREOPERATION_RESET;</span><br><span class="line"></span><br><span class="line">    HAL_RTC_SetTime(hrtc, &amp;sTime, RTC_FORMAT_BIN);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//DMA的传输完成中断</span><br><span class="line">void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size)&#123;</span><br><span class="line">	//由于是中断，所以不需要timeout</span><br><span class="line">    if(huart == &amp;huart1)&#123;</span><br><span class="line">        HAL_UART_Transmit_DMA(&amp;huart1,receive_data,Size);</span><br><span class="line">        ParseAndSetRTC(receive_data, &amp;hrtc);</span><br><span class="line">        HAL_UARTEx_ReceiveToIdle_DMA(&amp;huart1, receive_data, sizeof(receive_data));</span><br><span class="line">        __HAL_DMA_DISABLE_IT(&amp;hdma_usart1_rx,DMA_IT_HT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、视频演示</p>
<p><video width="800" height="450" src="https://zx2023qj.github.io/2024/12/27/嵌入式实验与课设/2025-01-01 19-18-49.mkv" controls></video></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://zx2023qj.github.io">zx</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://zx2023qj.github.io/2024/12/27/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%9E%E9%AA%8C%E4%B8%8E%E8%AF%BE%E8%AE%BE/">https://zx2023qj.github.io/2024/12/27/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%9E%E9%AA%8C%E4%B8%8E%E8%AF%BE%E8%AE%BE/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zx2023qj.github.io" target="_blank">zx's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%97%A5%E5%B8%B8/">日常</a><a class="post-meta__tags" href="/tags/%E4%BD%9C%E4%B8%9A/">作业</a></div><div class="post_share"><div class="social-share" data-image="/img/3.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2024/12/27/c%E7%9B%98%E6%B8%85%E7%90%86/" title="从来没有觉得清理c盘快乐过"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">从来没有觉得清理c盘快乐过</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/11/14/BIM-CIM%E8%AE%BE%E8%AE%A1/" title="BIM&#x2F;CIM设计"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-14</div><div class="title">BIM&#x2F;CIM设计</div></div></a></div><div><a href="/2024/12/19/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E9%AA%8C-%E8%AF%BE%E8%AE%BE/" title="数据库实验 &amp; 课设"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-19</div><div class="title">数据库实验 &amp; 课设</div></div></a></div><div><a href="/2024/09/02/%E5%BF%83%E6%83%85%E4%B8%8D%E5%A5%BD%E5%86%99%E7%82%B9/" title="心情不好写点 &amp; 2024年8月总结"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-02</div><div class="title">心情不好写点 &amp; 2024年8月总结</div></div></a></div><div><a href="/2024/09/05/%E5%86%8D%E6%B0%B4%E4%B8%80%E7%AF%87%E6%97%A5%E5%B8%B8/" title="再水一篇日常"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-05</div><div class="title">再水一篇日常</div></div></a></div><div><a href="/2024/09/18/2024%E4%B8%AD%E7%A7%8B/" title="2024中秋"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-18</div><div class="title">2024中秋</div></div></a></div><div><a href="/2024/10/04/2024%E5%9B%BD%E5%BA%86/" title="2024国庆"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-04</div><div class="title">2024国庆</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/3.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">zx</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">32</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">30</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">20</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/zx2023qj"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E0%E5%88%B01%E7%9A%84%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85"><span class="toc-number">1.</span> <span class="toc-text">从0到1的嵌入式之旅</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C1"><span class="toc-number">1.1.</span> <span class="toc-text">实验1</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E5%86%85%E5%AE%B9"><span class="toc-number">1.1.1.</span> <span class="toc-text">实验内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E6%80%9D%E8%B7%AF"><span class="toc-number">1.1.2.</span> <span class="toc-text">实验思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.1.3.</span> <span class="toc-text">实验步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85"><span class="toc-number">1.1.4.</span> <span class="toc-text">知识补充</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GPIO%E5%85%AB%E5%A4%A7%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%A8%A1%E5%BC%8F%E8%A7%A3%E6%9E%90"><span class="toc-number">1.2.</span> <span class="toc-text">GPIO八大输入输出模式解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E6%9D%A1%E4%BB%B6"><span class="toc-number">1.3.</span> <span class="toc-text">中断条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C2"><span class="toc-number">1.4.</span> <span class="toc-text">实验2</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E5%86%85%E5%AE%B9-1"><span class="toc-number">1.4.1.</span> <span class="toc-text">实验内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E6%80%9D%E8%B7%AF-1"><span class="toc-number">1.4.2.</span> <span class="toc-text">实验思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E6%AD%A5%E9%AA%A4-1"><span class="toc-number">1.4.3.</span> <span class="toc-text">实验步骤</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-number">1.5.</span> <span class="toc-text">定时器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C3"><span class="toc-number">1.6.</span> <span class="toc-text">实验3</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E5%86%85%E5%AE%B9-2"><span class="toc-number">1.6.1.</span> <span class="toc-text">实验内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E6%80%9D%E8%B7%AF-2"><span class="toc-number">1.6.2.</span> <span class="toc-text">实验思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E6%AD%A5%E9%AA%A4-2"><span class="toc-number">1.6.3.</span> <span class="toc-text">实验步骤</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1"><span class="toc-number">1.7.</span> <span class="toc-text">串口通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AE%E8%AF%A2"><span class="toc-number">1.7.1.</span> <span class="toc-text">轮询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD"><span class="toc-number">1.7.2.</span> <span class="toc-text">中断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DMA"><span class="toc-number">1.7.3.</span> <span class="toc-text">DMA</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C4"><span class="toc-number">1.8.</span> <span class="toc-text">实验4</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E5%86%85%E5%AE%B9-3"><span class="toc-number">1.8.1.</span> <span class="toc-text">实验内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E6%80%9D%E8%B7%AF-3"><span class="toc-number">1.8.2.</span> <span class="toc-text">实验思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E6%AD%A5%E9%AA%A4-3"><span class="toc-number">1.8.3.</span> <span class="toc-text">实验步骤</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C5"><span class="toc-number">1.9.</span> <span class="toc-text">实验5</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E5%86%85%E5%AE%B9-4"><span class="toc-number">1.9.1.</span> <span class="toc-text">实验内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E6%80%9D%E8%B7%AF-4"><span class="toc-number">1.9.2.</span> <span class="toc-text">实验思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E6%AD%A5%E9%AA%A4-4"><span class="toc-number">1.9.3.</span> <span class="toc-text">实验步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="toc-number">1.9.4.</span> <span class="toc-text">参考链接</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C6"><span class="toc-number">1.10.</span> <span class="toc-text">实验6</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E5%86%85%E5%AE%B9-5"><span class="toc-number">1.10.1.</span> <span class="toc-text">实验内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E6%80%9D%E8%B7%AF-5"><span class="toc-number">1.10.2.</span> <span class="toc-text">实验思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E6%AD%A5%E9%AA%A4-5"><span class="toc-number">1.10.3.</span> <span class="toc-text">实验步骤</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PWM"><span class="toc-number">1.11.</span> <span class="toc-text">PWM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C7"><span class="toc-number">1.12.</span> <span class="toc-text">实验7</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E5%86%85%E5%AE%B9-6"><span class="toc-number">1.12.1.</span> <span class="toc-text">实验内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E6%80%9D%E8%B7%AF-6"><span class="toc-number">1.12.2.</span> <span class="toc-text">实验思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E6%AD%A5%E9%AA%A4-6"><span class="toc-number">1.12.3.</span> <span class="toc-text">实验步骤</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/27/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%9E%E9%AA%8C%E4%B8%8E%E8%AF%BE%E8%AE%BE/" title="嵌入式实验与课设">嵌入式实验与课设</a><time datetime="2024-12-27T12:48:44.000Z" title="发表于 2024-12-27 20:48:44">2024-12-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/27/c%E7%9B%98%E6%B8%85%E7%90%86/" title="从来没有觉得清理c盘快乐过">从来没有觉得清理c盘快乐过</a><time datetime="2024-12-27T06:59:58.000Z" title="发表于 2024-12-27 14:59:58">2024-12-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/19/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E9%AA%8C-%E8%AF%BE%E8%AE%BE/" title="数据库实验 &amp; 课设">数据库实验 &amp; 课设</a><time datetime="2024-12-19T03:24:55.000Z" title="发表于 2024-12-19 11:24:55">2024-12-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/18/ciscn2024-%C3%97-ccb/" title="ciscn2024 × ccb">ciscn2024 × ccb</a><time datetime="2024-12-18T05:10:27.000Z" title="发表于 2024-12-18 13:10:27">2024-12-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/06/%E6%AF%9B%E6%A6%82%E5%A4%8D%E4%B9%A0/" title="毛概复习">毛概复习</a><time datetime="2024-12-06T13:59:03.000Z" title="发表于 2024-12-06 21:59:03">2024-12-06</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By zx</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>